<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL及常用算法</title>
      <link href="/2020/03/07/STL%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/07/STL%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>STL及常用算法的总结</p><a id="more"></a><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    int data;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bool operator &lt; (const node &amp;b)const&#123; &#x2F;&#x2F;重载运算符</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        return data &lt; b.data;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;队列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    queue&lt;node&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;优先队列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    priority_queue&lt;int&gt;qu; &#x2F;&#x2F;从大到小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qu; &#x2F;&#x2F;从小到大</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    priority_queue&lt;node&gt;qu; &#x2F;&#x2F;结构体</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    qu.push(&#123;1&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    qu.push(&#123;2&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    cout &lt;&lt; qu.top().data &lt;&lt; endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;集合</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    set&lt;int&gt;st;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    st.insert(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    set&lt;int&gt;::iterator it;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    it &#x3D; st.lower_bound(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    st.insert(st.begin(), st.end());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;映射</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    map&lt;int,int&gt;mp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    map&lt;int,int&gt;::iterator it;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    mp[1] &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    it &#x3D; mp.lower_bound(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 10010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">int pre[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int fin(int x)&#123;return x &#x3D;&#x3D; pre[x] ? x : pre[x] &#x3D; fin(pre[x]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int n &#x3D; maxn;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; n; i++)pre[i] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int x &#x3D; fin(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    int y &#x3D; fin(2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    if(x !&#x3D; y)pre[x] &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="搜索-DFS-amp-amp-BFS"><a href="#搜索-DFS-amp-amp-BFS" class="headerlink" title="搜索 DFS &amp;&amp; BFS"></a>搜索 DFS &amp;&amp; BFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 10010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;mp[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int n, vis[maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">void dfs(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    vis[x] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; mp[x].size(); i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        int v &#x3D; mp[x][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        if(vis[v] &#x3D;&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            dfs(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    vis[x] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">void bfs(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    qu.push(x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    vis[x] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    while(!qu.empty())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        int w &#x3D; qu.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        qu.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 0; i &lt; mp[w].size(); i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            int v &#x3D; mp[w][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            if(vis[v] &#x3D;&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                qu.push(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                vis[v] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="最短路-Dijstra-amp-amp-Floyd-amp-amp-SPFA"><a href="#最短路-Dijstra-amp-amp-Floyd-amp-amp-SPFA" class="headerlink" title="最短路 Dijstra &amp;&amp; Floyd &amp;&amp; SPFA"></a>最短路 Dijstra &amp;&amp; Floyd &amp;&amp; SPFA</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    mp[1].push_back(2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    mp[2].push_back(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    dfs(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bfs(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">#define inf 0x3f3f3f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">int mp[maxn][maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">int n &#x3D; 3, st &#x3D; 1, ed &#x3D; 3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">void dij()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    int dis[maxn], vis[maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    vis[st] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    dis[st] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; -1, minn &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            if(dis[j] &lt; minn)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                minn &#x3D; dis[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                u &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        if(u &gt; 0)vis[u] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        else continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            if(vis[j] &#x3D;&#x3D; 0 &amp;&amp; dis[j] &gt; dis[u] + mp[u][j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                dis[j] &#x3D; dis[u] + mp[u][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">void floyd()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    int i, j, k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    for(k &#x3D; 1; k &lt;&#x3D; n; k++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">            for(j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                if(mp[i][j] &gt; mp[i][k] + mp[k][j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                    mp[i][j] &#x3D; mp[i][k] + mp[k][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">int spfa()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    int vis[maxn] &#x3D; &#123;0&#125;, dis[maxn], cnt[maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    dis[st] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    qu.push(st);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    vis[st] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    cnt[st]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    while(!qu.empty())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        int w &#x3D; qu.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        qu.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            if(vis[i] &#x3D;&#x3D; 0 &amp;&amp; dis[i] &gt; dis[w] + mp[w][i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">                dis[i] &#x3D; dis[w] + mp[w][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">                vis[i] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">                qu.push(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">                cnt[i]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">        vis[w] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    return dis[ed];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    mp[1][2] &#x3D; mp[2][1] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">    mp[1][3] &#x3D; mp[3][1] &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">    mp[2][3] &#x3D; mp[3][2] &#x3D; 4;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    cout &lt;&lt; spfa();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polya</title>
      <link href="/2020/03/07/Polya/"/>
      <url>/2020/03/07/Polya/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Polya的总结</p><a id="more"></a><h2 id="Step1-Polya-定理"><a href="#Step1-Polya-定理" class="headerlink" title="Step1 - Polya-定理"></a>Step1 - Polya-定理</h2><h3 id="设-G-是-n-个对象的一个置换群-用m种颜色染图这-n-个对象，则不同的染色方案数为："><a href="#设-G-是-n-个对象的一个置换群-用m种颜色染图这-n-个对象，则不同的染色方案数为：" class="headerlink" title="设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为："></a>设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为：</h3><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D248/sign=d4a125768b13632711edc537a98ea056/d62a6059252dd42aed4ab801023b5bb5c8eab8dd.jpg" alt="img"></p><h3 id="其中-G-P1-P2-P3-…-Pg-C-Pk-表示-Pk-的循环节。"><a href="#其中-G-P1-P2-P3-…-Pg-C-Pk-表示-Pk-的循环节。" class="headerlink" title="其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。"></a>其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。</h3><h2 id="Step2-Polya-定理的引入与简单理解"><a href="#Step2-Polya-定理的引入与简单理解" class="headerlink" title="Step2 - Polya-定理的引入与简单理解"></a>Step2 - Polya-定理的引入与简单理解</h2><p>参考博客：<a href="https://blog.csdn.net/lyc1635566ty/article/details/52545355" target="_blank" rel="noopener">https://blog.csdn.net/lyc1635566ty/article/details/52545355</a></p><p>参考视频：<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+60240013X+sp/about" target="_blank" rel="noopener">学堂在线-组合数学</a></p><h3 id="一、前置知识："><a href="#一、前置知识：" class="headerlink" title="一、前置知识："></a>一、前置知识：</h3><h4 id="1-置换："><a href="#1-置换：" class="headerlink" title="1.置换："></a>1.置换：</h4><p>其实就是集合 G 到 G 的一个双射，例如：</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D151/sign=9fe21a940df3d7ca08f63b73c31ebe3c/ac345982b2b7d0a20b345937caef76094a369a9e.jpg" alt="img"></p><p>也就是说每次变换，1 –&gt; a1，2 –&gt; a2，…，n –&gt; an。</p><h4 id="2-置换的乘法："><a href="#2-置换的乘法：" class="headerlink" title="2.置换的乘法："></a>2.置换的乘法：</h4><p>例如定义 P1, P2两个置换。<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D135/sign=6490ef9ba08b87d65442af1c32092860/91529822720e0cf3004613510b46f21fbf09aae3.jpg" alt="img"></p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D135/sign=61b8456fe1fe9925cf0c6d5301a95ee4/9e3df8dcd100baa196801a114610b912c9fc2eef.jpg" alt="img"></p><p>定义置换乘法：</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D266/sign=8e8ec5ae5882b2b7a39f3ec207accb0a/f11f3a292df5e0feb6efd4ab5d6034a85fdf72a0.jpg" alt="img"></p><p><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D346/sign=fe3b02fa0d33874498c52978670ed937/b3b7d0a20cf431adc3f01f934a36acaf2edd987d.jpg" alt="img"></p><p>表示先作 P1 的置换，再作 P2 的置换。</p><h4 id="3-Burnside引理"><a href="#3-Burnside引理" class="headerlink" title="3.Burnside引理:"></a>3.Burnside引理:</h4><p>设G={a1,a2,…ag}是目标集[1,n]上的置换群。每个置换都写成不相交循环的乘积。 是在置换ak的作用下不动点的个数，也就是长度为1的循环的个数。通过上述置换的变换操作后可以相等的元素属于同一个等价类。若G将[1,n]划分成l个等价类，则等价类个数为：</p><p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D249/sign=4819311e96eef01f49141fc1d9ff99e0/94cad1c8a786c91783a8da43cb3d70cf3bc75725.jpg" alt="img"></p><h3 id="二、Polya定理的引出："><a href="#二、Polya定理的引出：" class="headerlink" title="二、Polya定理的引出："></a>二、Polya定理的引出：</h3><p>设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为：</p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D248/sign=d4a125768b13632711edc537a98ea056/d62a6059252dd42aed4ab801023b5bb5c8eab8dd.jpg" alt="img"></p><p>其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。</p><h2 id="Step3-Polya-定理的使用"><a href="#Step3-Polya-定理的使用" class="headerlink" title="Step3 - Polya-定理的使用"></a>Step3 - Polya-定理的使用</h2><ol><li>确定置换的个数（旋转角度，翻转）</li><li>确定循环节个数（旋转角度时考虑 gcd，翻转时特殊考虑）</li><li>套用 Polya 公式</li></ol><h2 id="Step4-Polya定理-例题-amp-amp-模板（POJ-1286）"><a href="#Step4-Polya定理-例题-amp-amp-模板（POJ-1286）" class="headerlink" title="Step4 - Polya定理-例题&amp;&amp;模板（POJ 1286）"></a>Step4 - Polya定理-例题&amp;&amp;模板（POJ 1286）</h2><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个长度为 n 的项链（环），着 3 种颜色，问有多少种</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ol><li>确定置换个数：旋转 (k * 360 / n)° n 种， 对称反转 n 种， 共 2 * n 种</li><li>确定循环节个数，旋转角度 (k * 360 / n)° 循环节为 gcd(n, k)，对称反转分奇数和偶数。</li><li>套用 Polya 公式求解</li></ol><h3 id="代码-模板："><a href="#代码-模板：" class="headerlink" title="代码+模板："></a>代码+模板：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ll n, m, i, j, k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n) !&#x3D; EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if(n &#x3D;&#x3D; -1)break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        if(n &#x3D;&#x3D; 0)&#123;printf(&quot;0\n&quot;);continue;&#125;&#x2F;&#x2F;特判0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ll ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans +&#x3D; pow(3.0, __gcd(n, i) * 1.0);&#x2F;&#x2F;旋转（i * 360 &#x2F; n）°</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        if(n % 2 &#x3D;&#x3D; 1)&#123;ans +&#x3D; n * pow(3.0, (n + 1) &#x2F; 2);&#125;&#x2F;&#x2F;奇数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        else &#123;ans +&#x3D; n &#x2F; 2 * pow(3.0, n &#x2F; 2) + n &#x2F; 2 * pow(3.0, n &#x2F; 2 + 1);&#125;&#x2F;&#x2F;偶数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ans &#x2F;&#x3D; (n * 2);&#x2F;&#x2F;除置换个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher</title>
      <link href="/2020/03/07/Manacher/"/>
      <url>/2020/03/07/Manacher/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Manacher的总结</p><a id="more"></a><h2 id="题目传送门：POJ-3974-Palindrome"><a href="#题目传送门：POJ-3974-Palindrome" class="headerlink" title="题目传送门：POJ-3974 Palindrome"></a>题目传送门：<a href="https://vjudge.net/problem/POJ-3974" target="_blank" rel="noopener">POJ-3974 Palindrome</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求最长回文字串</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>Manacher模板题</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">char a[1000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">char ma[2000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">int mp[2000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int ca &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%s&quot;, a) !&#x3D; EOF &amp;&amp; strcmp(a, &quot;END&quot;) !&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        int n &#x3D; strlen(a), i, l &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        ma[l++] &#x3D; &#39;$&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ma[l++] &#x3D; &#39;#&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            ma[l++] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            ma[l++] &#x3D; &#39;#&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        ma[l] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        int mx &#x3D; 0, id &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        int ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; l; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            mp[i] &#x3D; mx &gt; i ? min(mp[2 * id - i], mx - i):1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            while(ma[i + mp[i]] &#x3D;&#x3D; ma[i - mp[i]])mp[i]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            if(i + mp[i] &gt; mx)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                mx &#x3D; i + mp[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                id &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            ans &#x3D; max(ans, mp[i] - 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;Case %d: %d\n&quot;, ca++, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2020/03/07/KMP/"/>
      <url>/2020/03/07/KMP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>KMP的总结</p><a id="more"></a><h2 id="题目传送门：POJ-2406-Power-Strings"><a href="#题目传送门：POJ-2406-Power-Strings" class="headerlink" title="题目传送门：POJ-2406 Power Strings"></a>题目传送门：<a href="https://cn.vjudge.net/problem/POJ-2406" target="_blank" rel="noopener">POJ-2406 Power Strings</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个字符串，求它的最小循环节</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>最小循环节==len/（len-next[len]）（如果能整除）</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">char a[1000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int nex[1000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%s&quot;, a) &amp;&amp; a[0] !&#x3D; &#39;.&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        int len &#x3D; strlen(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        int i &#x3D; 0, j &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        nex[0] &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        while(i &lt; len)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            if(j &#x3D;&#x3D; -1 || a[i] &#x3D;&#x3D; a[j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                nex[++i] &#x3D; ++j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            else j &#x3D; nex[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        if(len % (len - nex[len]) &#x3D;&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, len &#x2F; (len - nex[len]));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        else printf(&quot;1\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机</title>
      <link href="/2020/03/07/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2020/03/07/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AC自动机的总结</p><a id="more"></a><h2 id="P3808-【模板】AC自动机（简单版）"><a href="#P3808-【模板】AC自动机（简单版）" class="headerlink" title="P3808 【模板】AC自动机（简单版）"></a>P3808 【模板】AC自动机（简单版）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_automaton</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> c[N][<span class="number">26</span>], val[N], fail[N], cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//c数组记录字典树节点，val数组为该节点是否为字符串结尾（个数）（记录字符串结束的位置）， fail记录失配指针， cnt记录节点标号(对应val)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//cnt作用：模拟动态开点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span><span class="comment">//向字典树中插入字符串，s为模式串</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="keyword">int</span> now = <span class="number">0</span>;<span class="comment">//从根节点0开始</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'a'</span>;<span class="comment">//获取当前字符的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!c[now][v])c[now][v] = ++cnt;<span class="comment">//如果这个节点没开，则开点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            now = c[now][v];<span class="comment">//now移动到新节点，开始匹配下一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        val[now]++;<span class="comment">//字符串插入完毕后在尾部打标记，val[u]表示以该点结尾的字符串个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span><span class="comment">//获取每个节点的失配指针</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>][i])fail[c[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(c[<span class="number">0</span>][i]);<span class="comment">//首先将与根节点相连的点入队，即首字母入队，并赋失配指针为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!q.empty())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();<span class="comment">//出队</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(c[u][i])fail[c[u][i]] = c[fail[u]][i], q.push(c[u][i]);<span class="comment">//如果该节点存在，则他的失配指针为它的上一个失配指针处的失配指针，并入队</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> c[u][i] = c[fail[u]][i];<span class="comment">//该点不存在只更新fail指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span><span class="comment">//查询文本串中模式串的个数，s为文本串</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;<span class="comment">//ans记录答案（模式串个数）， 从根节点开始</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            now = c[now][s[i] - <span class="string">'a'</span>];<span class="comment">//从当前节点向下走</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = now; t &amp;&amp; ~val[t]; t = fail[t])ans += val[t], val[t] = <span class="number">-1</span>;<span class="comment">//遍历该节点前失配指针，并统计个数，清楚val（避免重复统计）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;AC;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> p[<span class="number">1000005</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">"%s"</span>, p), AC.ins(p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    AC.build();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = AC.query(p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用最大流</title>
      <link href="/2020/03/07/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/2020/03/07/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最小费用最大流的总结</p><a id="more"></a><h2 id="P4016-负载平衡问题"><a href="#P4016-负载平衡问题" class="headerlink" title="P4016 负载平衡问题"></a>P4016 负载平衡问题</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.org/problem/P4016" target="_blank" rel="noopener">https://www.luogu.org/problem/P4016</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分源点、汇点，源点所有超过均值的点流量为1，费用为0、所有未超过均值的点连汇点流量为1，费用为0、相邻两点连边，流量为INF，费用为1，跑最小费用最大流即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define maxn 2010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define maxm 1200010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define inf 0x3f3f3f3f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">struct Edge&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    int to, nex, cap, flow, cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;edge[maxm];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int head[maxn], tol, pre[maxn], dis[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">bool vis[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">int N;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">void init(int n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    N &#x3D; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    tol &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    memset(head, -1, sizeof(head));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">void addedge(int u, int v, int cap, int cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cap &#x3D; cap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cost &#x3D; cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[u];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    head[u] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; u;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cap &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cost &#x3D; -cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[v];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    head[v] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">bool spfa(int s, int t)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; N; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        dis[i] &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        vis[i] &#x3D; false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        pre[i] &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    dis[s] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    vis[s] &#x3D; true;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    q.push(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    while(!q.empty())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; q.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        q.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        vis[u] &#x3D; false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            int v &#x3D; edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                dis[v] &#x3D; dis[u] + edge[i].cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                pre[v] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                if(!vis[v])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                    vis[v] &#x3D; true;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                    q.push(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    if(pre[t] &#x3D;&#x3D; -1)return false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    else return true;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">int minCostMaxflow(int s, int t, int &amp;cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    int flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    cost &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    while(spfa(s, t))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        int Min &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">            if(Min &gt; edge[i].cap - edge[i].flow)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">                Min &#x3D; edge[i].cap - edge[i].flow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">            edge[i].flow +&#x3D; Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            edge[i^1].flow -&#x3D; Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            cost +&#x3D; edge[i].cost * Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        flow +&#x3D; Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">    return flow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">int a[105];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    int n, sum &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    init(n + 2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)scanf(&quot;%d&quot;, &amp;a[i]), sum +&#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    sum &#x2F;&#x3D; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        if(a[i] &gt; sum)addedge(0, i, a[i] - sum, 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">        else addedge(i, n + 1, sum - a[i], 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n-1)addedge(i,i+1,inf,1),addedge(i+1,i,inf,1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">    addedge(1,n,inf,1),addedge(n,1,inf,1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">    int ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">    minCostMaxflow(0,n+1,ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%d\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流</title>
      <link href="/2020/03/07/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/2020/03/07/%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最大流的总结</p><a id="more"></a><h2 id="P2756-飞行员配对方案问题-最大流"><a href="#P2756-飞行员配对方案问题-最大流" class="headerlink" title="P2756 飞行员配对方案问题(最大流)"></a>P2756 飞行员配对方案问题(最大流)</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">https://www.luogu.org/problem/P2756</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分源点、汇点，源点连英国飞行员点（流量为1）、每个英国飞行员点连可配合的外籍飞行员点（流量为1）、每个外籍飞行员点连汇点（流量为1），跑最大流即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define maxn 2010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define maxm 1200010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define inf 0x3f3f3f3f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">struct Edge&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    int to, nex, cap, flow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;edge[maxm];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int tol;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">int head[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">void init()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    tol &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    memset(head, -1, sizeof(head));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">void addedge(int u, int v, int w, int rw &#x3D; 0)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; v; edge[tol].cap &#x3D; w; edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[u]; head[u] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; u; edge[tol].cap &#x3D; rw; edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[v]; head[v] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">int Q[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">int dep[maxn], cur[maxn], sta[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">bool bfs(int s, int t, int n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    int fro &#x3D; 0, tail &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    memset(dep, -1, sizeof(dep[0]) * (n + 1));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    dep[s] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    Q[tail++] &#x3D; s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    while(fro &lt; tail)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; Q[fro++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            int v &#x3D; edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            if(edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] &#x3D;&#x3D; -1)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                dep[v] &#x3D; dep[u] + 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                if(v &#x3D;&#x3D; t)&#123;return true;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                Q[tail++] &#x3D; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    return false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">int dinic(int s, int t, int n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    int maxflow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    while(bfs(s, t, n))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)cur[i] &#x3D; head[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; s, tail &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        while(cur[s] !&#x3D; -1)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            if(u &#x3D;&#x3D; t)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">                int tp &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                    tp &#x3D; min(tp, edge[sta[i]].cap - edge[sta[i]].flow);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                maxflow +&#x3D; tp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                    edge[sta[i]].flow +&#x3D; tp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                    edge[sta[i]^1].flow -&#x3D; tp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                    if(edge[sta[i]].cap-edge[sta[i]].flow &#x3D;&#x3D; 0)tail &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">                u &#x3D; edge[sta[tail]^1].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            else if(cur[u] !&#x3D; -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 &#x3D;&#x3D; dep[edge[cur[u]].to])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">                sta[tail++] &#x3D; cur[u];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">                u &#x3D; edge[cur[u]].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">            else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">                while(u !&#x3D; s &amp;&amp; cur[u] &#x3D;&#x3D; -1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">                    u &#x3D; edge[sta[--tail]^1].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">                cur[u] &#x3D; edge[cur[u]].nex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    return maxflow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    int n, m, u, v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;u, &amp;v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    while(u !&#x3D; -1 &amp;&amp; v !&#x3D; -1)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        addedge(u, v + n, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d %d&quot;, &amp;u, &amp;v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)addedge(0, i, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">    go(i,1,m)addedge(i + n, n + m + 1, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    int ans &#x3D; dinic(0, n + m + 1, n + m + 2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    if(!ans)&#123;printf(&quot;No Solution!\n&quot;); return 0;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%d\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        for(int j &#x3D; head[i]; j !&#x3D; -1; j &#x3D; edge[j].nex)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">            if(edge[j].flow &#x3D;&#x3D; 1)printf(&quot;%d %d\n&quot;, i, edge[j].to - n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主席树&amp;莫队</title>
      <link href="/2020/03/07/%E4%B8%BB%E5%B8%AD%E6%A0%91&amp;%E8%8E%AB%E9%98%9F/"/>
      <url>/2020/03/07/%E4%B8%BB%E5%B8%AD%E6%A0%91&amp;%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主席树&amp;莫队的总结</p><a id="more"></a><h2 id="题目传送门：SPOJ-DQUERY-D-query（主席树-莫队-amp-amp-区间内不同数个数）"><a href="#题目传送门：SPOJ-DQUERY-D-query（主席树-莫队-amp-amp-区间内不同数个数）" class="headerlink" title="题目传送门：SPOJ-DQUERY D-query（主席树 | 莫队 &amp;&amp; 区间内不同数个数）"></a>题目传送门：<a href="https://cn.vjudge.net/problem/SPOJ-DQUERY" target="_blank" rel="noopener">SPOJ-DQUERY D-query</a>（主席树 | 莫队 &amp;&amp; 区间内不同数个数）</h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求区间内不同数的个数。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>主席树做法：</p><p>倒序（从右向左）建立主席树，如果一个值还没出现过，则直接插入，否则删除后再重新插入（相当于保留这个数最左出现的位置）。之后要查询 [l, r] 时，选用 l 位置的主席树，这时树中的数据是 [l, n] 范围内的，因此查询时需要传入 r 作为挡板，仅统计小于等于 r 的个数，这样就可以实现 [l, r] 区间不同数的查询。</p><p>莫队做法：</p><p>莫队模板题</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><h3 id="主席树："><a href="#主席树：" class="headerlink" title="主席树："></a>主席树：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100001;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int sum, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125; hjt[MAXN * 40];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">int a[MAXN], sorted[MAXN], num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int root[MAXN], cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">int GetIdx(int v)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">void init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    cnt &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">int CreateNode(int sum, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    int idx &#x3D; ++cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].sum &#x3D; sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].l &#x3D; l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].r &#x3D; r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    return idx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">void Insert(int &amp;root, int pre_rt, int pos, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">int Query(int s, int e, int k, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    int n, m, i, j, k, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            sorted[i] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        sort(sorted + 1, sorted + 1 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        while(m--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="莫队："><a href="#莫队：" class="headerlink" title="莫队："></a>莫队：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">int num[1000010],vis[1000010],s[1000010];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int m,block,ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int l,r,id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    bool operator &lt; (const node &amp;c)const&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        if(l&#x2F;block&#x3D;&#x3D;c.l&#x2F;block)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            return r&lt;c.r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        return l&#x2F;block &lt; c.l&#x2F;block;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;q[1000010];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">void add(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    vis[s[x]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    if(vis[s[x]]&#x3D;&#x3D;1)ans++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">void del(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    vis[s[x]]--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    if(vis[s[x]]&#x3D;&#x3D;0)ans--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    int n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    block&#x3D;sqrt(n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d&quot;,&amp;s[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        q[i].id&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    sort(q+1,q+1+m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    int l&#x3D;1,r&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        while(l&lt;q[i].l)del(l),l++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        while(l&gt;q[i].l)l--,add(l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        while(r&lt;q[i].r)r++,add(r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        while(r&gt;q[i].r)del(r),r--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        num[q[i].id]&#x3D;ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;,num[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="题目传送门：POJ-2104-K-th-Number（主席树-amp-amp-区间第-k-大）"><a href="#题目传送门：POJ-2104-K-th-Number（主席树-amp-amp-区间第-k-大）" class="headerlink" title="题目传送门：POJ-2104 K-th Number（主席树 &amp;&amp; 区间第 k 大）"></a>题目传送门：<a href="https://cn.vjudge.net/problem/POJ-2104" target="_blank" rel="noopener">POJ-2104 K-th Number</a>（主席树 &amp;&amp; 区间第 k 大）</h2><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求区间第 k 小的数。</p><h2 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h2><p>主席树模板题</p><h2 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100001;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int sum, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125; hjt[MAXN * 40];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">int a[MAXN], sorted[MAXN], num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int root[MAXN], cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">int GetIdx(int v)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">void init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    cnt &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">int CreateNode(int sum, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    int idx &#x3D; ++cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].sum &#x3D; sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].l &#x3D; l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].r &#x3D; r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    return idx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">void Insert(int &amp;root, int pre_rt, int pos, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">int Query(int s, int e, int k, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    int n, m, i, j, k, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            sorted[i] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        sort(sorted + 1, sorted + 1 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        while(m--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>种类并查集</title>
      <link href="/2020/03/07/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2020/03/07/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>种类并查集的总结</p><a id="more"></a><h2 id="POJ-1703-Find-them-Catch-them-种类并查集"><a href="#POJ-1703-Find-them-Catch-them-种类并查集" class="headerlink" title="POJ - 1703 Find them, Catch them (种类并查集)"></a>POJ - 1703 Find them, Catch them (种类并查集)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">300000</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fin</span><span class="params">(<span class="keyword">int</span> a)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pre[a]==a) <span class="keyword">return</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t=a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (pre[a]!=a)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        a=pre[a];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (pre[t]!=t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> t2=t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        t=pre[t];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        pre[t2]=a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sam</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fin(x) == fin(y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = fin(x), b = fin(y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a != b)pre[a] = b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m, i, sum = <span class="number">0</span>, a1, a2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(sum--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">char</span> cmd[<span class="number">15</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)pre[i] = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            getchar();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s %d %d"</span>, &amp;cmd, &amp;a1, &amp;a2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"A"</span>) == <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(sam(a1, a2 + n) || sam(a2, a1 + n))<span class="built_in">printf</span>(<span class="string">"In different gangs.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sam(a1, a2) || sam(a1 + n, a2 + n))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                    join(a1, a2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                    join(a1 + n, a2 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                    <span class="built_in">printf</span>(<span class="string">"In the same gang.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not sure yet.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">                join(a1,a2 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">                join(a2, a1 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斜率DP</title>
      <link href="/2020/03/07/%E6%96%9C%E7%8E%87DP/"/>
      <url>/2020/03/07/%E6%96%9C%E7%8E%87DP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>斜率DP的总结</p><a id="more"></a><p>斜率DP用来优化一类形如 dp[i]=min(dp[j]+f(i,j))dp[i]=min(dp[j]+f(i,j)) 的动态规划问题</p><h2 id="从HDU3507入手"><a href="#从HDU3507入手" class="headerlink" title="从HDU3507入手"></a>从HDU3507入手</h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>将长度为 nn 的数组划分成若干段，每段的花费为这段数字和的平方加 MM,求最小花费。</p><h3 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h3><p>定义 dp[i]dp[i] 为到i为止划分为若干段的最小花费，则有转移方程：</p><p>dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)</p><p>可以发现复杂度为n2n2的。</p><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ul><li>设 k&lt;j&lt;ik&lt;j&lt;i</li><li>若 jj 转移至 ii 比 kk 转移至 ii 更优(本题中为 jj 转移至 ii 花费更小)</li><li>则有 dp[j]+M+(sum[i]−sum[j])2&lt;dp[k]+M+(sum[i]−sum[k])2dp[j]+M+(sum[i]−sum[j])2&lt;dp[k]+M+(sum[i]−sum[k])2</li><li>移项化简得 (dp[j]+sum[j]2)−(dp[k]+sum[k]2)2sum[j]−2sum[k]&lt;sum<a href="dp[j]+sum[j]2">i</a>−(dp[k]+sum[k]2)2sum[j]−2sum[k]&lt;sum[i]</li><li>设Y(x)=dp[x]+sum[x]2Y(x)=dp[x]+sum[x]2,X(x)=2sum[x]X(x)=2sum[x],g[i,j]=Y(i)−Y(j)X(i)−X(j)g[i,j]=Y(i)−Y(j)X(i)−X(j)</li><li>则有当g[j,k]&lt;sum[i]g[j,k]&lt;sum[i]时，jj转移至ii要比kk转移至ii更优</li><li>分析当g[i,j]&lt;g[j,k]g[i,j]&lt;g[j,k]时，若g[i,j]&lt;sum[i]g[i,j]&lt;sum[i],则ii比jj优，若g[i,j]&gt;=sum[i]g[i,j]&gt;=sum[i],则g[j,k]&gt;sum[i]g[j,k]&gt;sum[i]，即jj不如kk优</li><li>结论:对于ii点当g[j,k]&lt;g[i,j]g[j,k]&lt;g[i,j]时，jj必然不是最优的转移方案</li><li>用单调队列维护有效解集，则有效解集的斜率为递增的</li></ul><p><img src="https://miracle-qsh.github.io/img/Slope_DP_01.jpg" alt="斜率"></p><ul><li>随着i的增长，sum[i]sum[i]单调递增，因此若对于一个jj为ii的最优转移方案，则对于ii之后的任意一点，jj之前的点一定不如jj优。</li><li>那么对于新入队的元素ii，若队尾元素与ii的斜率小于队尾元素与上一个元素的斜率，则不断删除队尾元素，直至单调</li><li>对于每次转移，找到第一个斜率大于sum[i]sum[i]的点jj，从那jj点转移，并将jj点前的元素出队</li><li>算法复杂度为O(n)O(n)</li></ul><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define N 500005</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define p2(x) (x)*(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ll a[N],dp[N],n,m,head,tail,q[N],sum[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ll getdp(ll i,ll j)&#123;return dp[j]+m+p2(sum[i]-sum[j]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ll getup(ll i,ll j)&#123;return dp[i]+p2(sum[i])-(dp[j]+p2(sum[j]));&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ll getdown(ll i,ll j)&#123;return 2ll*(sum[i]-sum[j]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">void init()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    head&#x3D;tail&#x3D;dp[0]&#x3D;sum[0]&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    q[tail++]&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            while(head+1&lt;tail&amp;&amp;getup(q[head],q[head+1])&gt;sum[i]*getdown(q[head],q[head]+1))head++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            dp[i]&#x3D;getdp(i,q[head]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            while(head+1&lt;tail&amp;&amp;getdown(q[tail-1],q[tail-2])*getup(i,q[tail-1])&lt;&#x3D;getdown(i,q[tail-1])*getup(q[tail-1],q[tail-2]))tail--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            q[tail++]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld\n&quot;,dp[n]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="HDU3507"><a href="#HDU3507" class="headerlink" title="HDU3507"></a>HDU3507</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3507" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=3507</a></p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)+斜率优化，入门题</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define N 500005</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define p2(x) (x)*(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ll a[N],dp[N],n,m,head,tail,q[N],sum[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ll getdp(ll i,ll j)&#123;return dp[j]+m+p2(sum[i]-sum[j]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ll getup(ll i,ll j)&#123;return dp[i]+p2(sum[i])-(dp[j]+p2(sum[j]));&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ll getdown(ll i,ll j)&#123;return 2ll*(sum[i]-sum[j]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">void init()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    head&#x3D;tail&#x3D;dp[0]&#x3D;sum[0]&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    q[tail++]&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            while(head+1&lt;tail&amp;&amp;getup(q[head],q[head+1])&gt;sum[i]*getdown(q[head],q[head]+1))head++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            dp[i]&#x3D;getdp(i,q[head]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            while(head+1&lt;tail&amp;&amp;getdown(q[tail-1],q[tail-2])*getup(i,q[tail-1])&lt;&#x3D;getdown(i,q[tail-1])*getup(q[tail-1],q[tail-2]))tail--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            q[tail++]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld\n&quot;,dp[n]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="BZOJ1010"><a href="#BZOJ1010" class="headerlink" title="BZOJ1010"></a>BZOJ1010</h2><h3 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1010" target="_blank" rel="noopener">https://www.lydsy.com/JudgeOnline/problem.php?id=1010</a></p><h3 id="备注-1"><a href="#备注-1" class="headerlink" title="备注"></a>备注</h3><p>dp[i]=min{dp[j]+(sum[i]−sum[j]+i−j−1−L)2}dp[i]=min{dp[j]+(sum[i]−sum[j]+i−j−1−L)2}，思路为将括号里的内容分为两个函数，便于展开。打错了函数名，调了一上午。。。</p><h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define N 500005</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define p2(x) (x)*(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ll a[N],sum[N],tail,head,q[N],L,n,m,dp[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">void init()&#123;head&#x3D;tail&#x3D;sum[0]&#x3D;dp[0]&#x3D;0;q[tail++]&#x3D;0;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ll getx(ll x)&#123;return x+sum[x];&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ll gety(ll x)&#123;return x+sum[x]+1+L;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">ll getdp(ll i,ll j)&#123;return dp[j]+p2(getx(i)-gety(j));&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">ll getup(ll j,ll k)&#123;return (dp[j]+p2(gety(j)))-(dp[k]+p2(gety(k)));&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">ll getdown(ll j,ll k)&#123;return 2ll*(gety(j)-gety(k));&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    cin&gt;&gt;n&gt;&gt;L;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;getx(i)*getdown(q[head+1],q[head]))head++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        dp[i]&#x3D;getdp(i,q[head]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1]))tail--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        q[tail++]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%lld\n&quot;,dp[n]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="牛客2019多校十J"><a href="#牛客2019多校十J" class="headerlink" title="牛客2019多校十J"></a>牛客2019多校十J</h2><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n块木板长与高，要求分为k组，每组经过切割变为等高，切割部分不能再利用，求最小浪费面积</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>将n块木板按从高到低排序，则每组木板必是连续的一段区间，且统一高度为该组中高度最小的木板高度。</li><li>求最小浪费面积即是求最大剩余面积</li></ul><h3 id="DP方程"><a href="#DP方程" class="headerlink" title="DP方程"></a>DP方程</h3><p>dp[k][i]=maxdp[k−1][j]+h[j]∗(sum[i]−sum[j])dp[k][i]=maxdp[k−1][j]+h[j]∗(sum[i]−sum[j])</p><h3 id="备注-2"><a href="#备注-2" class="headerlink" title="备注"></a>备注</h3><ul><li>二维斜率dp类似背包，可以倒着跑开一维或正着跑开二维</li><li>每维开一个单调队列，用上一组单调队列转移，新元素添加至本组</li><li>注意整数范围，过程爆long long,使用 __int128</li></ul><h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define N 5005</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define lll __int128</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">#define p2(x) (x)*(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">struct node&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    ll a,b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    bool operator&lt;(const node &amp;x)const&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        return a&gt;x.a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;s[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">ll dp[N][N],sum[N],head[N],tail[N],q[N][N],n,m;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">ll getdp(ll i,ll j,ll y)&#123;return dp[y-1][j]+s[i].a*(sum[i]-sum[j]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">ll gety(ll i,ll y)&#123;return (dp[y-1][i]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">ll getup(ll j,ll k,ll y)&#123;return gety(j,y)-gety(k,y);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">ll getdown(ll j,ll k)&#123;return sum[j]-sum[k];&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">ll getx(ll i)&#123;return s[i].a;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);ll sum1&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)scanf(&quot;%lld%lld&quot;,&amp;s[i].b,&amp;s[i].a),sum1+&#x3D;s[i].b*s[i].a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    sort(s+1,s+1+n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)sum[i]&#x3D;sum[i-1]+s[i].b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    go(i,0,m-1)head[i]&#x3D;tail[i]&#x3D;0,q[i][tail[i]++]&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    go(j,1,m)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            while(head[j-1]+1&lt;tail[j-1]&amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                  (lll)getup(q[j-1][head[j-1]+1],q[j-1][head[j-1]],j)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                  &gt;(lll)getx(i)*(lll)getdown(q[j-1][head[j-1]+1],q[j-1][head[j-1]]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                    head[j-1]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            dp[j][i]&#x3D;getdp(i,q[j-1][head[j-1]],j);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            while(head[j]+1&lt;tail[j]&amp;&amp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                  (lll)getup(i,q[j][tail[j]-1],j+1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                  *(lll)getdown(q[j][tail[j]-1],q[j][tail[j]-2])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                  &gt;(lll)getup(q[j][tail[j]-1],q[j][tail[j]-2],j+1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                  *(lll)getdown(i,q[j][tail[j]-1]))tail[j]--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            q[j][tail[j]++]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%lld\n&quot;,sum1-dp[m][n]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性基</title>
      <link href="/2020/03/07/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
      <url>/2020/03/07/%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线性基的总结</p><a id="more"></a><h2 id="线性基详解"><a href="#线性基详解" class="headerlink" title="线性基详解"></a>线性基详解</h2><h3 id="线性基是什么"><a href="#线性基是什么" class="headerlink" title="线性基是什么"></a>线性基是什么</h3><p>你可以理解为将一个序列处理完之后得到的产物，并且有如下性质（后面有证明）：</p><h3 id="线性基的性质"><a href="#线性基的性质" class="headerlink" title="线性基的性质"></a>线性基的性质</h3><ol><li>原序列里面的任意一个数都可以由线性基里面的一些数异或得到</li><li>线性基里面的任意一些数异或起来都不能得到00</li><li>线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的</li></ol><h3 id="线性基的构造过程"><a href="#线性基的构造过程" class="headerlink" title="线性基的构造过程"></a>线性基的构造过程</h3><p>那么它是怎么构造的呢？</p><p>我们设有一个数组dd，表示序列aa的线性基，下标从00开始算。对于序列里面的每一个数，我们尝试将它插入到线性基里面去，具体如何插入这里给出伪代码（为了方便理解，我们设 x(2)x(2) 为xx的二进制数）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制for i&#x3D;60 to 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">if(x(2)的第i+1位为1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    if(d[i]为0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        d[i]&#x3D;x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    else x&#x3D;x^d[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>据此，我们可以得到一个关于dd数组的性质：若d[i]d[i]不为00，则d[i]（2）d[i]（2）的第i+1i+1位为11，并且d[i]（2）d[i]（2）的最高位就是第i+1i+1位。<br>为了更好地进行线性基的讲解，我们要先知道关于异或的一个小性质：<br>如果满足aa ^ bb ^ c=0c=0 ，那么aa ^ b=cb=c，所以如果aa ^ b=cb=c，那么aa ^ c=bc=b<br>证明虽然简单但是这里就不给出了，不明白的读者手动模拟一下就明白了</p><h3 id="线性基性质的证明"><a href="#线性基性质的证明" class="headerlink" title="线性基性质的证明"></a>线性基性质的证明</h3><h4 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h4><p>我们知道了线性基的构造方法后，其实就可以很容易想到如何证明性质1了，我们设原序列里面有一个数x，我们尝试用它来构造线性基，那么会有两种结果：1、不能成功插入线性基；2、成功插入线性基。</p><p>分类讨论一下：</p><ol><li>不能成功插入线性基</li></ol><p>什么时候不能插入进去呢？<br>显然就是它在尝试插入时异或若干个数之后变成了00<br>那么就有如下式子：<br>xx ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=0=0<br>根据上面的那个小性质，则有：<br>d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=x=x<br>所以，如果xx不能成功插入线性基，一定是因为当前线性基里面的一些数异或起来可以等于xx。</p><ol><li>可以成功插入线性基</li></ol><p>我们假设xx插入到了线性基的第ii个位置，显然，它在插入前可能异或若干个数，那么就有：<br>xx ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=d[i]=d[i]<br>d[i]d[i] ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=x=x<br>所以显然，xx此时也可以由线性基里面的若干个数异或得到。</p><p>综上，性质1得证</p><h4 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h4><p>我们使用反证法<br>设d[a]d[a] ^ d[b]d[b] ^ d[c]=0d[c]=0（其中d[c]d[c]比d[a]d[a]和d[b]d[b]要更晚被插入线性基）<br>那么有d[a]d[a] ^ d[b]=d[c]d[b]=d[c]<br>∵d[c]∵d[c]可以由d[a]d[a] ^ d[b]d[b]得到<br>∴d[c]∴d[c]不可能插入线性基<br>故假设不成立，所以线性基中不存在有任何数异或起来可以得到00。</p><h4 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h4><p>分类讨论一下</p><ol><li>假如序列里面的所有元素都可以插入到线性基里面</li></ol><p>显然如果是这种情况的话，不管是用什么顺序将序列里的数插入到线性基里，线性基中的元素一定与原序列元素数量相同。所以性质3成立。</p><ol><li>假如序列里面的一些元素不能插入到线性基里面</li></ol><p>我们设xx不能插入到线性基里面，那么一定满足形如d[a]d[a] ^ d[b]d[b] ^ d[c]=xd[c]=x的式子，那我们尝试将插入顺序改变，变成：d[a]d[a]、d[b]d[b]、xx、d[c]d[c]。那么显然，d[c]d[c]是不可能插入成功的，简单的证明：<br>∵d[a]∵d[a] ^ d[b]d[b] ^ d[c]=xd[c]=x<br>∴d[a]∴d[a] ^ d[b]d[b] ^ x=d[c]x=d[c]（根据上面那条异或性质）<br>原来是xx插入不进去，改变顺序后，d[c]d[c]插入不进去，也就是说，对于插入不进去的元素，改变插入顺序后，要么还是插入不进去，要么就是插入进去了，同时另一个原来插入的进去的元素插入不进去了，所以，可以插入进去的元素数量一定是固定的。<br>显然，如果你去掉线性基里面的任意一个数，都会使得原序列里的一些（或一个）数无法通过用线性基里的元素异或得到，所以，每一个元素都是必要的，换句话说，这里面没有多余的元素，所以，这个线性基的元素个数在保持性质1的前提下，一定是最少的。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制void add(ll x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;50;i&gt;&#x3D;0;i--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        if(x&amp;(1ll&lt;&lt;i))&#x2F;&#x2F;注意，如果i大于31，前面的1的后面一定要加ll</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            if(d[i])x^&#x3D;d[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                d[i]&#x3D;x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                break;&#x2F;&#x2F;记得如果插入成功一定要退出</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="线性基的应用"><a href="#线性基的应用" class="headerlink" title="线性基的应用"></a>线性基的应用</h2><h3 id="求异或最大值"><a href="#求异或最大值" class="headerlink" title="求异或最大值"></a>求异或最大值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制ll ans()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    ll anss&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;50;i&gt;&#x3D;0;i--)&#x2F;&#x2F;记得从线性基的最高位开始</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    if((anss^d[i])&gt;anss)anss^&#x3D;d[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    return anss;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure><h3 id="求异或最小值"><a href="#求异或最小值" class="headerlink" title="求异或最小值"></a>求异或最小值</h3><p>显然的，最小值一定是最小的d[i]d[i]</p><h3 id="求异或第-K-小值"><a href="#求异或第-K-小值" class="headerlink" title="求异或第 K 小值"></a>求异或第 K 小值</h3><p>完整的说，应该是——从一个序列中取任意个元素进行异或，求能异或出的所有数字中第kk小的那个。<br>首先，要对这个序列的线性基处理一下，对于每一个d[i]d[i]，枚举j=ito1j=ito1，如果d[i]（2）d[i]（2）的第jj位为11，那么d[i]d[i]异或d[j−1]d[j−1]。<br>那么处理完一个线性基之后，应该大致是长这个样子的（x表示0或1）：<br>1xxxx0xxx0x1xxxx0xxx0x<br>……1xxx0x……1xxx0x<br>………..1x………..1x<br>求解过程：将k先转成二进制，假如kk的第ii位为11，ansans就异或上线性基中第ii个元素（注意不是直接异或d[i−1]d[i−1]）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制void work()&#x2F;&#x2F;处理线性基</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;1;i&lt;&#x3D;60;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">for(int j&#x3D;1;j&lt;&#x3D;i;j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">if(d[i]&amp;(1&lt;&lt;(j-1)))d[i]^&#x3D;d[j-1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ll k_th(ll k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">if(k&#x3D;&#x3D;1&amp;&amp;tot&lt;n)return 0;&#x2F;&#x2F;特判一下，假如k&#x3D;1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">if(tot&lt;n)k--;&#x2F;&#x2F;类似上面，去掉0的情况，因为线性基中只能异或出不为0的解</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">work();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">ll ans&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">for(int i&#x3D;0;i&lt;&#x3D;60;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">if(d[i]!&#x3D;0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">if(k%2&#x3D;&#x3D;1)ans^&#x3D;d[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">k&#x2F;&#x3D;2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="判断能否被当前线性基中元素异或得到"><a href="#判断能否被当前线性基中元素异或得到" class="headerlink" title="判断能否被当前线性基中元素异或得到"></a>判断能否被当前线性基中元素异或得到</h3><p>把它尝试插入进线性基里面去，假如可以插入，说明不能异或得到，假如插不进去，说明能异或得到</p><h2 id="题集"><a href="#题集" class="headerlink" title="题集"></a>题集</h2><h3 id="P3812-【模板】线性基"><a href="#P3812-【模板】线性基" class="headerlink" title="P3812 【模板】线性基"></a>P3812 【模板】线性基</h3><p>“<a href="https://www.luogu.org/problem/P3812&quot;" target="_blank" rel="noopener">https://www.luogu.org/problem/P3812&quot;</a></p><h3 id="P4570-BJWC2011-元素"><a href="#P4570-BJWC2011-元素" class="headerlink" title="P4570 [BJWC2011]元素"></a>P4570 [BJWC2011]元素</h3><p>“<a href="https://www.luogu.org/problem/P4570&quot;" target="_blank" rel="noopener">https://www.luogu.org/problem/P4570&quot;</a></p><h3 id="P3857-TJOI2008-彩灯"><a href="#P3857-TJOI2008-彩灯" class="headerlink" title="P3857 [TJOI2008]彩灯"></a>P3857 [TJOI2008]彩灯</h3><p>“<a href="https://www.luogu.org/problem/P3857&quot;" target="_blank" rel="noopener">https://www.luogu.org/problem/P3857&quot;</a></p><h3 id="P3292-SCOI2016-幸运数字"><a href="#P3292-SCOI2016-幸运数字" class="headerlink" title="P3292 [SCOI2016]幸运数字"></a>P3292 [SCOI2016]幸运数字</h3><p>“<a href="https://www.luogu.org/problem/P3292&quot;" target="_blank" rel="noopener">https://www.luogu.org/problem/P3292&quot;</a></p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>“<a href="https://blog.csdn.net/a_forever_dream/article/details/83654397&quot;" target="_blank" rel="noopener">https://blog.csdn.net/a_forever_dream/article/details/83654397&quot;</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2020/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>线段树的总结</p><a id="more"></a><h2 id="HYSBZ-1012-最大数maxnumber-线段树"><a href="#HYSBZ-1012-最大数maxnumber-线段树" class="headerlink" title="HYSBZ - 1012 最大数maxnumber (线段树)"></a>HYSBZ - 1012 最大数maxnumber (线段树)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ll left, right;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ll maxx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">node tree[maxn &lt;&lt; <span class="number">2</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">ll a[maxn] = &#123;<span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">ll n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">ll p = <span class="number">0</span>, q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    tree[m].left = l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    tree[m].right = r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        tree[m].maxx = a[l];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    build(m &lt;&lt; <span class="number">1</span>, l, mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    build(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    tree[m].maxx = <span class="built_in">max</span>(tree[m &lt;&lt; <span class="number">1</span>].maxx, tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> a, <span class="keyword">int</span> val)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (tree[m].left == a &amp;&amp; tree[m].right == a)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        tree[m].maxx += val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (a &lt;= mid)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        update(m &lt;&lt; <span class="number">1</span>, a, val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        update(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, a, val);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    tree[m].maxx = <span class="built_in">max</span>(tree[m &lt;&lt; <span class="number">1</span>].maxx, tree[m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].maxx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">queryMax</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (l == tree[m].left &amp;&amp; r == tree[m].right)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> tree[m].maxx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = (tree[m].left + tree[m].right) &gt;&gt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (r &lt;= mid)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> queryMax(m &lt;&lt; <span class="number">1</span>, l, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> queryMax(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(queryMax(m &lt;&lt; <span class="number">1</span>, l, mid), queryMax(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    ll t = <span class="number">0</span>,i,j, k, MOD, l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">char</span> cmd;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;MOD);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    build(<span class="number">1</span>, <span class="number">1</span>, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        getchar();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c %lld"</span>, &amp;cmd, &amp;l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(cmd == <span class="string">'Q'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">//cout &lt;&lt; p - l + 1 &lt;&lt; " " &lt;&lt; p &lt;&lt; endl;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">            t = queryMax(<span class="number">1</span>, p - l + <span class="number">1</span>,p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">            update(<span class="number">1</span>, p + <span class="number">1</span>, (l + t) % MOD);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            p++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2020/03/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>拓扑排序的总结</p><a id="more"></a><h2 id="题目传送门：POJ-2367-Genealogical-tree"><a href="#题目传送门：POJ-2367-Genealogical-tree" class="headerlink" title="题目传送门：POJ-2367 Genealogical tree"></a>题目传送门：<a href="https://vjudge.net/problem/POJ-2367" target="_blank" rel="noopener">POJ-2367 Genealogical tree</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个有向无环图，求拓扑排序序列</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>拓扑排序模板题</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 100010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int head[maxn], links, ans[maxn], pi, n, in[maxn], vis[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    int v, nex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;edge[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">void init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    memset(head, 0, sizeof(head));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    memset(in, 0, sizeof(in));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    memset(vis, 0, sizeof(vis));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    links &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    pi &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">void add_edge(int u, int v)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    edge[++links].v &#x3D; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    edge[links].nex &#x3D; head[u];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    head[u] &#x3D; links;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">void tsort()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    int i, j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        for(j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            if(!vis[j] &amp;&amp; !in[j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                vis[j] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                ans[pi++] &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        for(j &#x3D; head[u]; j; j &#x3D; edge[j].nex)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            in[edge[j].v]--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    int m, i, j, k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">            while(1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                scanf(&quot;%d&quot;, &amp;j);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                if(j &#x3D;&#x3D; 0)break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">                in[j]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">                add_edge(i, j);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        tsort();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; pi; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">            if(i !&#x3D; 0)printf(&quot; &quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d&quot;, ans[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位DP</title>
      <link href="/2020/03/07/%E6%95%B0%E4%BD%8DDP/"/>
      <url>/2020/03/07/%E6%95%B0%E4%BD%8DDP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数位DP的总结</p><a id="more"></a><p>基础：<a href="https://blog.csdn.net/Miracle_QSH/article/details/85067535" target="_blank" rel="noopener">https://blog.csdn.net/Miracle_QSH/article/details/85067535</a><br>进阶：<a href="https://blog.csdn.net/Miracle_QSH/article/details/85079176" target="_blank" rel="noopener">https://blog.csdn.net/Miracle_QSH/article/details/85079176</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论四大定理</title>
      <link href="/2020/03/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/"/>
      <url>/2020/03/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数论四大定理的总结</p><a id="more"></a><h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><p>(<em>p</em>−1)!=<em>p</em>−1(<em>m<strong>o</strong>d**p</em>) 当且仅当<em>p</em> 为质数</p><h3 id="威尔逊定理模板题"><a href="#威尔逊定理模板题" class="headerlink" title="威尔逊定理模板题"></a>威尔逊定理模板题</h3><p>2019 HDU 多校第三场 1006 <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6608" target="_blank" rel="noopener">HDU-6608</a></p><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若<em>n</em>,<em>a</em>为正整数，且<em>n</em>,<em>a</em>互质，即<em>g<strong>c</strong>d</em>(<em>a</em>,<em>n</em>)=1，则<em>a</em> ^ φ(n) ≡ 1 (mod n)</p><h2 id="孙子定理（中国剩余定理）"><a href="#孙子定理（中国剩余定理）" class="headerlink" title="孙子定理（中国剩余定理）"></a>孙子定理（中国剩余定理）</h2><p>用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组：</p><p><img src="https://img-blog.csdn.net/20180531204833773?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jhb2RyZWFt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>中国剩余定理说明：假设整数m1,m2, … ,mn两两互质，则对任意的整数：a1,a2, … ,an，方程组 &amp;(S)&amp;有解。</p><p>并且通解可以用如下方式构造得到：</p><p>设M=m_1 \times m_2 \times … \times m_n = \prod_{i=1}^n{m_i} 是整数m1,m2,… ,mn的乘积，并设M_i = {M \over m_i}, \forall i \in {1,2,…,n}是除了mi以外的n- 1个整数的乘积。<br>设t_i = M_i^-1这个就是逆元了，则t_i M_i=1(mod m_i), \forall i \in {1,2,…,n}</p><p>通解形式为:</p><p><img src="https://img-blog.csdn.net/20180531220318747?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jhb2RyZWFt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><p>在模M的意义下，方程组(S)只有一个解：</p><p><img src="https://img-blog.csdn.net/20180531220325316?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jhb2RyZWFt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。</p><h3 id="补充费马大定理"><a href="#补充费马大定理" class="headerlink" title="补充费马大定理"></a>补充费马大定理</h3><p>当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^$n￥ 没有正整数解</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2020/03/07/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/07/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>树状数组的总结</p><a id="more"></a><h2 id="HDU-1166-敌兵布阵"><a href="#HDU-1166-敌兵布阵" class="headerlink" title="HDU - 1166 敌兵布阵"></a>HDU - 1166 敌兵布阵</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">50005</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> cmd[<span class="number">1005</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t, n, m, i, j, k, ca = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(t--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n; i++)a[i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(j = i; j &lt;= n; j += j &amp; -j)a[j] += k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>, ca++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd) != EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'E'</span>)<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'Q'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span>(i = r; i &gt; <span class="number">0</span>; i -= i &amp; -i)ans1 += a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span>(i = l - <span class="number">1</span>; i &gt; <span class="number">0</span>; i -= i &amp; -i)ans2 += a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans1 - ans2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmd[<span class="number">0</span>] == <span class="string">'A'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span>(;x &lt;= n; x += x &amp; -x)a[x] += y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span>(;x &lt;= n; x += x &amp; -x)a[x] -= y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容斥原理</title>
      <link href="/2020/03/07/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2020/03/07/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>容斥原理的总结</p><a id="more"></a><h2 id="HDU-1796-How-many-integers-can-you-find-（容斥原理）"><a href="#HDU-1796-How-many-integers-can-you-find-（容斥原理）" class="headerlink" title="HDU - 1796 How many integers can you find （容斥原理）"></a>HDU - 1796 How many integers can you find （容斥原理）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ll n, m, a[<span class="number">15</span>], ans, p;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span></span>&#123;<span class="keyword">return</span> a * b / __gcd(a, b);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll x, ll sum, ll num)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(num &gt; m)<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">1</span>)&#123;ans += (n - <span class="number">1</span>) / sum;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;ans -= (n - <span class="number">1</span>) / sum;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(ll i = x + <span class="number">1</span>; i &lt; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        dfs(i, lcm(sum, a[i]), num + <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;p) != EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        m = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; p; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[m++]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(a[i] == <span class="number">0</span> || a[i] &gt; n)m--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        ll flag = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(ll i = <span class="number">0</span>; i &lt; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            dfs(i, a[i], <span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(n % a[i] == <span class="number">0</span>)flag = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>米勒罗宾素数测试</title>
      <link href="/2020/03/07/%E7%B1%B3%E5%8B%92%E7%BD%97%E5%AE%BE%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/03/07/%E7%B1%B3%E5%8B%92%E7%BD%97%E5%AE%BE%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>米勒罗宾素数测试的总结</p><a id="more"></a><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制&#x2F;&#x2F; 18位素数：154590409516822759  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 19位素数：2305843009213693951 (梅森素数)  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 19位素数：4384957924686954497  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">LL prime[6] &#x3D; &#123;2, 3, 5, 233, 331&#125;;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">LL qmul(LL x, LL y, LL mod) &#123; &#x2F;&#x2F; 乘法防止溢出， 如果p * p不爆LL的话可以直接乘； O(1)乘法或者转化成二进制加法  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    return (x * y - (long long)(x &#x2F; (long double)mod * y + 1e-3) *mod + mod) % mod;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    LL ret &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    while(y) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        if(y &amp; 1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            ret &#x3D; (ret + x) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; x * 2 % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        y &gt;&gt;&#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    return ret;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    *&#x2F;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">LL qpow(LL a, LL n, LL mod) &#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    LL ret &#x3D; 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    while(n) &#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        if(n &amp; 1) ret &#x3D; qmul(ret, a, mod);  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        a &#x3D; qmul(a, a, mod);  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        n &gt;&gt;&#x3D; 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    return ret;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">bool Miller_Rabin(LL p) &#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    if(p &lt; 2) return 0;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    if(p !&#x3D; 2 &amp;&amp; p % 2 &#x3D;&#x3D; 0) return 0;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    LL s &#x3D; p - 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    while(! (s &amp; 1)) s &gt;&gt;&#x3D; 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; 5; ++i) &#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        if(p &#x3D;&#x3D; prime[i]) return 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        LL t &#x3D; s, m &#x3D; qpow(prime[i], s, p);  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        while(t !&#x3D; p - 1 &amp;&amp; m !&#x3D; 1 &amp;&amp; m !&#x3D; p - 1) &#123;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            m &#x3D; qmul(m, m, p);  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            t &lt;&lt;&#x3D; 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        if(m !&#x3D; p - 1 &amp;&amp; !(t &amp; 1)) return 0;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    return 1;  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类欧几里得</title>
      <link href="/2020/03/07/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2020/03/07/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>类欧几里得的总结</p><a id="more"></a><h2 id="类欧几里得的作用"><a href="#类欧几里得的作用" class="headerlink" title="类欧几里得的作用"></a>类欧几里得的作用</h2><p>类欧几里得主要用于加速下列三种函数（log）:</p><p>f(a,b,c,n)=∑ni=0⌊ai+bc⌋f(a,b,c,n)=∑i=0n⌊ai+bc⌋</p><p>g(a,b,c,n)=∑ni=0⌊ai+bc⌋2g(a,b,c,n)=∑i=0n⌊ai+bc⌋2</p><p>h(a,b,c,n)=∑ni=0i⌊ai+bc⌋h(a,b,c,n)=∑i=0ni⌊ai+bc⌋</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#pragma GCC optimize(3)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">constexpr int mod &#x3D; 998244353;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">constexpr ll inv2 &#x3D; 499122177;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">constexpr ll inv6 &#x3D; 166374059;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">ll f(ll a, ll b, ll c, ll n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">ll g(ll a, ll b, ll c, ll n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">ll h(ll a, ll b, ll c, ll n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">struct Query &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    ll f, g, h;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">Query solve(ll a, ll b, ll c, ll n) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    Query ans, tmp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    if (a &#x3D;&#x3D; 0) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        ans.f &#x3D; (n + 1) * (b &#x2F; c) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        ans.g &#x3D; (b &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        ans.h &#x3D; (n + 1) * (b &#x2F; c) % mod * (b &#x2F; c) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        return ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    if (a &gt;&#x3D; c || b &gt;&#x3D; c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        tmp &#x3D; solve(a % c, b % c, c, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        ans.f &#x3D; (tmp.f + (a &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod + (b &#x2F; c) * (n + 1) % mod) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        ans.g &#x3D; (tmp.g + (a &#x2F; c) * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        ans.h &#x3D; ((a &#x2F; c) * (a &#x2F; c) % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                (b &#x2F; c) * (b &#x2F; c) % mod * (n + 1) % mod + (a &#x2F; c) * (b &#x2F; c) % mod * n % mod * (n + 1) % mod +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                tmp.h + 2 * (a &#x2F; c) % mod * tmp.g % mod + 2 * (b &#x2F; c) % mod * tmp.f % mod) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        return ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    ll m &#x3D; (a * n + b) &#x2F; c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    tmp &#x3D; solve(c, c - b - 1, a, m - 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    ans.f &#x3D; (n * (m % mod) % mod - tmp.f) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    ans.g &#x3D; (n * (n + 1) % mod * (m % mod) % mod - tmp.f - tmp.h) % mod * inv2 % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    ans.h &#x3D; (n * (m % mod) % mod * ((m + 1) % mod) % mod - 2 * tmp.g - 2 * tmp.f - ans.f) % mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    return ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">inline char nc() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    static char buf[1000000], *p1 &#x3D; buf, *p2 &#x3D; buf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    return p1 &#x3D;&#x3D; p2 &amp;&amp; (p2 &#x3D; (p1 &#x3D; buf) + fread(buf, 1, 1000000, stdin), p1 &#x3D;&#x3D; p2) ? EOF : *p1++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">inline ll read() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    ll res &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    char ch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    do ch &#x3D; nc(); while (ch &lt; 48 || ch &gt; 57);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    do res &#x3D; res * 10 + ch - 48, ch &#x3D; nc(); while (ch &gt;&#x3D; 48 &amp;&amp; ch &lt;&#x3D; 57);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    return res;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">char pbuf[1 &lt;&lt; 20], *pp &#x3D; pbuf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">inline void push(const char &amp;c) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    if (pp - pbuf &#x3D;&#x3D; 1 &lt;&lt; 20) fwrite(pbuf, 1, 1 &lt;&lt; 20, stdout), pp &#x3D; pbuf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    *pp++ &#x3D; c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">inline void write(int x) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    static ll sta[35];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    ll top &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    do &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        sta[top++] &#x3D; x % 10, x &#x2F;&#x3D; 10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    &#125; while (x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    while (top) push(sta[--top] + &#39;0&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">int main() &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    ll t &#x3D; read();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    ll n, a, b, c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">    while (t--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        n &#x3D; read(), a &#x3D; read(), b &#x3D; read(), c &#x3D; read();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        Query ans &#x3D; solve(a, b, c, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld %lld %lld\n&quot;, (ans.f + mod) % mod, (ans.h + mod) % mod, (ans.g + mod) % mod);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展KMP</title>
      <link href="/2020/03/07/%E6%89%A9%E5%B1%95KMP/"/>
      <url>/2020/03/07/%E6%89%A9%E5%B1%95KMP/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>扩展KMP的总结</p><a id="more"></a><h2 id="题目传送门：HDU-6153-A-Secret"><a href="#题目传送门：HDU-6153-A-Secret" class="headerlink" title="题目传送门：HDU-6153 A Secret"></a>题目传送门：<a href="https://cn.vjudge.net/problem/HDU-6153" target="_blank" rel="noopener">HDU-6153 A Secret</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定两个串，求其中一个串s的每个后缀在另一个串t中出现的次数乘以其长度之和。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><ol><li>将S与T串反转，转换成求前缀问题</li><li>扩展KMP求S的每个后缀与T串的最长公共前缀（extend[i] 表示 S[i..n-1] 与 T 的最长公共前缀）。</li><li>然后遍历 extend 数组， 值不为零的加上一个等差数列的和（1，2，3…extend[i]）。</li></ol><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">const ll maxn &#x3D; 1000005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const ll mod &#x3D; 1000000007;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ll nex[maxn], extend[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">char a[maxn], b[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">void pre_EKMP(char x[], ll m, ll nex[])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    nex[0] &#x3D; m;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    ll j &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    while(j + 1 &lt; m &amp;&amp; x[j] &#x3D;&#x3D; x[j + 1])j++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    nex[1] &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    ll k &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(ll i &#x3D; 2; i &lt; m; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        ll p &#x3D; nex[k] + k - 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ll L &#x3D; nex[i - k];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        if(i + L &lt; p + 1)nex[i] &#x3D; L;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            j &#x3D; max((ll)0, p - i + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            while(i + j &lt; m &amp;&amp; x[i + j] &#x3D;&#x3D; x[j])j++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            nex[i] &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            k &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">void EKMP(char x[], ll m, char y[], ll n, ll nex[], ll extend[])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    pre_EKMP(x, m, nex);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    ll j &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    while(j &lt; n &amp;&amp; j &lt; m &amp;&amp; x[j] &#x3D;&#x3D; y[j])j++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    extend[0] &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    ll k &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    for(ll i &#x3D; 1; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        ll p &#x3D; extend[k] + k - 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        ll L &#x3D; nex[i - k];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        if(i + L &lt; p + 1)extend[i] &#x3D; L;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            j &#x3D; max((ll)0, p - i + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            while(i + j &lt; n &amp;&amp; j &lt; m &amp;&amp; y[i + j] &#x3D;&#x3D; x[j])j++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">            extend[i] &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">            k &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    ll t, n, m, i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%lld&quot;, &amp;t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    while(t--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%s %s&quot;, a, b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        n &#x3D; strlen(a), m &#x3D; strlen(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n &#x2F; 2; i++)swap(a[i],a[n - 1 - i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m &#x2F; 2; i++)swap(b[i],b[m - 1 - i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        EKMP(b, strlen(b), a, strlen(a), nex, extend);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        ll ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            ans +&#x3D; (1 + extend[i]) * extend[i] &#x2F; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            ans %&#x3D; mod;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回文树</title>
      <link href="/2020/03/07/%E5%9B%9E%E6%96%87%E6%A0%91/"/>
      <url>/2020/03/07/%E5%9B%9E%E6%96%87%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回文树的总结</p><a id="more"></a><h2 id="回文树详解"><a href="#回文树详解" class="headerlink" title="回文树详解"></a>回文树详解</h2><p>今天我们来学习一个神奇的数据结构：Palindromic Tree。中译过来就是——回文树。</p><p>那么这个回文树有何功能？</p><h3 id="回文树的功能"><a href="#回文树的功能" class="headerlink" title="回文树的功能"></a>回文树的功能</h3><p>假设我们有一个串S，S下标从0开始，则回文树能做到如下几点：</p><p>1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同）</p><p>2.求串S内每一个本质不同回文串出现的次数</p><p>3.求串S内回文串的个数（其实就是1和2结合起来）</p><p>4.求以下标i结尾的回文串的个数</p><h3 id="回文树的构造过程"><a href="#回文树的构造过程" class="headerlink" title="回文树的构造过程"></a>回文树的构造过程</h3><p>那么我们该如何构造回文树？</p><p>首先我们定义一些变量。</p><p>1.len[i]表示编号为i的节点表示的回文串的长度（一个节点表示一个回文串）</p><p>2.next[i][c]表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号（和字典树类似）。</p><p>3.fail[i]表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串（和AC自动机类似）。</p><p>4.cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的）</p><p>5.num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。</p><p>6.last指向新添加一个字母后所形成的最长回文串表示的节点。</p><p>7.S[i]表示第i次添加的字符（一开始设S[0] = -1（可以是任意一个在串S中不会出现的字符））。</p><p>8.p表示添加的节点个数。</p><p>9.n表示添加的字符个数。</p><p>一开始回文树有两个节点，0表示偶数长度串的根和1表示奇数长度串的根，且len[0] = 0，len[1] = -1，last = 0，S[0] = -1，n = 0，p = 2（添加了节点0、1）。</p><p><img src="https://img-blog.csdn.net/20141223143320477" alt="img"><br><img src="https://img-blog.csdn.net/20141223122035759" alt="img"></p><p>假设现在我们有串S = abbaabba。</p><p>首先我们添加第一个字符’a’，S[++ n] = ‘a’，然后判断此时S[n - len[last] - 1]是否等于S[n]，即上一个串-1的位置和新添加的位置是否相同，相同则说明构成回文。否则，last = fail[last]。此时last = 0，我们发现S[1 - 0 - 1] != S[1]，所以last = fail[last] = 1，然后我们发现S[1 - (-1) - 1] == S[1]（即自己等于自己，所以我们让len[1]等于-1可以让这一步更加方便）。</p><p>令cur等于此时的last（即cur = last = 1），判断此时next[cur][‘a’]是否已经有后继，如果next[cur][‘a’]没有后继，我们就进行如下的步骤：新建节点（节点数p++，且之后p = 3），并让now等于新节点的编号（now = 2），则len[now] = len[cur] + 2（每一个回文串的长度总是在其最长子回文串的基础上在两边加上两个相同的字符构成的，所以是+2，同时体现出我们让len[1] = -1的优势，一个字符自成一个奇回文串时回文串的长度为(-1) + 2 = 1）。然后我们让fail[now] = next[get_fail ( fail[cur] )][‘a’]，即得到fail[now]（此时为fail[2] = 0），其中的get_fail函数就是让找到第一个使得S[n - len[last] - 1] == S[n]的last。然后next[cur][‘a’] = now。</p><p>当上面步骤完成后我们让last = next[cur][c]（不管next[cur][‘a’]是否有后继），然后cnt[last] ++。</p><p>此时回文树为下图状态：</p><p><img src="https://img-blog.csdn.net/20141223142946632" alt="img"><br><img src="https://img-blog.csdn.net/20141223130816445" alt="img"></p><p>现在我们添加第二个字符字符’b’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223143827221" alt="img"><br><img src="https://img-blog.csdn.net/20141223132439949" alt="img"></p><p>继续添加第三个字符’b’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223144151940" alt="img"><br><img src="https://img-blog.csdn.net/20141223134028009" alt="img"></p><p>继续添加第四个字符’a’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223144805951" alt="img"><br><img src="https://img-blog.csdn.net/20141223144227000" alt="img"></p><p>继续添加第五个字符’a’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223150032521" alt="img"><br><img src="https://img-blog.csdn.net/20141223144902688" alt="img"></p><p>继续添加第六个字符’b’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223150534023" alt="img"><br><img src="https://img-blog.csdn.net/20141223145158906" alt="img"></p><p>继续添加第七个字符’b’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223150807121" alt="img"><br><img src="https://img-blog.csdn.net/20141223145251135" alt="img"></p><p>继续添加第八个字符’a’到回文树中：</p><p><img src="https://img-blog.csdn.net/20141223151025968" alt="img"><br><img src="https://img-blog.csdn.net/20141223145255296" alt="img"></p><p>到此，串S已经完全插入到回文树中了，现在所有的数据如下：</p><p><img src="https://img-blog.csdn.net/20141223153851123" alt="img"></p><p>然后我们将节点x在fail指针树中将自己的cnt累加给父亲，从叶子开始倒着加，最后就能得到串S中出现的每一个本质不同回文串的个数。</p><h3 id="回文树的复杂度"><a href="#回文树的复杂度" class="headerlink" title="回文树的复杂度"></a>回文树的复杂度</h3><p>构造回文树需要的空间复杂度为O（N<em>字符集大小），时间复杂度为O（N</em>log（字符集大小）），这个时间复杂度比较神奇。如果空间需求太大，可以改成邻接表的形式存储，不过相应的要牺牲一些时间。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 210005 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const int N &#x3D; 26 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">struct Palindromic_Tree &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int next[MAXN][N] ;&#x2F;&#x2F;next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    int fail[MAXN] ;&#x2F;&#x2F;fail指针，失配后跳转到fail指针指向的节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    long long cnt[MAXN] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    int num[MAXN] ; &#x2F;&#x2F;num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    int len[MAXN] ;&#x2F;&#x2F;len[i]表示节点i表示的回文串的长度</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    int S[MAXN] ;&#x2F;&#x2F;存放添加的字符</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    int last ;&#x2F;&#x2F;指向上一个字符所在的节点，方便下一次add</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    int n ;&#x2F;&#x2F;字符数组指针</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    int p ;&#x2F;&#x2F;节点指针</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    int newnode ( int l ) &#123;&#x2F;&#x2F;新建节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for ( int i &#x3D; 0 ; i &lt; N ; ++ i ) next[p][i] &#x3D; 0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        cnt[p] &#x3D; 0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        num[p] &#x3D; 0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        len[p] &#x3D; l ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        return p ++ ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    void init () &#123;&#x2F;&#x2F;初始化</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        p &#x3D; 0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        newnode (0) ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        newnode (-1) ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        last &#x3D; 0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        n &#x3D; 0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        S[n] &#x3D; -1 ;&#x2F;&#x2F;开头放一个字符集中没有的字符，减少特判</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        fail[0] &#x3D; 1 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    int get_fail ( int x ) &#123;&#x2F;&#x2F;和KMP一样，失配后找一个尽量最长的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        while ( S[n - len[x] - 1] !&#x3D; S[n] ) x &#x3D; fail[x] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        return x ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    void add ( int c ) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        c -&#x3D; &#39;a&#39; ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        S[++ n] &#x3D; c ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;  cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;(char)(S[n]+&#39;a&#39;)&lt;&lt;endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        int cur &#x3D; get_fail ( last ) ;&#x2F;&#x2F;通过上一个回文串找这个回文串的匹配位置</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        if ( !next[cur][c] ) &#123;&#x2F;&#x2F;如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            int now &#x3D; newnode ( len[cur] + 2 ) ;&#x2F;&#x2F;新建节点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            fail[now] &#x3D; next[get_fail ( fail[cur] )][c] ;&#x2F;&#x2F;和AC自动机一样建立fail指针，以便失配后跳转</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">            next[cur][c] &#x3D; now ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            num[now] &#x3D; num[fail[now]] + 1 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        last &#x3D; next[cur][c] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        cnt[last] ++ ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    void count () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        for ( int i &#x3D; p - 1 ; i &gt;&#x3D; 0 ; -- i ) cnt[fail[i]] +&#x3D; cnt[i] ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;父亲累加儿子的cnt，因为如果fail[v]&#x3D;u，则u一定是v的子回文串！</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    void print()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;S[i]表示第i次添加的字符（一开始设S[0] &#x3D; -1（可以是任意一个在串S中不会出现的字符））</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;p-2;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%c &quot;,S[i]+&#39;a&#39;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        for(int i&#x3D;2;i&lt;p;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d &quot;,cnt[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        for(int i&#x3D;2;i&lt;p;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d &quot;,num[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">&#125; ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">Palindromic_Tree a1,b1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">long long ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">char a[201312],b[223123];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">void dfs(int x,int y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;0;i&lt;N;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        int x1 &#x3D;a1.next[x][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">        int y1 &#x3D;b1.next[y][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">        if(x1&amp;&amp;y1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">            ans+&#x3D;(long long)(a1.cnt[x1]*b1.cnt[y1]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">            cout&lt;&lt;a1.cnt[x1]&lt;&lt;&quot; &quot;&lt;&lt;b1.cnt[y1]&lt;&lt;endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">            dfs(x1,y1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">    int T;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">    cin&gt;&gt;T;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">    int yy &#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">    while(T--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%s%s&quot;,a,b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">        yy++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;Case #%d: &quot;,yy);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">        int len1 &#x3D;strlen(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">        int len2 &#x3D;strlen(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">         a1.init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">         b1.init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">        for(int i&#x3D;0;i&lt;len1;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">            a1.add(a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">        for(int i&#x3D;0;i&lt;len2;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">            b1.add(b[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">        a1.count();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">        b1.count();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">        a1.print();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">        cout&lt;&lt;endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">        b1.print();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">        ans &#x3D;0 ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">        dfs(0,0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">        cout&lt;&lt;endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">        cout&lt;&lt;endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">        dfs(1,1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="题集"><a href="#题集" class="headerlink" title="题集"></a>题集</h2><h3 id="题集链接"><a href="#题集链接" class="headerlink" title="题集链接"></a>题集链接</h3><p>“<a href="https://cn.vjudge.net/contest/283852#overview&quot;" target="_blank" rel="noopener">https://cn.vjudge.net/contest/283852#overview&quot;</a></p><h3 id="简易题解"><a href="#简易题解" class="headerlink" title="简易题解"></a>简易题解</h3><p>A UVALive 7041 【裸】<br>题意：求两个串的公共回文串的个数。</p><p>B HDU 3068【裸】<br>题意：求最长回文串的长度</p><p>C HDU 3948 【裸】<br>题意：求出本质不同的回文串个数。</p><p>D HYSBZ 2565<br>题意：求最长双回文子串的长度<br>正着跑一遍，反着跑一遍即可。</p><p>E URAL 1960<br>题意：求字符串的所有前缀 本质不同的回文串个数。<br>在添加字符的过程中直接输出即可。</p><p>F HYSBZ 3676<br>题意：我们定义s的一个子串t的“出<br>现值”为t在s中的出现次数乘以t的长度。请你求出s的所有回文子串中的最<br>大出现值。</p><p>G HDU 5658<br>题意：给定一个串，询问l到r右多少本质不同的回文串。</p><p>H HDU 5157</p><p>题意 ：给定一个字符串str，求str的不相交的回文子串的对数。<br>回文树num数组的运用。</p><p>I HYSBZ 2160<br>题意：给一个字符串，求最长的k个回文子串（此处回文子串长度必须为奇数）<br>长度的乘积。字符串长度≤1000000，即要将回文串按照长度从大到小选择k个出来,并求出长度乘积。</p><p>J HDU - 5785<br>题意：给你一个串，定义了一个权值，每个权值是两个回文串拼起来的左右坐标乘积。求所有权值的和。</p><p>注意细节，不然会爆空间</p><p>K CodeForces 17E<br>题意：求一个字符串中相交回文串的对数。</p><p>L HDU 5421（回文树扩展——可左右添加字符的回文树）<br>题意：有n种操作，开始给你一个空串，给你4种操作。<br>1 c 在字符串的首部添加字符c<br>2 c 在字符串的尾部添加字符c<br>3 询问字符中的本质不同的回文串的个数<br>4 询问字符串中回文串的个数</p><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://blog.csdn.net/u013368721/article/details/42100363" target="_blank" rel="noopener">https://blog.csdn.net/u013368721/article/details/42100363</a><br><a href="http://axuhongbo.top/tree/" target="_blank" rel="noopener">http://axuhongbo.top/tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>后缀数组</title>
      <link href="/2020/03/07/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
      <url>/2020/03/07/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>后缀数组的总结</p><a id="more"></a><h2 id="Step1-后缀数组模板-详细注释"><a href="#Step1-后缀数组模板-详细注释" class="headerlink" title="Step1 - 后缀数组模板+详细注释"></a>Step1 - 后缀数组模板+详细注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;rnk从0开始</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;sa从1开始,因为最后一个字符(最小的)排在第0位</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;height从1开始,因为表示的是sa[i - 1]和sa[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;倍增算法 O(nlogn)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Suffix函数的参数m代表字符串中字符的取值范围,是基数排序的一个参数,如果原序列都是字母可以直接取128,如果原序列本身都是整数的话,则m可以取比最大的整数大1的值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;待排序的字符串放在r数组中,从r[0]到r[n-1]，长度为n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为了方便比较大小,可以在字符串后面添加一个字符,这个字符没有在前面的字符中出现过,而且比前面的字符都要小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;同上,为了函数操作的方便,约定除r[n-1]外所有的r[i]都大于0,r[n-1]&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数结束后,结果放在sa数组中,从sa[0]到sa[n-1]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;对长度为1的字符串排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;一般来说,在字符串的题目中,r的最大值不会很大,所以这里使用了基数排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;如果r的最大值很大,那么把这段代码改成快速排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;&#x2F;&#x2F;统计字符的个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];&#x2F;&#x2F;统计不大于字符i的字符个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;&#x2F;&#x2F;计算字符排名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;基数排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;x数组保存的值相当于是rank值</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;j是当前字符串的长度,数组y保存的是对第二关键字排序的结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;第二关键字排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;&#x2F;&#x2F;第二关键字为0的排在前面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;&#x2F;&#x2F;长度为j的子串sa[i]应该是长度为2 * j的子串sa[i] - j的后缀（第二关键字）,对所有的长度为2 * j的子串根据第二关键字来排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];&#x2F;&#x2F;提取第一关键字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;按第一关键字排序 (原理同对长度为1的字符串排序)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];&#x2F;&#x2F;按第一关键字,计算出了长度为2 * j的子串排名情况</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;此时数组x是长度为j的子串的排名情况,数组y仍是根据第二关键字排序后的结果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;计算长度为2 * j的子串的排名情况,保存到数组x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;若长度为2 * j的子串sa[i]与sa[i - 1]完全相同,则他们有相同的排名</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="Step2-模板的使用"><a href="#Step2-模板的使用" class="headerlink" title="Step2 - 模板的使用"></a>Step2 - 模板的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">scanf(&quot;%s&quot;, str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">int len &#x3D; strlen(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">for(i &#x3D; 0; i &lt; len; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    r[i] &#x3D; str[i] - &#39;a&#39; + 1;&#x2F;&#x2F;将字符串填入r数组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">r[i] &#x3D; 0;&#x2F;&#x2F;末尾添加一个字符集中没有的树，保证字典序最小，便于编排数组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Suffix(r, sa, len + 1, m);&#x2F;&#x2F;m为字符集大小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">calheight(r, sa, len);&#x2F;&#x2F;求 Height 数组</span></pre></td></tr></table></figure><h2 id="Step3-后缀数组的应用"><a href="#Step3-后缀数组的应用" class="headerlink" title="Step3 - 后缀数组的应用"></a>Step3 - 后缀数组的应用</h2><h3 id="Step3-1-最长公共前缀"><a href="#Step3-1-最长公共前缀" class="headerlink" title="Step3.1 - 最长公共前缀"></a>Step3.1 - 最长公共前缀</h3><h4 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串，询问某两个后缀的最长公共前缀。</p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>按照上面所说的做法，求两个后缀的最长公共前缀可以转化为求某个区间上 的最小值。对于这个 RMQ 问题（如果对 RMQ 问题不熟悉，请阅读其他相关资料）， 可以用 O(nlogn)的时间先预处理，以后每次回答询问的时间为 O(1)。所以对于 本问题，预处理时间为 O(nlogn)，每次回答询问的时间为 O(1)。如果 RMQ 问题 用 O(n)的时间预处理，那么本问题预处理的时间可以做到 O(n)。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;后缀数组部分</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;RMQ部分</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">int n,minnum[MAXN][17];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">void RMQ()   &#x2F;&#x2F;预处理  O(nlogn)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">int i,j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">int m&#x3D;(int)(log(n*1.0)&#x2F;log(2.0));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">minnum[i][0]&#x3D;height[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">for(j&#x3D;1;j&lt;&#x3D;m;j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">for(i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">minnum[i][j]&#x3D;min(minnum[i][j-1],minnum[i+(1&lt;&lt;(j-1))][j-1]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">int ask(int a,int b) &#x2F;&#x2F;O(1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">int k&#x3D;int(log(b-a+1.0)&#x2F;log(2.0));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">return min(minnum[a][k],minnum[b-(1&lt;&lt;k)+1][k]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">int askpre(int a,int b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    a&#x3D;Rank[a],b&#x3D;Rank[b];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    if(a&gt;b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        swap(a,b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    return ask(a+1,b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">char str[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%s&quot;, str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    n &#x3D; strlen(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    int i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        r[i] &#x3D; str[i] - &#39;a&#39; + 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">    r[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">    Suffix(r, sa, n + 1, 27);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    calheight(r, sa, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    RMQ();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    int q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;, &amp;q);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">    while(q--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        int l, r;&#x2F;&#x2F; 0 &lt;&#x3D; l &lt;&#x3D; r &lt; n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d %d&quot;, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;, askpre(l, r));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="Step3-2-单个字符串的相关问题"><a href="#Step3-2-单个字符串的相关问题" class="headerlink" title="Step3.2 - 单个字符串的相关问题"></a>Step3.2 - 单个字符串的相关问题</h3><p>这类问题的一个常用做法是先求后缀数组和 height 数组，然后利用 height 数组进行求解。</p><h3 id="1-重复子串"><a href="#1-重复子串" class="headerlink" title="1. 重复子串"></a>1. 重复子串</h3><h3 id="1-1-可重叠最长重复子串"><a href="#1-1-可重叠最长重复子串" class="headerlink" title="1.1 可重叠最长重复子串"></a>1.1 可重叠最长重复子串</h3><h4 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串，求最长重复子串，这两个子串可以重叠。</p><h4 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h4><p>这道题是后缀数组的一个简单应用。做法比较简单，只需要求 height 数组 里的最大值即可。首先求最长重复子串，等价于求两个后缀的最长公共前缀的最 大值。因为任意两个后缀的最长公共前缀都是 height 数组里某一段的最小值， 那么这个值一定不大于 height 数组里的最大值。所以最长重复子串的长度就是 height 数组里的最大值。这个做法的时间复杂度为 O(n)。</p><h3 id="1-2-不可重叠最长重复子串（poj-1743）"><a href="#1-2-不可重叠最长重复子串（poj-1743）" class="headerlink" title="1.2 不可重叠最长重复子串（poj 1743）"></a>1.2 不可重叠最长重复子串（poj 1743）</h3><h4 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串，求最长重复子串，这两个子串不能重叠。</p><h4 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h4><p>这题比上一题稍复杂一点。先二分答案，把题目变成判定性问题：判断是否 存在两个长度为 k 的子串是相同的，且不重叠。解决这个问题的关键还是利用 height 数组。把排序后的后缀分成若干组，其中每组的后缀之间的 height 值都 不小于 k。例如，字符串为“aabaaaab”，当 k=2 时，后缀分成了 4 组，如图 所示。</p><p><a href="https://img-blog.csdn.net/20180718214818842?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JiYmJzd2Jx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener"><img src="https://img-blog.csdn.net/20180718214818842?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JiYmJzd2Jx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></a></p><p>容易看出，有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然 后对于每组后缀，只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于 k。如果有一组满足，则说明存在，否则不存在。整个做法的时间复杂度为 O(nlogn)。本题中利用 height 值对后缀进行分组的方法很常用，请读者认真体 会。</p><h4 id="代码（待测）"><a href="#代码（待测）" class="headerlink" title="代码（待测）"></a>代码（待测）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">int n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">int check(int k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    int mx &#x3D; -0x3f3f3f, mm &#x3D; 0x3f3f3f;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 2; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        if(height[i] &gt;&#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            mm &#x3D; min(mm, min(sa[i], sa[i - 1]));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            mx &#x3D; max(mx, max(sa[i], sa[i - 1]));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            if(mx - mm &gt; k)return 1;&#x2F;&#x2F;如果两个sa相差大于k（等于k不行）则答案可行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">            mx &#x3D; -0x3f3f3f, mm &#x3D; 0x3f3f3f;&#x2F;&#x2F;重新分组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    int i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        if(n &#x3D;&#x3D; 0)break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;r[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        n--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; i++)r[i] &#x3D; r[i + 1] - r[i] + 89;&#x2F;&#x2F;求差值去掉负数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        r[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        Suffix(r, sa, n + 1, 300);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        calheight(r, sa, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        int l &#x3D; 0, r &#x3D; n &#x2F; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        while(l &lt; r)&#x2F;&#x2F;二分答案</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">            int mid &#x3D; (l + r + 1) &#x2F; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">            if(check(mid))l &#x3D; mid;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            else r &#x3D; mid - 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        if(l &gt;&#x3D; 4)printf(&quot;%d\n&quot;, l + 1);&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        else printf(&quot;0\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="1-3-可重叠的-k-次最长重复子串（poj3261）"><a href="#1-3-可重叠的-k-次最长重复子串（poj3261）" class="headerlink" title="1.3 可重叠的 k 次最长重复子串（poj3261）"></a>1.3 可重叠的 k 次最长重复子串（poj3261）</h3><h4 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串，求至少出现 k 次的最长重复子串，这 k 个子串可以重叠。</p><h4 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h4><p>这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不 同的是，这里要判断的是有没有一个组的后缀个数不小于 k。如果有，那么存在 k 个相同的子串满足条件，否则不存在。这个做法的时间复杂度为 O(nlogn)。</p><h4 id="代码（待测）-1"><a href="#代码（待测）-1" class="headerlink" title="代码（待测）"></a>代码（待测）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 1000005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">int n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">int check(int k, int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    int sum &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 2; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        if(height[i] &gt;&#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            sum++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            sum &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        if(sum &gt;&#x3D; x)return 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    int i, k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;r[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    r[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    Suffix(r, sa, n + 1, 1000005);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    calheight(r, sa, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    if(k &#x3D;&#x3D; 1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        if(k &#x3D;&#x3D; 2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">            int ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">            for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans &#x3D; max(ans, height[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">            int l &#x3D; 0, r &#x3D; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">            while(l &lt; r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">                int mid &#x3D; (l + r + 1) &#x2F; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">                if(check(mid, k))l &#x3D; mid;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">                else r &#x3D; mid - 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="2-子串的个数"><a href="#2-子串的个数" class="headerlink" title="2. 子串的个数"></a>2. 子串的个数</h3><h3 id="2-1-不相同的子串的个数（spoj694-spoj705）"><a href="#2-1-不相同的子串的个数（spoj694-spoj705）" class="headerlink" title="2.1 不相同的子串的个数（spoj694,spoj705）"></a>2.1 不相同的子串的个数（spoj694,spoj705）</h3><h4 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串，求不相同的子串的个数。</p><h4 id="解题思路：-4"><a href="#解题思路：-4" class="headerlink" title="解题思路："></a>解题思路：</h4><p>每个子串一定是某个后缀的前缀，那么原问题等价于求所有后缀之间的不相 同的前缀的个数。如果所有的后缀按照 suffix(sa[1]), suffix(sa[2]), suffix(sa[3]), …… ,suffix(sa[n])的顺序计算，不难发现，对于每一次新加 进来的后缀 suffix(sa[k]),它将产生 n-sa[k]+1 个新的前缀。但是其中有 height[k]个是和前面的字符串的前缀是相同的。所以 suffix(sa[k])将“贡献” 出 n-sa[k]+1- height[k]个不同的子串。累加后便是原问题的答案。这个做法 的时间复杂度为 O(n)。</p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 1000005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">int n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">char str[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    int t, i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    while (t--) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%s&quot;, str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        n &#x3D; strlen(str);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; i++)r[i] &#x3D; str[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        r[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        Suffix(r, sa, n + 1, 300);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        calheight(r, sa, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        ll ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; n; i++) ans +&#x3D; n-sa[i]-height[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    return 0;&#x2F;&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="3-回文子串"><a href="#3-回文子串" class="headerlink" title="3. 回文子串"></a>3. 回文子串</h3><h1 id="留坑"><a href="#留坑" class="headerlink" title="留坑"></a>留坑</h1><h3 id="4-连续重复字串"><a href="#4-连续重复字串" class="headerlink" title="4. 连续重复字串"></a>4. 连续重复字串</h3><h3 id="4-1-连续重复子串-poj2406"><a href="#4-1-连续重复子串-poj2406" class="headerlink" title="4.1 连续重复子串(poj2406)"></a>4.1 连续重复子串(poj2406)</h3><h4 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串 L，已知这个字符串是由某个字符串 S 重复 R 次而得到的， 求 R 的最大值。</p><h4 id="解题思路：-5"><a href="#解题思路：-5" class="headerlink" title="解题思路："></a>解题思路：</h4><p>做法比较简单，穷举字符串 S 的长度 k，然后判断是否满足。判断的时候， 先看字符串 L 的长度能否被 k 整除，再看 suffix(1)和 suffix(k+1)的最长公共 前缀是否等于 n-k。在询问最长公共前缀的时候，suffix(1)是固定的，所以 RMQ 问题没有必要做所有的预处理，只需求出 height 数组中的每一个数到 height[rank[1]]之间的最小值即可。整个做法的时间复杂度为 O(n)。</p><p>也可以使用 KMP 最小循环节解决</p><h4 id="代码（待测）-2"><a href="#代码（待测）-2" class="headerlink" title="代码（待测）"></a>代码（待测）</h4><h1 id="留坑-1"><a href="#留坑-1" class="headerlink" title="留坑"></a>留坑</h1><h3 id="4-2-重复次数最多的连续重复子串-SPOJ-REPEATS"><a href="#4-2-重复次数最多的连续重复子串-SPOJ-REPEATS" class="headerlink" title="4.2 重复次数最多的连续重复子串(SPOJ-REPEATS)"></a>4.2 重复次数最多的连续重复子串(SPOJ-REPEATS)</h3><h4 id="题目大意：-6"><a href="#题目大意：-6" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定一个字符串，求重复次数最多的连续重复子串。</p><h4 id="解题思路：-6"><a href="#解题思路：-6" class="headerlink" title="解题思路："></a>解题思路：</h4><p>先穷举长度 L，然后求长度为 L 的子串最多能连续出现几次。首先连续出现 1 次是肯定可以的，所以这里只考虑至少 2 次的情况。假设在原字符串中连续出 现 2 次，记这个子字符串为 S，那么 S 肯定包括了字符 r[0], r[L], r[L<em>2], r[L<em>3], ……中的某相邻的两个。所以只须看字符 r[L</em>i]和 r[L</em>(i+1)]往前和 往后各能匹配到多远，记这个总长度为 K，那么这里连续出现了 K/L+1 次。最后 看最大值是多少。如图所示。</p><p><a href="https://img-blog.csdn.net/20161104093604718" target="_blank" rel="noopener"><img src="https://img-blog.csdn.net/20161104093604718" alt="img"></a></p><p>穷举长度 L 的时间是 n，每次计算的时间是 n/L。所以整个做法的时间复杂 度是 O(n/1+n/2+n/3+……+n/n)=O(nlogn)。</p><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 50005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">int n,minnum[MAXN][16];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">void RMQ()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">int i,j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">int m&#x3D;(int)(log(n*1.0)&#x2F;log(2.0));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">for(i&#x3D;1;i&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">minnum[i][0]&#x3D;height[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">for(j&#x3D;1;j&lt;&#x3D;m;j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">for(i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">minnum[i][j]&#x3D;min(minnum[i][j-1],minnum[i+(1&lt;&lt;(j-1))][j-1]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">int Ask_MIN(int a,int b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">int k&#x3D;int(log(b-a+1.0)&#x2F;log(2.0));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">return min(minnum[a][k],minnum[b-(1&lt;&lt;k)+1][k]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">int calprefix(int a,int b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    a&#x3D;Rank[a],b&#x3D;Rank[b];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    if(a&gt;b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        swap(a,b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    return Ask_MIN(a+1,b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">char s[5];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    int t,i,j,k,ans,Max;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    while(t--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        Max&#x3D;1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        for(i&#x3D;0;i&lt;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%s&quot;,s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">            r[i]&#x3D;s[0]-&#39;a&#39;+1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        r[i]&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        Suffix(r,sa,n+1,3);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        calheight(r,sa,n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        RMQ();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        for(i&#x3D;1;i&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">            for(j&#x3D;0;j+i&lt;n;j+&#x3D;i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">                ans&#x3D;calprefix(j,j+i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">                k&#x3D;j-(i-ans%i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">                ans&#x3D;ans&#x2F;i+1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">                if(k&gt;&#x3D;0&amp;&amp;calprefix(k,k+i)&gt;&#x3D;i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">                    ans++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">                Max&#x3D;max(Max,ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;,Max);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="Step3-3-两个字符串的相关问题"><a href="#Step3-3-两个字符串的相关问题" class="headerlink" title="Step3.3 - 两个字符串的相关问题"></a>Step3.3 - 两个字符串的相关问题</h3><p>这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和 height 数组，再利用 height 数组进行求解。</p><h3 id="1-最长公共字串"><a href="#1-最长公共字串" class="headerlink" title="1. 最长公共字串"></a>1. 最长公共字串</h3><h4 id="题目大意：-7"><a href="#题目大意：-7" class="headerlink" title="题目大意："></a>题目大意：</h4><p>给定两个字符串 A 和 B，求最长公共子串。</p><h4 id="解题思路：-7"><a href="#解题思路：-7" class="headerlink" title="解题思路："></a>解题思路：</h4><p>分隔符将两个字符串连接</p><p>后缀数组求height数组后</p><p>只要相邻两个分别在两串，就可以用height更新ans</p><h4 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define ll long long</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 50005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">void Suffix(int *r, int *sa, int n, int m)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        t &#x3D; x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        x &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        y &#x3D; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">void calheight(int *r,int *sa,int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    int i,j,k&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">char a[MAXN], b[MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">int n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    int i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%s %s&quot;, a, b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    int lena &#x3D; strlen(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    int lenb &#x3D; strlen(b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; lena; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        r[i] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    r[lena] &#x3D; &#39;#&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 0; i &lt; lenb; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        r[i + lena + 1] &#x3D; b[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    r[lena + lenb + 1] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    Suffix(r, sa, lena + lenb + 2, 300);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    calheight(r, sa, lena + lenb + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    n &#x3D; lena + lenb + 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    int ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 2; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        int pos1 &#x3D; sa[i - 1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        int pos2 &#x3D; sa[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        if(pos1 &lt;&#x3D; lena &amp;&amp; pos2 &lt;&#x3D; lena)continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        else if(pos1 &gt; lena + 1&amp;&amp; pos2 &gt; lena + 1)continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        else ans &#x3D; max(ans, height[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%d\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="2-子串的个数-1"><a href="#2-子串的个数-1" class="headerlink" title="2. 子串的个数"></a>2. 子串的个数</h3><h1 id="留坑-2"><a href="#留坑-2" class="headerlink" title="留坑"></a>留坑</h1><h3 id="Step3-4-多个字符串的相关问题"><a href="#Step3-4-多个字符串的相关问题" class="headerlink" title="Step3.4 - 多个字符串的相关问题"></a>Step3.4 - 多个字符串的相关问题</h3><h1 id="留坑-3"><a href="#留坑-3" class="headerlink" title="留坑"></a>留坑</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分匹配</title>
      <link href="/2020/03/07/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/"/>
      <url>/2020/03/07/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二分匹配的总结</p><a id="more"></a><h2 id="HYSBZ-1143-祭祀river-二分图最大匹配"><a href="#HYSBZ-1143-祭祀river-二分图最大匹配" class="headerlink" title="HYSBZ - 1143 祭祀river (二分图最大匹配)"></a>HYSBZ - 1143 祭祀river (二分图最大匹配)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">105</span>] = &#123;<span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">205</span>], s[<span class="number">205</span>] = &#123;<span class="number">0</span>&#125;, vis[<span class="number">105</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cat</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span> &amp;&amp; a[x][i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            vis[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!s[i] || cat(s[i], n))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                s[i] = x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m, i, j, k, u, v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        a[u][v] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(a[i][k] == <span class="number">1</span> &amp;&amp; a[k][j] == <span class="number">1</span>)a[i][j] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(cat(i, n))ans++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆与哈夫曼树</title>
      <link href="/2020/03/07/%E5%A0%86%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2020/03/07/%E5%A0%86%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>堆与哈夫曼树的总结</p><a id="more"></a><h1 id="堆与哈夫曼树"><a href="#堆与哈夫曼树" class="headerlink" title="堆与哈夫曼树"></a>堆与哈夫曼树</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="前置知识-5min"><a href="#前置知识-5min" class="headerlink" title="前置知识(5min)"></a>前置知识(5min)</h3><h4 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h4><p><font color='red'>二叉树</font>是每个结点最多有<font color='red'>两个子树</font>的树结构</p><h4 id="什么是满二叉树"><a href="#什么是满二叉树" class="headerlink" title="什么是满二叉树"></a>什么是满二叉树</h4><p>一个二叉树，如果<font color='red'>每一个层的结点数都达到最大值</font>，则这个二叉树就是<font color='red'>满二叉树</font></p><h4 id="什么是完全二叉树"><a href="#什么是完全二叉树" class="headerlink" title="什么是完全二叉树"></a>什么是完全二叉树</h4><p>对于深度为K的，有n个结点的二叉树，当且仅当其<font color='red'>每一个结点</font>都与深度为K的<font color='red'>满二叉树</font>中编号从1至n的结点<font color='red'>一一对应</font>时称之为<font color='red'>完全二叉树</font></p><p>用一张图可以较清楚的展示三者的区别</p><p><img src="https://i.loli.net/2020/02/03/tm3eG8udaivQlF4.png" alt="tm3eG8udaivQlF4.png (1294×599)"></p><h3 id="堆是什么-0-5min"><a href="#堆是什么-0-5min" class="headerlink" title="堆是什么(0.5min)"></a>堆是什么(0.5min)</h3><p>堆是计算机科学中的一类<font color='red'>数据结构</font></p><h3 id="堆有什么特点-5min"><a href="#堆有什么特点-5min" class="headerlink" title="堆有什么特点(5min)"></a>堆有什么特点(5min)</h3><ul><li><p>堆总是一颗<font color='red'>完全二叉树</font></p></li><li><p>堆中任意一个节点总是<font color='red'>不大于（或不小于）</font>其父节点的值</p><p>[换言之，任意一个父节点的值一定大于等于（或小于等于）其所有子节点的值]</p></li></ul><p>例如：</p><p><img src="https://i.loli.net/2020/02/03/Am6osuZ578OSpJw.png" alt="img"></p><p>上述完全二叉树中，任意一个节点的值一定大于其子节点的值</p><p>7 &gt; 4 且 7 &gt; 6</p><p>4 &gt; 1 且 4 &gt; 3</p><p>6 &gt; 2 且 6 &gt; 5</p><p>因此，这课完全二叉树就可以叫做堆</p><p>补充：</p><ul><li>任意父节点大于等于子节点的堆叫<font color='red'>大顶堆</font></li><li>任意父节点小于等于子节点的堆叫<font color='red'>小顶堆</font></li></ul><h3 id="堆有什么用-4-5min"><a href="#堆有什么用-4-5min" class="headerlink" title="堆有什么用(4.5min)"></a>堆有什么用(4.5min)</h3><p>基于堆的特点，我们发现堆可以：</p><ul><li><p>快速获取一些元素中<font color='red'>最大的值（或最小的值）</font>（通过查询根节点的值实现）</p></li><li><p>通过不断取出当前元素中最大（或最小）的值来实现<font color='red'>排序</font></p><p>例如：</p><p>现在有一个堆，堆中的元素有[6, 8, 4]，规定这是一个大顶堆。</p><p>首先我们取出根节点，也就是 8，把 8 放入序列</p><p><img src="https://i.loli.net/2020/02/03/GPg1tvuEezZ6xFC.png" alt="img"></p><p>然后继续取出根节点，这时根节点是 6，把 6 放入序列</p><p><img src="https://i.loli.net/2020/02/03/APjpCHFRwb1zyXd.png" alt="img"></p><p>然后继续取出根节点，这时根节点是 4，把 4 放入序列</p><p><img src="https://i.loli.net/2020/02/03/C82NbVRLS53AWxw.png" alt="img"></p><p>排序完成，新序列为[8, 6, 4]。</p></li></ul><h3 id="如何建立一个堆-15min"><a href="#如何建立一个堆-15min" class="headerlink" title="如何建立一个堆(15min)"></a>如何建立一个堆(15min)</h3><h4 id="完全二叉树的一个性质-7min"><a href="#完全二叉树的一个性质-7min" class="headerlink" title="完全二叉树的一个性质(7min)"></a>完全二叉树的一个性质(7min)</h4><p><img src="https://i.loli.net/2020/02/03/yjIdvWXGtTl719u.png" alt="img"></p><p>上图是一颗完全二叉树，红字部分为给每个节点的标号，不难发现这样一个特点：</p><p><font color='red'>对于任意一个节点，其左儿子标号=该节点标号*2，其右儿子标号=该节点标号 *2+1</font></p><p>上图中：</p><p>2 = 1 * 2， 3 = 1 * 2 + 1</p><p>4 = 2 * 2， 5 = 2 * 2 + 1</p><p>6 = 3 * 2， 7 = 3 * 2 + 1</p><h4 id="用数组表示树-7-5min"><a href="#用数组表示树-7-5min" class="headerlink" title="用数组表示树(7.5min)"></a>用数组表示树(7.5min)</h4><p>基于上面得到的性质，<font color='red'>可以用一段数组来表示一颗完全二叉树</font>，而不再使用树形结构。</p><p>只需按照标号顺序依次向数组中放入每个节点即可用数组表示完全二叉树</p><p>例如在发现完全二叉树性质时使用的例子：</p><p>其数组表示为：</p><p>[7, 4, 6, 1, 3, 2, 5]</p><p>其标号顺序为：</p><p>[1, 2, 3, ,4, 5, 6, 7]</p><h4 id="用数组建立一个空堆-0-5min"><a href="#用数组建立一个空堆-0-5min" class="headerlink" title="用数组建立一个空堆(0.5min)"></a>用数组建立一个空堆(0.5min)</h4><p>那么如果要建立一个空堆（即没有任何元素的堆），只需要声明一个数组即可，因为堆本质就是一颗特殊的完全二叉树。</p><p>之后的讨论中默认新建的这个堆为大顶堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[N];</span></pre></td></tr></table></figure><h3 id="向堆中插入一个元素-15min"><a href="#向堆中插入一个元素-15min" class="headerlink" title="向堆中插入一个元素(15min)"></a>向堆中插入一个元素(15min)</h3><h4 id="在尾部添加新元素-3min"><a href="#在尾部添加新元素-3min" class="headerlink" title="在尾部添加新元素(3min)"></a>在尾部添加新元素(3min)</h4><p>现在向堆中插入第一个元素，我们只需要在数组的尾部插入即可，例如我们插入 4</p><p>现在数组变为[4]，表现为树形结构为：</p><p><img src="https://i.loli.net/2020/02/03/C82NbVRLS53AWxw.png" alt="img"></p><p>然后，插入第二个元素 6</p><p>现在数组变为[4, 6]，很显然</p><p>6 是 4的子节点，但4 &lt; 6，不符合大顶堆的性质，那么也就是说：</p><p>我们每次在数组尾部添加了一个新元素，需要重新维护数组中元素的顺序来保证堆的性质</p><h4 id="调整位置以保证堆的性质-12min"><a href="#调整位置以保证堆的性质-12min" class="headerlink" title="调整位置以保证堆的性质(12min)"></a>调整位置以保证堆的性质(12min)</h4><p>首先，我们来看一个插入元素的过程动画</p><p><img src="https://i.loli.net/2020/02/03/Yqw6G7uTOKli8cf.gif" alt="img"></p><p>在这个动画中，我们可以观察到，我们在堆的尾部添加了一个元素这个元素是不符合大顶堆的性质的，于是我们会对元素的位置进行调整。</p><p>可以比较清楚的发现，调整过程中，新插入元素一直在不停的与他的父亲节点交换，直到整棵完全二叉树合法</p><p>于是，我们可以这样编码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">heap[++len] = val; <span class="comment">// heap为堆数组，len为当前长度， val为新插入的元素，该步骤实现在尾部插入新元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp_pos = len; <span class="comment">//定义临时变量存储新添加元素当前的位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(temp_pos &gt; <span class="number">1</span> &amp;&amp; heap[temp_pos] &gt; heap[temp_pos / <span class="number">2</span>])<span class="comment">// temp_pos &gt; 1 保证了当前位置节点有父节点，根据完全二叉树性质，我们不难推断：一个节点的父节点标号=当前节点标号/2，heap[temp_pos] &gt; heap[temp_pos / 2]保证了当前元素还没有到达合适位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    swap(a[temp_pos], a[temp_pos/<span class="number">2</span>]); <span class="comment">//交换当前节点与父节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    temp_pos /= <span class="number">2</span>; <span class="comment">// 更新元素的当前位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="从堆中取出一个最大值-15min"><a href="#从堆中取出一个最大值-15min" class="headerlink" title="从堆中取出一个最大值(15min)"></a>从堆中取出一个最大值(15min)</h3><h4 id="将首部元素取出-0-5min"><a href="#将首部元素取出-0-5min" class="headerlink" title="将首部元素取出(0.5min)"></a>将首部元素取出(0.5min)</h4><p>一般情况下，对我们有用的元素往往是根节点的值（也就是最值），</p><p>因此，我们要取出最大值，首先要将首部元素提出。</p><h4 id="将尾部元素调整至首部-0-5min"><a href="#将尾部元素调整至首部-0-5min" class="headerlink" title="将尾部元素调整至首部(0.5min)"></a>将尾部元素调整至首部(0.5min)</h4><p>首部元素提出后，首部位置将会闲置，为了保证堆仍然是一颗完全二叉树，我们将尾部元素调整至首部</p><h4 id="调整位置以保证堆得性质-14min"><a href="#调整位置以保证堆得性质-14min" class="headerlink" title="调整位置以保证堆得性质(14min)"></a>调整位置以保证堆得性质(14min)</h4><p>同样的，调整之后堆的性质将被打乱，我们需要重新将首部元素调整至合适位置以保证堆的性质</p><p>我们来看一下删除元素的动画</p><p><img src="https://i.loli.net/2020/02/03/hVDxMec8dAUO1Ni.gif" alt="img"></p><p>从动画中我们可以看出，将尾部调整至首部后，首部元素不符合堆的性质，因此不断与比本身大的子节点交换（两个子节点都比本身大时与较大的子节点交换），直至整个堆合法。</p><p>因此，我们可以这样编码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maxn = heap[<span class="number">1</span>]; <span class="comment">// 取出最大值，赋值给maxn</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">heap[<span class="number">1</span>] = heap[len--]; <span class="comment">// 将尾部元素调至首部，并改变堆的大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp_pos = <span class="number">1</span>; <span class="comment">// temp_pos 表示首部元素的当前位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(temp_pos * <span class="number">2</span> &lt;= len) <span class="comment">// 保证当前节点有子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(temp_pos*<span class="number">2</span>+<span class="number">1</span>&lt;=len) <span class="comment">// 如果当前节点有两个子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(heap[temp_pos*<span class="number">2</span>]&gt;=heap[temp_pos*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;heap[temp_pos*<span class="number">2</span>]&gt;=heap[temp_pos])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 如果左子节点是两个子节点中最大的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            swap(heap[temp_pos*<span class="number">2</span>],heap[temp_pos]),temp_pos=temp_pos*<span class="number">2</span>; <span class="comment">// 交换当前节点与左子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (heap[temp_pos*<span class="number">2</span>+<span class="number">1</span>]&gt;=heap[temp_pos*<span class="number">2</span>]&amp;&amp;heap[temp_pos*<span class="number">2</span>+<span class="number">1</span>]&gt;=heap[temp_pos])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 如果右子节点是两个子节点中最大的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            swap(heap[temp_pos*<span class="number">2</span>+<span class="number">1</span>],heap[temp_pos]),temp_pos=temp_pos*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">// 交换当前节点与右子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 除此之外，表明堆已合法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果当前节点有一个子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(heap[temp_pos*<span class="number">2</span>] &gt;= heap[temp_pos]) <span class="comment">//如果子节点大于当前节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            swap(heap[temp_pos*<span class="number">2</span>], heap[temp_pos]),temp_pos=temp_pos*<span class="number">2</span>; <span class="comment">//交换当前节点与子节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 除此之外，表明堆已合法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="线性建堆"><a href="#线性建堆" class="headerlink" title="*线性建堆"></a>*线性建堆</h3><p>至此，堆的基本内容已经给大家讲完了，已经了解时间复杂度的大家可以对堆的建立，删除，插入进行一个简单的分析，其实不难得出，一次插入与删除的复杂度均为O（log n）</p><p>现在，我们有n个元素，如果我们用上面所介绍的方法建堆，将插入n次，每次复杂度为O（log n），总复杂度为O（n*log n）</p><p>事实上，我们有线性时间建堆的方法，即复杂度O（n）的建堆方法</p><p>下面我们通过动画了解一下：</p><p><img src="https://i.loli.net/2020/02/03/6FhJfgVHGcLr8eN.gif" alt="img"></p><p>通过动画我们可以发现，线性建堆的方法，在于一开始即将无序的元素放入堆数组中，</p><p>然后从尾部元素开始，逐个向下调整（过程类似于删除首部元素后的调整），直到首部元素向下调整的过程结束，</p><p>一个符合堆性质的堆数组即建立完成</p><p>下面通过伪代码的方式给大家呈现整个过程的编码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(i * <span class="number">2</span> &gt; len)<span class="keyword">continue</span>; <span class="comment">// 无子节点时直接跳过</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    down(i); <span class="comment">//向下调整</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>其中down()函数不再给出，具体实现请大家参考从堆中取出最大值的操作。</p><p>编码完了，我们还有一个问题没有解决，即：</p><p>为什么这样操作的复杂度是O（n）的？</p><p>关于这个问题感兴趣的同学可以移步<a href="https://blog.csdn.net/anonymalias/article/details/8807895" target="_blank" rel="noopener">线性建堆复杂度证明</a>去了解一下，在这里不做赘述</p><h3 id="使用堆来排序-4-5min"><a href="#使用堆来排序-4-5min" class="headerlink" title="使用堆来排序(4.5min)"></a>使用堆来排序(4.5min)</h3><p>排序过程中，不断从堆顶（即根节点取出元素）即可，伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N], len = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(heap不为空)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    p[++len] = 取出堆顶();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="使用堆来找出一个集合中的最值-0-5min"><a href="#使用堆来找出一个集合中的最值-0-5min" class="headerlink" title="使用堆来找出一个集合中的最值(0.5min)"></a>使用堆来找出一个集合中的最值(0.5min)</h3><p>建好堆后获取根节点的值即可</p><h2 id="哈夫曼树-10min"><a href="#哈夫曼树-10min" class="headerlink" title="哈夫曼树(10min)"></a>哈夫曼树(10min)</h2><h3 id="什么是哈夫曼树-5min"><a href="#什么是哈夫曼树-5min" class="headerlink" title="*什么是哈夫曼树(5min)"></a>*什么是哈夫曼树(5min)</h3><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h3 id="如何构建一颗哈夫曼树-3min"><a href="#如何构建一颗哈夫曼树-3min" class="headerlink" title="*如何构建一颗哈夫曼树(3min)"></a>*如何构建一颗哈夫曼树(3min)</h3><p>可以通过将元素压入小顶堆，每次取出两个元素，权值相加作为两个元素的根节点，同时将根节点压入堆中，直到堆中只剩下一个元素，则哈夫曼树建成</p><h3 id="哈夫曼树有什么用-2min"><a href="#哈夫曼树有什么用-2min" class="headerlink" title="哈夫曼树有什么用(2min)"></a>哈夫曼树有什么用(2min)</h3><p>一道经典的例题：<a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/3172/pid/2127" target="_blank" rel="noopener">SDUTOJ 树-堆结构练习——合并果子之哈夫曼树</a></p><p>解题思路：</p><p>因为哈夫曼树是带权路径长度最短的树，所以本题可以通过构建哈夫曼树的思路解决，即：</p><p>将所有元素压入小顶堆中，每次取出两个元素相加，压入堆，直到堆中只剩一个元素，则该元素为最终答案</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="[https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91](https://baike.baidu.com/item/二叉树)">百度百科：二叉树</a></p><p><a href="[https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91](https://baike.baidu.com/item/满二叉树)">百度百科：满二叉树</a></p><p><a href="[https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91](https://baike.baidu.com/item/完全二叉树)">百度百科：完全二叉树</a></p><p><a href="https://blog.csdn.net/adidas74891496/article/details/82262872" target="_blank" rel="noopener">二叉树,完全二叉树,满二叉树,完美二叉树</a></p><p><a href="https://www.jianshu.com/p/6b526aa481b1" target="_blank" rel="noopener">数据结构：堆（Heap）</a></p><p><a href="https://blog.csdn.net/anonymalias/article/details/8807895" target="_blank" rel="noopener">堆排序中建堆过程的时间复杂度O(n)的证明</a></p><p><a href="[https://baike.baidu.com/item/%E5%A0%86/20606834?fr=aladdin](https://baike.baidu.com/item/堆/20606834?fr=aladdin)">百度百科：堆</a></p><p><a href="[https://baike.baidu.com/item/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/2305769?fr=aladdin](https://baike.baidu.com/item/哈夫曼树/2305769?fr=aladdin)">百度百科：哈夫曼树</a></p><p><a href="https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Contest/contestproblem/cid/3172/pid/2127" target="_blank" rel="noopener">SDUTOJ 树-堆结构练习——合并果子之哈夫曼树</a></p><p><a href="https://visualgo.net/zh/heap?slide=1" target="_blank" rel="noopener">可视化数据结构学习VisuAlgo—二叉堆</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2020/03/07/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2020/03/07/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单调栈的总结</p><a id="more"></a><h2 id="题目传送门：Gym-100971D-Laying-Cables"><a href="#题目传送门：Gym-100971D-Laying-Cables" class="headerlink" title="题目传送门：Gym-100971D Laying Cables"></a>题目传送门：<a href="https://cn.vjudge.net/problem/Gym-100971D" target="_blank" rel="noopener">Gym-100971D Laying Cables</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定你一些城市（直线）的坐标和城市人口大小，要求你输出距离每个城市最近的比他人口大的城市标号，如果没有，则置为-1。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>维护一个单调递减的栈，分别从左到右，在从右到左，分别计算离他最近的点。</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 200005;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">struct Node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ll loc, v, num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;node[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">bool cmp(Node x, Node y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    return x.loc &lt; y.loc;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">ll aim[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    ll n, m, i, j, k, a, b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%lld&quot;, &amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        node[i].loc &#x3D; a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        node[i].v &#x3D; b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        node[i].num &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    sort(node + 1, node + 1 + m, cmp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    stack&lt;Node&gt;s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    vector&lt;Node&gt;lef, rig;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    lef.resize(maxn);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    rig.resize(maxn);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    Node w;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    w.v &#x3D; w.loc &#x3D; 2e10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    w.num &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    s.push(w);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        while(node[i].v &gt; s.top().v)s.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        lef[i] &#x3D; s.top();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        s.push(node[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    while(!s.empty())s.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    node[m + 1].v &#x3D; 2e10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    node[m + 1].loc &#x3D; 2e10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    node[m + 1].num &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    s.push(node[m + 1]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; m; i &gt;&#x3D; 1; i--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        while(node[i].v &gt; s.top().v)s.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        rig[i] &#x3D; s.top();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        s.push(node[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        if(abs(lef[i].loc - node[i].loc) &#x3D;&#x3D; abs(rig[i].loc - node[i].loc))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">            if(lef[i].v &gt; rig[i].v)aim[node[i].num] &#x3D; lef[i].num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            else aim[node[i].num] &#x3D; rig[i].num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        else if(abs(lef[i].loc - node[i].loc) &gt; abs(rig[i].loc - node[i].loc))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">            aim[node[i].num] &#x3D; rig[i].num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        else aim[node[i].num] &#x3D; lef[i].num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    for(i &#x3D; 1; i &lt;&#x3D; m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        if(i !&#x3D; 1)printf(&quot; &quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld&quot;, aim[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈</title>
      <link href="/2020/03/07/%E5%8D%9A%E5%BC%88/"/>
      <url>/2020/03/07/%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>纳什博弈、威佐夫博弈、尼姆博弈的总结</p><a id="more"></a><h2 id="HDU-2516-取石子游戏-斐波那契博弈"><a href="#HDU-2516-取石子游戏-斐波那契博弈" class="headerlink" title="HDU - 2516 取石子游戏 (斐波那契博弈)"></a>HDU - 2516 取石子游戏 (斐波那契博弈)</h2><p>题目链接：<a href="https://cn.vjudge.net/contest/269106#problem/F" target="_blank" rel="noopener">https://cn.vjudge.net/contest/269106#problem/F</a></p><p>题目大意：</p><pre><code>1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出&quot;Second win&quot;.先取者胜输出&quot;First win&quot;.</code></pre><p>解题思路：</p><pre><code>斐波那契博弈，n为斐波那契数时先手必败，用map记录一下斐波那契数即可。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt;mp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ll i, n, a, b, c, len = <span class="number">1e18</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    a = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    b = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    c = a + b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    mp[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(c &lt;= len)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        mp[c] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        a = b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        b = c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        c = a + b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n) != EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(mp[n] == <span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"Second win\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"First win\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="HDU-1527-取石子游戏-威佐夫博弈"><a href="#HDU-1527-取石子游戏-威佐夫博弈" class="headerlink" title="HDU - 1527 取石子游戏 (威佐夫博弈)"></a>HDU - 1527 取石子游戏 (威佐夫博弈)</h2><p>题目链接：<a href="https://cn.vjudge.net/contest/269106#problem/R" target="_blank" rel="noopener">https://cn.vjudge.net/contest/269106#problem/R</a></p><p>题目大意：</p><pre><code>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</code></pre><p>解题思路：</p><pre><code>威佐夫博弈，设（a，b），a &lt; b，若a / b最接近（sqrt（5） - 1）/ 2，则（a，b）为必败态。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">double</span> a, b, c;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;a, &amp;b) != EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a &gt; b)&#123;c = a; a = b; b = c;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        c = (<span class="built_in">sqrt</span>(<span class="number">5</span>) - <span class="number">1.0</span>) / <span class="number">2.0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>((a + <span class="number">1</span>) / b - c) &gt; <span class="built_in">abs</span>(a / b - c) &amp;&amp; <span class="built_in">abs</span>((a - <span class="number">1</span>) / b - c) &gt; <span class="built_in">abs</span>(a / b - c))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="HDU-2176-取-m堆-石子游戏-（尼姆博弈）"><a href="#HDU-2176-取-m堆-石子游戏-（尼姆博弈）" class="headerlink" title="HDU - 2176 取(m堆)石子游戏 （尼姆博弈）"></a>HDU - 2176 取(m堆)石子游戏 （尼姆博弈）</h2><p>题目链接：<a href="https://cn.vjudge.net/contest/269106#problem/Q" target="_blank" rel="noopener">https://cn.vjudge.net/contest/269106#problem/Q</a></p><p>题目大意：</p><pre><code>m堆石子,两人轮流取.只能在1堆中取.取完者胜.先取者负输出No.先取者胜输出Yes,然后输出怎样取子.例如5堆 5,7,8,9,10先取者胜,先取者第1次取时可以从有8个的那一堆取走7个剩下1个,也可以从有9个的中那一堆取走9个剩下0个,也可以从有10个的中那一堆取走7个剩下3个.</code></pre><p>解题思路：</p><pre><code>尼姆博弈，即所有数异或和为0是必败态，否则为必胜态，首先异或一遍，为0输出No，不为零输出Yes，然后遍历石子数，sum ^= a[i]，则sum为除第i堆石子外的异或和，易知sum ^ sum = 0，故当sum &lt; a[i]时，第i堆石子可已走a[i] - sum个石子，使对手必败。</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ll a[<span class="number">200005</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ll n, sum, i, left;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n) != EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            sum ^= a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                sum ^= a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">                left = sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(left &lt;= a[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, a[i], left);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">                sum ^= a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2020/03/07/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/07/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>01背包、完全背包、多重背包的总结</p><a id="more"></a><p><strong>动态规划—简单背包问题</strong></p><p><strong>零   开始之前</strong></p><p><strong>什么是动态规划？</strong></p><p>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法叫做动态规划。</p><p><strong>什么时候能用动态规划？</strong></p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题。</p><p><strong>什么是最优子结构？</strong></p><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p><p><strong>什么是重叠子问题？</strong></p><p>在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。</p><p><strong>动态规划该怎么做？</strong></p><p>1、确定状态</p><p>2、确定状态转移方程</p><p>3、从大到小（记忆化+递归）、从小到大（递推）</p><p><strong>一个简单的例子</strong></p><p>爬楼梯问题</p><p>你正在爬一个有n个台阶的楼梯，每次只能上1个或者2个台阶，那么到达顶端共有多少种不同的方法？</p><ul><li>确定状态 dp[i] 表示有 i 个台阶时的方法数</li><li>确定转移方程 dp[i] = dp[i - 1] + dp[i - 2]。</li><li>递归加记忆化求解：</li></ul><p>#include &lt;bits/stdc++.h&gt; #define ll long long #define N 5123 using namespace std; int dp[N]; int F(int n){    if(n == 1 || n == 2)return n; //边界    if(dp[n] != 0)return dp[n]; //记忆化    return F(n - 1) + F(n - 2); // 转移 } int main(){    int n;    scanf(“%d”, &amp;n);    printf(“%d\n”, F(n)); }</p><ul><li>递推求解：</li></ul><p>#include &lt;bits/stdc++.h&gt; #define ll long long #define N 5123 using namespace std; int dp[N]; int main(){    int n;    scanf(“%d”, &amp;n);    dp[1] = 1; dp[2] = 2; //边界    for(int i = 3; i &lt;= n; i++)        dp[i] = dp[i - 1] + dp[i - 2]; //转移    printf(“%d\n”, dp[n]); }</p><p><strong>什么是背包问题？</strong></p><p>动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。背包问题是动态规划问题的一种类型。</p><p><strong>一   0-1背包问题</strong></p><p><strong>简化的 01-背包 ——装箱问题</strong></p><p>题目链接：（<a href="https://www.acwing.com/problem/content/1026/）" target="_blank" rel="noopener">https://www.acwing.com/problem/content/1026/）</a></p><p>题目大意：有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。</p><p>要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</p><p><strong>确定状态</strong></p><p> dp[i][j] 表示前 i 个物品能否组成体积 j</p><p><strong>确定转移方程</strong></p><p>dp[i][j] = 1 (f[i - 1][j] == 1 || f[i - 1][j - v[i]] == 1)</p><p>dp[i][j] = 0 (else)</p><p><strong>列表验证</strong></p><p>样例输入: 24 6</p><p>​        8 3 12 7 9 7</p><p>样例输出：0</p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5C422eb792ef05482d93c47d674b28239d%5Cclipboard.png" alt="img"></p><p><strong>递推解决</strong></p><p>#include &lt;bits/stdc++.h&gt; #define ll long long #define N 21234 using namespace std; int dp[31][N], a[31]; int main() {    int v, n;    scanf(“%d %d”, &amp;v, &amp;n);    for(int i = 1; i &lt;= n; i++)scanf(“%d”, &amp;a[i]);    dp[0][0] = 1;    int ans = v;    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= v; j++){            if(dp[i - 1][j] == 1)dp[i][j] = 1;            if(j - a[i] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i]] == 1)dp[i][j] = 1;            if(dp[i][j] == 1)ans = min(ans, v - j);        }    }    printf(“%d\n”, ans); }</p><p><strong>01滚动</strong></p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5C33d8d1f153f742b59b21be5968584e1d%5Cclipboard.png" alt="img"></p><p>我们可以看到每一行的结果实际上只与上一行有关，所以就可以01滚动——f[i][0,1] 一行记录前一行的值，另一行记录当前行的值……</p><p><strong>就地滚动</strong></p><p>对于本题更加常用的方法是就地滚动，顾名思义只用一个一维数组了!之前的状态和当前的状态都记在同一个数组里了！</p><p>比如：</p><p>for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= v; j++){            if([j] == 1)dp[j] = 1;            if(j - a[i] &gt;= 0 &amp;&amp; dp[j - a[i]] == 1)dp[j] = 1;        }    }</p><p>但是简单的变成一维以后有可能发出问题</p><p>比如：</p><p>假设第一个物品体积3</p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5C33c5eb6e8db543fcbfa1b455c1535f05%5Cclipboard.png" alt="img"></p><p>一个物品被使用了多次！</p><p>如何解决？</p><p>我们只需改变内层循环的顺序即可！</p><p>for(int i = 1; i &lt;= n; i++){        for(int j = v; j &gt;= 0; j–){            if([j] == 1)dp[j] = 1;            if(j - a[i] &gt;= 0 &amp;&amp; dp[j - a[i]] == 1)dp[j] = 1;        }    }</p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5C1de53b8a016b44ad9cf686b26be7b136%5Cclipboard.png" alt="img"></p><p>问题得到解决！</p><p><strong>0-1背包问题</strong></p><p>题目链接：（<a href="https://www.acwing.com/problem/content/2/）" target="_blank" rel="noopener">https://www.acwing.com/problem/content/2/）</a></p><p>题目大意：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p><p><strong>确定状态</strong></p><p>f[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值</p><p><strong>确定状态转移方程</strong></p><p>两种情况：</p><p>   1.不放当前物品  f[i][j] = f[i-1][j]</p><p>   2.放当前物品     f[i][j] = f[i-1][j-c[i]]+w[i]    </p><p>f[i][j]=max{f[i-1][j],f[i-1][j-c[i]]+w[i]}</p><p><strong>列表验证</strong></p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5C187c9604e2624b69b68201a6e2dc9e46%5Cclipboard.png" alt="img"></p><p><strong>就地滚动</strong></p><p>#include &lt;bits/stdc++.h&gt; using namespace std; #define N 2123 #define ll long long int dp[N], u[N], v[N]; int main() {    ios::sync_with_stdio(0);    int n, w, ans = 0;    cin &gt;&gt; n &gt;&gt; w;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; u[i] &gt;&gt; v[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = w; j &gt;= u[i]; j–){            dp[j] = max(dp[j], dp[j - u[i]] + v[i]);            ans = max(ans, dp[j]);        }    }    printf(“%d\n”, ans);    return 0; }</p><p><strong>二   完全背包问题</strong></p><p>题目链接：（<a href="https://www.acwing.com/problem/content/3/）" target="_blank" rel="noopener">https://www.acwing.com/problem/content/3/）</a></p><p>题目大意：有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci ，价值是 Wi 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。</p><p><strong>回忆 0-1 背包的就地滚动</strong></p><p>回想 0-1 背包就地滚动时错误的代码，之所以错误，是因为每件物品重复使用多次，这恰好符合本题的要求！</p><p><strong>递推求解</strong></p><p>#include &lt;bits/stdc++.h&gt; using namespace std; #define N 2123 #define ll long long int dp[N], u[N], v[N]; int main() {    ios::sync_with_stdio(0);    int n, w, ans = 0;    cin &gt;&gt; n &gt;&gt; w;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; u[i] &gt;&gt; v[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = u[i]; j &lt;= w; j++){            dp[j] = max(dp[j], dp[j - u[i]] + v[i]);            ans = max(ans, dp[j]);        }    }    printf(“%d\n”, ans);    return 0; }</p><p><strong>三   多重背包</strong></p><p>题目链接：（<a href="https://www.acwing.com/problem/content/3/）" target="_blank" rel="noopener">https://www.acwing.com/problem/content/3/）</a></p><p>题目大意：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p><p><strong>问题的转化</strong></p><p>对于本题，我们可以将其拆解为 0-1 背包问题解决</p><p><strong>如何优化</strong></p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5Cd8a1e6cffc60404e8b098f126d6882b1%5Cclipboard.png" alt="img"></p><p><img src="D:%5Cnoteloc%5Cqq48F8B56E1766418F93662E3F74896C51%5Caac0486203ed43aa91e527a73a9e7b2b%5Cclipboard.png" alt="img"></p><p>#include&lt;bits/stdc++.h&gt; using namespace std; int main() {    int N,V,v[1001],w[1001],dp[2001],s[1001]    int a[25000],b[25000];      //2的12次方大于2000，也就是说一个数最多可以拆成12个，故数组容量乘12    cin&gt;&gt;N&gt;&gt;V;    memset(dp,0,sizeof(dp));    for(int i=0;i&lt;N;i++)     cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];    int total=0;    for(int i=0;i&lt;N;i++)    {        for(int j=1;j&lt;s[i];j&lt;&lt;=1)//二进制拆分         {            a[total]=j<em>w[i];//存价值            b[total++]=j</em>v[i];//存容量            s[i]-=j;         }         if(s[i])//当s[i]&gt;0;         {             a[total]=s[i]<em>w[i];             b[total++]=s[i]</em>v[i];         }    }    for(int i=0;i&lt;total;i++)//01背包     for(int j=V;j&gt;=b[i];j–)      dp[j]=max(dp[j],dp[j-b[i]]+a[i]);    cout&lt;&lt;dp[V];    return 0; }</p><p><strong>四   参考资料</strong></p><p>博客：动态规划快速入门：<a href="https://www.jianshu.com/p/4dd4717301dc" target="_blank" rel="noopener">https://www.jianshu.com/p/4dd4717301dc</a></p><p>题目：AcWing题库</p><p>参考课件：背包九讲（崔添翼）</p><p>​    nwpu2014暑假集训：动态规划2——简单背包问题（dsy）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
