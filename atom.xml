<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QSH&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://miracle-qsh.github.io/"/>
  <updated>2020-04-27T22:17:54.407Z</updated>
  <id>http://miracle-qsh.github.io/</id>
  
  <author>
    <name>QSH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春招面试总结</title>
    <link href="http://miracle-qsh.github.io/2020/04/21/%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://miracle-qsh.github.io/2020/04/21/%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-21T10:02:43.822Z</published>
    <updated>2020-04-27T22:17:54.407Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>总结从二月份以来所经历的面试情况</p><a id="more"></a><h1 id="春招面试情况"><a href="#春招面试情况" class="headerlink" title="春招面试情况"></a>春招面试情况</h1><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><ul><li><p>Rust/C++研发实习：二面技术面试挂</p></li><li><p>基础架构研发实习：三面技术面试+HR面，已offer</p></li></ul><h2 id="阿里巴巴"><a href="#阿里巴巴" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h2><ul><li>支付宝JAVA研发实习：笔试+四面技术面试+HR面试，已offer</li></ul><h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><ul><li><p>音乐人JAVA实习：二面技术面试挂</p></li><li><p>微信技术架构实习：两面技术面试+HR面试，已offer</p></li></ul><h2 id="美团点评"><a href="#美团点评" class="headerlink" title="美团点评"></a>美团点评</h2><ul><li>到店餐饮JAVA实习：笔试+两面技术面试+HR面试，已完成</li></ul><h2 id="三七互娱"><a href="#三七互娱" class="headerlink" title="三七互娱"></a>三七互娱</h2><ul><li>Web后端实习：笔试+两面技术面试+HR面试，已完成</li></ul><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><ul><li>C++/PHP研发实习：笔试+三面技术面试，等待HR面试中</li></ul><h2 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h2><ul><li>基础架构实习：笔试+两面技术面试，已挂</li></ul><h2 id="吉比特"><a href="#吉比特" class="headerlink" title="吉比特"></a>吉比特</h2><ul><li>游戏研发实习：笔试+一面面试，已挂</li></ul><h2 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h2><ul><li>游戏研发实习：笔试已通过，已放弃</li></ul><h1 id="面经整理"><a href="#面经整理" class="headerlink" title="面经整理"></a>面经整理</h1><h2 id="字节跳动-1"><a href="#字节跳动-1" class="headerlink" title="字节跳动"></a>字节跳动</h2><h3 id="Rust-C-研发实习"><a href="#Rust-C-研发实习" class="headerlink" title="Rust/C++研发实习"></a>Rust/C++研发实习</h3><p><strong>一面</strong></p><ol><li>从输入一个url到浏览器响应的过程中经历的了什么？</li><li>说一下TCP三次握手的过程？</li><li>TCP的拥塞控制有哪些机制？</li><li>说一下HTTP握手的过程？</li><li>说一下HTTP1.0和HTTP1.1的区别？</li><li>说一下HTTP和HTTPS的区别？</li><li>说一下短连接和长连接的区别？</li><li>说一下什么是HTTP流水线机制？</li><li>进程和线程的区别？</li><li>进程间通信的方式有哪些？</li><li>线程间通信的方式有哪些？</li><li>说一下悲观锁和乐观锁的区别？</li><li>算法题：最大字段和问题？</li><li>算法题：每一次可以修改某个数的一位，求把素数A修改到素数B的方案数？</li></ol><p><strong>二面</strong></p><ol><li>算法题：K个有序数组归并？</li><li>算法题：将一个整数划分为不同数字之和的方案数？</li><li>讲一下智能指针？</li><li>Extern C的作用？</li><li>Std：：move的作用？</li><li>数据库索引的作用？</li><li>讲一下联合索引的原理？</li><li>说一下linux的innode机制？</li><li>说一下页溢出和段溢出？</li><li>说一下TCP和UDP的区别？</li><li>说一下TCP的拥塞控制机制？</li><li>相邻两次进入拥塞避免状态的时间之差是多少？</li><li>cookie和session的区别？</li></ol><h3 id="基础架构实习"><a href="#基础架构实习" class="headerlink" title="基础架构实习"></a>基础架构实习</h3><p><strong>一面</strong></p><ol><li>说一下TCP三次握手状态机图？</li><li>说一下SYN攻击？</li><li>说一下四次挥手状态机图？</li><li>说一下TIME_WAIT的作用？</li><li>如果没有TIME_WAIT会发生什么？</li><li>发送方不停恶意发起TCP连接请求该怎么解决？</li><li>说一下程序运行过程的状态机图？</li><li>说一下进程间通信方式？</li><li>什么是孤儿进程？</li><li>什么是僵尸进程？</li><li>如何解决僵尸进程？</li><li>linux如何查看内存使用情况</li><li>算法题：一个先增后降的数组排序</li></ol><p><strong>二面</strong></p><ol><li>说一下网络分层</li><li>有TCP了为什么还要HTTP</li><li>为什么要分层</li><li>HTTP相比于TCP有什么不同</li><li>C++unorder_map底层实现是什么</li><li>哈希表如何解决冲突</li><li>冲突太多怎么解决</li><li>哈希表扩容为什么要倍增</li><li>多线程有哪些实现方式</li><li>Atomic的作用</li><li>Atomic的底层实现</li><li>说一下CAS的实现</li><li>算法题：树的直径</li></ol><p><strong>三面</strong></p><ol><li>算法题：单链表快排</li><li>TOP K问题</li><li>多线程实现同步的技术了解哪些</li><li>进程通信的技术有哪些</li><li>说一下TCP三次握手、四次挥手</li></ol><h2 id="阿里巴巴-1"><a href="#阿里巴巴-1" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h2><h3 id="支付宝JAVA研发实习"><a href="#支付宝JAVA研发实习" class="headerlink" title="支付宝JAVA研发实习"></a>支付宝JAVA研发实习</h3><p><strong>一面</strong></p><ol><li>链表判断有环</li><li>链表判断有环并返回环的入口</li><li>链表判断有环并返回环的入口，不允许开额外空间</li><li>两个链表判断相交，返回交点</li><li>两个链表判断相交，返回交点，不允许开额外空间</li><li>两个栈模拟队列</li><li>两个栈模拟队列，实现最小栈</li><li>两个队列模拟一个栈</li><li>网络分层，每层作用</li><li>三次握手</li><li>四次挥手</li><li>为什么要三次握手，两次可不可以</li><li>为什么要四次挥手，三次可不可以</li><li>如果两次握手会发生什么</li><li>TCP拥塞控制机制</li><li>详细解释慢开始、拥塞避免、快重传、快恢复</li><li>滑动窗口的作用</li><li>进程和线程的区别</li><li>线程和协程的区别</li><li>进程间通信的方法</li><li>socket通信的过程</li><li>银行家算法</li><li>页面置换算法有哪些，详细说说</li><li>数据库事务的特性</li><li>如何保证原子性</li><li>你了解哪些锁</li><li>事务的隔离级别</li><li>不可重复读解决什么问题</li><li>不可重复读能解决幻读吗</li><li>什么是幻读</li><li>设计一个微信红包算法</li></ol><p><strong>二面</strong></p><ol><li>实现一个IDE</li><li>IDE如何实现代码格式规范化</li><li>实现一个支付通信接口</li><li>如果公钥更换了怎么办</li><li>如果频繁更换怎么办</li><li>如果一个用户恶意访问接口怎么办</li><li>接口功能不能停的情况下，新旧公钥如何过渡</li><li>实现一个微博推送功能</li><li>如果博主反复更新动态怎么办</li><li>实现一个搜索引擎</li></ol><p><strong>三面</strong></p><ol><li>聊价值观、方法论</li></ol><p><strong>四面</strong></p><ol><li>谈一下对面向对象程序设计的看法</li><li>了解过哪些设计模式</li><li>说一下对网络分层的看法</li><li>为什么要分层</li><li>有IP协议了，为什么还需要TCP/UDP协议</li><li>对加密算法了解哪些</li><li>了解过中间件吗</li><li>看过哪些开源项目的源码</li></ol><h2 id="腾讯-1"><a href="#腾讯-1" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="音乐人JAVA实习"><a href="#音乐人JAVA实习" class="headerlink" title="音乐人JAVA实习"></a>音乐人JAVA实习</h3><p><strong>一面</strong></p><ol><li>介绍一下虚拟内存</li><li>介绍一下银行家算法</li><li>进程间通信方式</li><li>线程间通信方式</li><li>说一下网络分层</li><li>TCP三次握手</li><li>滑动窗口的作用</li><li>栈和队列的特点及应用场景</li><li>什么是幻读</li><li>怎么解决幻读</li><li>介绍一下死锁的产生条件</li><li>有哪些解决死锁的办法</li></ol><p><strong>二面</strong></p><ol><li>介绍一下进程间通信方式</li><li>TCP三次握手的过程</li><li>为什么要三次握手</li><li>TCP四次挥手的过程</li><li>进程和线程的区别</li><li>谈谈对ioc容器的看法</li><li>数据库事务的隔离级别</li></ol><h3 id="微信技术架构实习"><a href="#微信技术架构实习" class="headerlink" title="微信技术架构实习"></a>微信技术架构实习</h3><p><strong>一面</strong></p><ol><li>算法题：实现一个memcopy函数</li><li>算法题：归并两个有序链表</li><li>算法题：实现一个抽奖函数（rand6实现均等概率的rand30）</li><li>场景题：一百万个数取前100大的数字</li><li>场景题：200G的文本文件，每个字符串不超过16字节，100M内存，取前100个的高频字符串</li></ol><p><strong>二面</strong></p><ol><li>算法题：链表去重</li><li>算法题：找出合法的IP地址</li><li>算法题：判断两个多项式是否等价</li><li>算法题：按出现频率排序</li><li>算法题：多个活动给出开始时间和结束时间，求最少需要多少会议室才能全部安排</li><li>场景题：设计一个服务器</li></ol><h2 id="美团点评-1"><a href="#美团点评-1" class="headerlink" title="美团点评"></a>美团点评</h2><h3 id="到店餐饮JAVA实习"><a href="#到店餐饮JAVA实习" class="headerlink" title="到店餐饮JAVA实习"></a>到店餐饮JAVA实习</h3><p><strong>一面</strong></p><ol><li>Static关键字的作用</li><li>Const的作用</li><li>虚函数的具体实现</li><li>纯虚函数和虚函数的区别</li><li>Static变量的初始化时间</li><li>介绍一下智能指针</li><li>TCP三次握手</li><li>TCP四次挥手</li><li>进程和线程的区别</li><li>Linux命令了解哪些</li><li>智力题：蚂蚁爬杆问题</li></ol><p><strong>二面</strong></p><ol><li>JAVA和C++的区别</li><li>谈谈对面向对象的看法</li><li>Hash_map的实现原理</li><li>哈希表处理冲突的方法</li><li>哈希表的扩容为什么要倍增</li><li>哈希表的平均插入复杂度是多少，怎么证明</li></ol><h2 id="三七互娱-1"><a href="#三七互娱-1" class="headerlink" title="三七互娱"></a>三七互娱</h2><h3 id="Web后端实习"><a href="#Web后端实习" class="headerlink" title="Web后端实习"></a>Web后端实习</h3><p><strong>一面</strong></p><ol><li>面向对象的特点</li><li>谈谈你理解的多态</li><li>进程线程的区别</li><li>进程间通信的方式有哪些</li><li>介绍一下虚拟内存</li><li>数据库事务的隔离级别</li><li>不可重复读解决什么问题</li><li>什么是脏读</li><li>什么是幻读</li><li>单例模式的懒汉式如何实现</li><li>TCP三次握手过程</li><li>TCP四次挥手过程</li></ol><p><strong>二面</strong></p><ol><li>聊价值观、谈理想</li></ol><h2 id="百度-1"><a href="#百度-1" class="headerlink" title="百度"></a>百度</h2><h3 id="C-PHP研发实习"><a href="#C-PHP研发实习" class="headerlink" title="C++/PHP研发实习"></a>C++/PHP研发实习</h3><p><strong>一面</strong></p><ol><li>Const关键字的作用</li><li>介绍一下智能指针</li><li>循环引用如何解决</li><li>说一下虚函数的实现机制</li><li>B+树和红黑树的区别</li><li>为什么使用B+树作为数据库索引的数据结构</li><li>AVL树和红黑树的区别</li><li>说一下AVL树具体如何旋转</li><li>算法题：链表判环</li><li>算法题：链表判环并返回环开始的位置</li></ol><p><strong>二面</strong></p><ol><li>算法题：一个颜色数组，求包含所有颜色的最小连续字段长度</li><li>算法题：一个环形颜色数组，求包含所有颜色的最小连续字段长度</li><li>场景题：TOPK问题</li><li>介绍一下KMP算法</li><li>介绍一下AC自动机算法</li></ol><p><strong>三面</strong></p><ol><li>纳什博弈</li><li>概率题：不均等概率硬币实现均等概率</li><li>如果让你设计百度搜索的广告推送，你会怎样设计</li></ol><h2 id="快手-1"><a href="#快手-1" class="headerlink" title="快手"></a>快手</h2><h3 id="基础架构实习-1"><a href="#基础架构实习-1" class="headerlink" title="基础架构实习"></a>基础架构实习</h3><p><strong>一面</strong></p><ol><li>Static作用</li><li>内存分区</li><li>编译过程</li><li>实现一个分享式智能指针</li><li>算法题：链表分组反转</li><li>算法题：活动安排</li></ol><p><strong>二面</strong></p><ol><li>算法题：实现O（N）排序</li><li>编译过程</li><li>实现代码文件去除注释功能</li><li>TOPK问题</li><li>文件字符串去重</li></ol><h2 id="吉比特-1"><a href="#吉比特-1" class="headerlink" title="吉比特"></a>吉比特</h2><h3 id="游戏研发实习"><a href="#游戏研发实习" class="headerlink" title="游戏研发实习"></a>游戏研发实习</h3><p><strong>一面</strong></p><ol><li>介绍一下智能指针</li><li>引用和指针的区别</li><li>介绍一下右值引用</li><li>最小生成树算法</li><li>并查集</li><li>智力题：元旦不是星期二问题</li><li>进程与线程的区别</li><li>进程通信方式</li><li>TCP三次握手过程</li><li>TCP四次挥手过程</li></ol><h1 id="复习资料整理"><a href="#复习资料整理" class="headerlink" title="复习资料整理"></a>复习资料整理</h1><ol><li>计算机基础+算法：<a href="https://cyc2018.github.io/CS-Notes/#/README" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/README</a></li><li>计算机基础：<a href="https://github.com/wolverinn/Waking-Up" target="_blank" rel="noopener">https://github.com/wolverinn/Waking-Up</a></li><li>后端面试重点难点：<a href="https://xiaozhuanlan.com/topic/2167809435" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/2167809435</a></li><li>个人博客：<a href="https://miracle-qsh.github.io/">https://miracle-qsh.github.io/</a></li></ol><h1 id="简历制作"><a href="#简历制作" class="headerlink" title="简历制作"></a>简历制作</h1><ol><li>超级简历：<a href="https://www.wondercv.com/cvs" target="_blank" rel="noopener">https://www.wondercv.com/cvs</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结从二月份以来所经历的面试情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="春招" scheme="http://miracle-qsh.github.io/categories/%E6%98%A5%E6%8B%9B/"/>
    
    
      <category term="春招" scheme="http://miracle-qsh.github.io/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>Socket</title>
    <link href="http://miracle-qsh.github.io/2020/03/09/socket/"/>
    <id>http://miracle-qsh.github.io/2020/03/09/socket/</id>
    <published>2020-03-09T02:13:38.381Z</published>
    <updated>2020-04-08T00:48:54.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Socket的总结，结合常见问题</p><a id="more"></a><h4 id="介绍一下I-O模型"><a href="#介绍一下I-O模型" class="headerlink" title="介绍一下I/O模型"></a>介绍一下I/O模型</h4><p>一个输入操作，包含：等待数据准备好，从内核向进程复制数据两个阶段</p><h4 id="五大I-O模型"><a href="#五大I-O模型" class="headerlink" title="五大I/O模型"></a>五大I/O模型</h4><p>阻塞时I/O、非阻塞式I/O、I/O复用、信号驱动式I/O、异步I/O</p><h4 id="介绍一下阻塞式I-O"><a href="#介绍一下阻塞式I-O" class="headerlink" title="介绍一下阻塞式I/O"></a>介绍一下阻塞式I/O</h4><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回</p><h4 id="介绍一下非阻塞式I-O"><a href="#介绍一下非阻塞式I-O" class="headerlink" title="介绍一下非阻塞式I/O"></a>介绍一下非阻塞式I/O</h4><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）</p><h4 id="阻塞式I-O与非阻塞式I-O的区别"><a href="#阻塞式I-O与非阻塞式I-O的区别" class="headerlink" title="阻塞式I/O与非阻塞式I/O的区别"></a>阻塞式I/O与非阻塞式I/O的区别</h4><p>阻塞式I/O发起后进程会被阻塞，非阻塞式I/O不会，但阻塞式I/O没有那么多的系统调用，CPU利用率高</p><h4 id="介绍一下I-O复用"><a href="#介绍一下I-O复用" class="headerlink" title="介绍一下I/O复用"></a>介绍一下I/O复用</h4><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中，它可以让单个进程具有处理多个 I/O 事件的能力</p><h4 id="介绍一下信号驱动I-O"><a href="#介绍一下信号驱动I-O" class="headerlink" title="介绍一下信号驱动I/O"></a>介绍一下信号驱动I/O</h4><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中</p><h4 id="介绍一下异步I-O"><a href="#介绍一下异步I-O" class="headerlink" title="介绍一下异步I/O"></a>介绍一下异步I/O</h4><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号</p><h4 id="异步I-O与信号驱动I-O的区别"><a href="#异步I-O与信号驱动I-O的区别" class="headerlink" title="异步I/O与信号驱动I/O的区别"></a>异步I/O与信号驱动I/O的区别</h4><p>异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O</p><h4 id="介绍一下select"><a href="#介绍一下select" class="headerlink" title="介绍一下select"></a>介绍一下select</h4><p>使用fd_set实现，大小为FD_SETSIZE，三种描述符类型readset、writeset、exceptset</p><p>timeout为超时参数</p><p>成功返回大于0，出错为-1，超时为0</p><h4 id="介绍一下poll"><a href="#介绍一下poll" class="headerlink" title="介绍一下poll"></a>介绍一下poll</h4><p>与select类似，描述符为pollfd类型数组</p><h4 id="select与poll的比较"><a href="#select与poll的比较" class="headerlink" title="select与poll的比较"></a>select与poll的比较</h4><p>select会修改描述符，poll不会</p><p>select有数量限制，poll没有</p><p>poll对描述符的重复利用比select高</p><p>select可移植性比poll高</p><h4 id="介绍一下epoll"><a href="#介绍一下epoll" class="headerlink" title="介绍一下epoll"></a>介绍一下epoll</h4><p>epoll_creat()创建句柄，声明监听的数目+1</p><p>epoll_ctl()用于添加/删除/修改描述符（维护在红黑树上）</p><p>epoll_wait()轮询I/O事件的发生</p><p>epoll不会产生select/poll的监听某描述符时另一线程关闭该描述符造成的不确定结果</p><h4 id="介绍一下epoll的两种工作模式"><a href="#介绍一下epoll的两种工作模式" class="headerlink" title="介绍一下epoll的两种工作模式"></a>介绍一下epoll的两种工作模式</h4><p>LT模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking</p><p>ET模式：和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Socket的总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://miracle-qsh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://miracle-qsh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL</title>
    <link href="http://miracle-qsh.github.io/2020/03/09/SQL/"/>
    <id>http://miracle-qsh.github.io/2020/03/09/SQL/</id>
    <published>2020-03-09T02:10:41.183Z</published>
    <updated>2020-04-08T00:49:05.645Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SQL的总结，结合常见问题</p><a id="more"></a><h4 id="数据库的创建与使用"><a href="#数据库的创建与使用" class="headerlink" title="数据库的创建与使用"></a>数据库的创建与使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mytable(</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    col1 <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">1</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    col2 <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="literal">null</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    col3 <span class="built_in">date</span> <span class="literal">null</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">);</span></pre></td></tr></table></figure><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">add</span> <span class="keyword">col</span> <span class="built_in">char</span>(<span class="number">20</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> <span class="keyword">col</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> mytable;</span></pre></td></tr></table></figure><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mytable(cols, col2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">values</span>(val1, val2);</span></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mytable1(col1, col2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1, col2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable2;</span></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> newtable <span class="keyword">as</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable;</span></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">col</span> = val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> mytable;</span></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><h5 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> col1, col2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable;</span></pre></td></tr></table></figure><h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">limit</span> <span class="number">5</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">limit</span> <span class="number">0</span>, <span class="number">5</span>;</span></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">limit</span> <span class="number">2</span>, <span class="number">3</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3-5行</span></span></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ul><li>ASC升序</li><li>DESC降序</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> col1 <span class="keyword">desc</span>, col2 <span class="keyword">asc</span>;</span></pre></td></tr></table></figure><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">col</span> <span class="keyword">is</span> <span class="literal">null</span>;</span></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;&gt; !=</td><td>不等于</td></tr><tr><td>&lt;= !&gt;</td><td>小于等于</td></tr><tr><td>&gt;= !&lt;</td><td>大于等于</td></tr><tr><td>BETWEEN</td><td>在两个值之间</td></tr><tr><td>IS NULL</td><td>为 NULL 值</td></tr></tbody></table><p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><strong>NOT</strong> 操作符用于否定一个条件</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><ul><li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li><li><strong>_</strong> 匹配 ==1 个任意字符；</li><li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">col</span> <span class="keyword">like</span> <span class="string">'[^AB]%'</span>;</span></pre></td></tr></table></figure><h4 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1 * col2 <span class="keyword">as</span> <span class="keyword">alias</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable;</span></pre></td></tr></table></figure><p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mytable;Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的平均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列值之和</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mytable;</span></pre></td></tr></table></figure><h5 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>LEFT()</td><td>左边的字符</td></tr><tr><td>RIGHT()</td><td>右边的字符</td></tr><tr><td>LOWER()</td><td>转换为小写字符</td></tr><tr><td>UPPER()</td><td>转换为大写字符</td></tr><tr><td>LTRIM()</td><td>去除左边的空格</td></tr><tr><td>RTRIM()</td><td>去除右边的空格</td></tr><tr><td>LENGTH()</td><td>长度</td></tr><tr><td>SOUNDEX()</td><td>转换为语音值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="keyword">SOUNDEX</span>(col1) = <span class="keyword">SOUNDEX</span>(<span class="string">'apple'</span>)Copy <span class="keyword">to</span> clipboardErrorCopied</span></pre></td></tr></table></figure><h5 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h5><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td>ADDDATE()</td><td>增加一个日期（天、周等）</td></tr><tr><td>ADDTIME()</td><td>增加一个时间（时、分等）</td></tr><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>DATE()</td><td>返回日期时间的日期部分</td></tr><tr><td>DATEDIFF()</td><td>计算两个日期之差</td></tr><tr><td>DATE_ADD()</td><td>高度灵活的日期运算函数</td></tr><tr><td>DATE_FORMAT()</td><td>返回一个格式化的日期或时间串</td></tr><tr><td>DAY()</td><td>返回一个日期的天数部分</td></tr><tr><td>DAYOFWEEK()</td><td>对于一个日期，返回对应的星期几</td></tr><tr><td>HOUR()</td><td>返回一个时间的小时部分</td></tr><tr><td>MINUTE()</td><td>返回一个时间的分钟部分</td></tr><tr><td>MONTH()</td><td>返回一个日期的月份部分</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>SECOND()</td><td>返回一个时间的秒部分</td></tr><tr><td>TIME()</td><td>返回一个日期时间的时间部分</td></tr><tr><td>YEAR()</td><td>返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT NOW();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2018-4-14 20:25:11</span></span></pre></td></tr></table></figure><h5 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h5><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">col</span>, <span class="keyword">count</span>(*) <span class="keyword">as</span> <span class="keyword">num</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">col</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">num</span>;</span></pre></td></tr></table></figure><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">col</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="keyword">num</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> <span class="keyword">col</span> &gt; <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">col</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">HAVING</span> <span class="keyword">num</span> &gt;= <span class="number">2</span>;</span></pre></td></tr></table></figure><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> col1 <span class="keyword">in</span> (<span class="keyword">select</span> col2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">from</span> mytable2);</span></pre></td></tr></table></figure><h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.value, b.value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tablea <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> tableb <span class="keyword">as</span> b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> a.key = b.key;</span></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.value, b.value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tablea <span class="keyword">as</span> a, tableb <span class="keyword">as</span> b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> a.key = b.key;</span></pre></td></tr></table></figure><h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e1.name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> employee <span class="keyword">as</span> e1 <span class="keyword">inner</span> <span class="keyword">join</span> employee <span class="keyword">as</span> e2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span> e1.val = e2.val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> e2.name = <span class="string">"jim"</span>;</span></pre></td></tr></table></figure><h5 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h5><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.val, b.val</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tablea <span class="keyword">as</span> a <span class="keyword">natural</span> <span class="keyword">join</span> tableb <span class="keyword">as</span> b;</span></pre></td></tr></table></figure><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span></pre></td></tr></table></figure><p>customers 表：</p><table><thead><tr><th>cust_id</th><th>cust_name</th></tr></thead><tbody><tr><td>1</td><td>a</td></tr><tr><td>2</td><td>b</td></tr><tr><td>3</td><td>c</td></tr></tbody></table><p>orders 表：</p><table><thead><tr><th>order_id</th><th>cust_id</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>3</td></tr></tbody></table><p>结果：</p><table><thead><tr><th>cust_id</th><th>cust_name</th><th>order_id</th></tr></thead><tbody><tr><td>1</td><td>a</td><td>1</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>c</td><td>3</td></tr><tr><td>3</td><td>c</td><td>4</td></tr><tr><td>2</td><td>b</td><td>Null</td></tr></tbody></table><h4 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">col</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">col</span> = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">col</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mytable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> <span class="keyword">col</span> = <span class="number">2</span>;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SQL的总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/MySQL/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/MySQL/</id>
    <published>2020-03-08T13:32:12.168Z</published>
    <updated>2020-04-08T00:48:49.337Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MySQL的总结，结合常见问题</p><a id="more"></a><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-Tree原理"><a href="#B-Tree原理" class="headerlink" title="B+ Tree原理"></a>B+ Tree原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>B Tree是平衡树，是一颗查找树，所有叶子节点位于同一层</p><p>B+ Tree基于B Tree和叶子节点顺序访问指针实现，具有平衡性，通过顺序访问指针提高区间查询性能</p><p>B+ Tree中，一个节点中的key从左到右非递减排列</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归的在指针所指向的节点进行查找，知道找到叶子节点，然后再叶子节点上进行二分查找，找到key对应的data</p><p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作后，需要对树进行一个分裂、合并、旋转等操作维护平衡性</p><h4 id="与红黑树的比较"><a href="#与红黑树的比较" class="headerlink" title="与红黑树的比较"></a>与红黑树的比较</h4><p>红黑树等平衡性也可以用来实现索引，但文件系统和数据库普遍采用B+树作为索引结构，原因有二：</p><ul><li>更少的查找次数</li><li>利用磁盘预读特性</li></ul><h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>索引在存储引擎层实现</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h4><p>大多数MySQL存储引擎默认索引类型</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" alt="img"></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" alt="img"></p><h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h4 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span></pre></td></tr></table></figure><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_ <span class="keyword">id</span> <span class="keyword">FROM</span> sakila.film_actor</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">AND</span> film_id = <span class="number">1</span>;</span></pre></td></tr></table></figure><h4 id="索引列顺序"><a href="#索引列顺序" class="headerlink" title="索引列顺序"></a>索引列顺序</h4><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">COUNT</span>(*)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> payment;Copy to clipboardErrorCopied</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">customer_id_selectivity: 0.0373</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">               COUNT(*): 16049</span></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li></ul><h3 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h3><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h2 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h2><h3 id="使用Explain分析"><a href="#使用Explain分析" class="headerlink" title="使用Explain分析"></a>使用Explain分析</h3><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h4 id="减少服务端扫描的行数"><a href="#减少服务端扫描的行数" class="headerlink" title="减少服务端扫描的行数"></a>减少服务端扫描的行数</h4><p>使用索引</p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><h4 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h4><h4 id="分解大连接查询"><a href="#分解大连接查询" class="headerlink" title="分解大连接查询"></a>分解大连接查询</h4><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>整型、浮点数、字符串、时间和日期（datatime日期、timestamp格里尼治秒数）</p><h2 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL的总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://miracle-qsh.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>C++总结(3)</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/C++3/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/C++3/</id>
    <published>2020-03-08T11:47:00.048Z</published>
    <updated>2020-04-08T00:48:31.407Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++第三次总结，结合常见问题</p><a id="more"></a><h2 id="sizeof和strlen区别"><a href="#sizeof和strlen区别" class="headerlink" title="sizeof和strlen区别"></a>sizeof和strlen区别</h2><ul><li>strlen计算字符串的具体长度，不包括字符串结束符，返回字符个数</li><li>sizeof计算什么后站的内存数（字节大小），不是实际长度</li><li>strlen是一个函数，sizeof是一个取字节的运算符</li><li>sizeof的返回值是字符个数*字符所占的字节数，字符实际长度小于定义的长度</li><li>sizeof可以用类型做参数，strlen只能用char*做参数，且只能用‘\0’结尾</li><li>数组做sizeof的参数不退化，传递给strlen就退化成指针</li></ul><h2 id="简述strcpy、sprintf、memcpy区别"><a href="#简述strcpy、sprintf、memcpy区别" class="headerlink" title="简述strcpy、sprintf、memcpy区别"></a>简述strcpy、sprintf、memcpy区别</h2><ul><li><p>操作对象不同</p><p>strcpy的两个操作对象均为字符串</p><p>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p><p>memcpy的两个操作对象就是两个任意可操作的内存地址</p></li><li><p>执行效率不同</p><p>memcpy最高，strcpy次之，sprintf最差</p></li><li><p>实现功能不同</p><p>strcpy主要实现字符串变量间的拷贝</p><p>sprintf主要实现其他数据类型到字符串的转化</p><p>memcpy主要是内存块间的拷贝</p></li></ul><h2 id="编码实现某变量某位清零"><a href="#编码实现某变量某位清零" class="headerlink" title="编码实现某变量某位清零"></a>编码实现某变量某位清零</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1 &lt;&lt; 3)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    a |= BIT3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    a &amp;= ~BIT3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="将引用作为函数参数有哪些特点"><a href="#将引用作为函数参数有哪些特点" class="headerlink" title="将引用作为函数参数有哪些特点"></a>将引用作为函数参数有哪些特点</h2><ul><li>传递引用给函数与传递指针给函数效果是一样的</li><li>使用引用做参数，并没有在内存中产生实参副本，是直接对实参操作；而一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。</li><li>使用指针作为函数参数虽然也能达到一样的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用*变量名的形式进行运算；另外，在主调函数处必须使用变量的地址做实参</li></ul><h2 id="分别写出bool，int，flost，指针类型的变量a与零的比较"><a href="#分别写出bool，int，flost，指针类型的变量a与零的比较" class="headerlink" title="分别写出bool，int，flost，指针类型的变量a与零的比较"></a>分别写出bool，int，flost，指针类型的变量a与零的比较</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>: <span class="keyword">if</span>(!a) <span class="function"><span class="keyword">or</span> <span class="title">if</span><span class="params">(a)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">int: if(a == 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>: <span class="keyword">const</span> EXPRESSION EXP = <span class="number">0.00001</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt; EXP &amp;&amp; a &gt; -EXP)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">pointer: <span class="keyword">if</span>(a != <span class="literal">NULL</span>) <span class="keyword">or</span> <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span></pre></td></tr></table></figure><h2 id="局部变量全局变量的问题"><a href="#局部变量全局变量的问题" class="headerlink" title="局部变量全局变量的问题"></a>局部变量全局变量的问题</h2><ul><li>局部会屏蔽全局。要用全局变量，需要使用“：：”，局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量</li><li>如何引用一个已经定义过的全局变量，可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引入某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用，假定你犯了同样错误，会在链接期间报错</li><li>全局变量定义在不同C文件中，需要以static形式来声明</li></ul><h2 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h2><ul><li>数组在内存中时连续存放的，开辟一块连续的内存空间；数组作所占的空间：sizeof（数组名）；数组大小：sizeof（数组名）/sizeof（元素类型）</li><li>用运算符sizeof可以计算数组大小，sizeof（指针）得到的是指针变量的大小，而不是指向内存的大小</li><li>向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针</li><li>数组原地址固定，指针不固定</li></ul><h2 id="C-如何组织一个类被实例化？一般在什么时候将构造函数声明为private？"><a href="#C-如何组织一个类被实例化？一般在什么时候将构造函数声明为private？" class="headerlink" title="C++如何组织一个类被实例化？一般在什么时候将构造函数声明为private？"></a>C++如何组织一个类被实例化？一般在什么时候将构造函数声明为private？</h2><ul><li>将类定义为抽象基类或者将构造函数声明为private</li><li>不允许类外部创建类对象，只能在类内部创建对象</li></ul><h2 id="如何禁止自动生成拷贝构造函数"><a href="#如何禁止自动生成拷贝构造函数" class="headerlink" title="如何禁止自动生成拷贝构造函数"></a>如何禁止自动生成拷贝构造函数</h2><ul><li>为了组织编译器默认生成拷贝构造函数和拷贝赋值函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要将他们设置为private，防止被调用</li><li>类的成员函数和friend函数还是可以调用private函数，如果这个private函数只声明不定义，会产生一个连接错误</li><li>针对上述两种情况，我们可以定义一个base类，在base类中将拷贝构造函数和拷贝赋值函数设置为private，那么派生类中编译器将不会自动生成这两个函数，且由于base类中该函数是私有的，因此，派生类将阻止编译器执行相关操作</li></ul><h2 id="assert与NDEBUGE"><a href="#assert与NDEBUGE" class="headerlink" title="assert与NDEBUGE"></a>assert与NDEBUGE</h2><ul><li><p>assert宏的原型定义在&lt;assert.h&gt;，其作用是如果它的条件返回错误，则终止程序执行，原型定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assert</span><span class="params">(<span class="keyword">int</span> expression)</span></span>;</span></pre></td></tr></table></figure><p>assert的作用是先计算表达式expression，如果其值为假，那么它先向stderr打印一条出错信息，然后通过调用abort来终止程序运行</p></li><li><p>NDBEBUGE宏是Standard C中定义的宏，专门用来控制assert()的行为。如果定义了这个宏，则assert不会起作用</p></li></ul><h2 id="main函数有没有返回值"><a href="#main函数有没有返回值" class="headerlink" title="main函数有没有返回值"></a>main函数有没有返回值</h2><ul><li>程序运行过程入口点，main函数，返回值必须是int，这样返回值才能传递给程序激活者表示程序正常退出。main(int args, int char **args) 参数传递，参数处理一般会调用getopt()函数处理</li></ul><h2 id="写一个比较大小的模板函数"><a href="#写一个比较大小的模板函数" class="headerlink" title="写一个比较大小的模板函数"></a>写一个比较大小的模板函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ioatream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1, <span class="keyword">typename</span> type2&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function">type1 <span class="title">Max</span><span class="params">(type1 a, type2 b)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="C-怎么实现一个函数先于main函数运行"><a href="#C-怎么实现一个函数先于main函数运行" class="headerlink" title="C++怎么实现一个函数先于main函数运行"></a>C++怎么实现一个函数先于main函数运行</h2><ul><li>如果在main函数之前声明一个类的全局变量的对象，那么执行顺序先于main函数</li><li>定义在main函数之前的全局对象、静态对象的构造函数在main函数之前执行</li><li>mian函数执行之前，主要是初始化系统相关资源<ul><li>设置栈指针</li><li>初始化static静态和global全局变量，即data段的内容</li><li>将未初始化部分的全局变量赋初值，即bss段内容</li><li>全局对象初始化，在main之前调用构造函数</li><li>将main函数的参数，argc，argv等传递给main函数，然后才开始执行main函数</li></ul></li><li>main函数执行之后<ul><li>全局对象的析构函数会在main函数之后执行</li><li>可以用_onexit注册一个函数，它会在main之后执行</li></ul></li></ul><h2 id="虚函数和纯虚函数的区别在于"><a href="#虚函数和纯虚函数的区别在于" class="headerlink" title="虚函数和纯虚函数的区别在于"></a>虚函数和纯虚函数的区别在于</h2><ul><li>纯虚函数只有定义没有实现，虚函数既有定义又有实现</li><li>含有传虚函数的类不能定义对象，含有虚函数的类可以定义对象</li></ul><h2 id="智能指针怎么用，只能指针出现循环引用怎么解决"><a href="#智能指针怎么用，只能指针出现循环引用怎么解决" class="headerlink" title="智能指针怎么用，只能指针出现循环引用怎么解决"></a>智能指针怎么用，只能指针出现循环引用怎么解决</h2><ul><li>shar_ptr调用一个名为make_shared的标准库函数，每个shared_ptr都有一个关联计数器，通常称为引用计数，一旦一个shared_ptr的计数器变为零，他就会自动释放自己所管理的对象；shared_ptr的析构函数就会递减它所指向的对象的引用计数。如果引用计数变为零，shared_ptr的析构函数就会销毁对象，并释放它占用的内存</li><li>unique_ptr，某一时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁</li><li>weak_ptr,是一种不控制所指向对象生存期的智能指针，他指向一个由shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变引用计数，一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放，即使有weak_ptr指向对象，对象还是会被释放</li><li>弱指针用于专门解决循环引用问题</li></ul><h2 id="strcpy和strncpy函数的区别，那个函数更安全"><a href="#strcpy和strncpy函数的区别，那个函数更安全" class="headerlink" title="strcpy和strncpy函数的区别，那个函数更安全"></a>strcpy和strncpy函数的区别，那个函数更安全</h2><ul><li><p>函数原型</p><p>char * strcpy(char *strDest, const char * strSrc)</p><p>char * strncpy(char *strDet, const char *strSrc, int pos)</p></li><li><p>strcpy函数：如果参数dest所指的内存空间不够大，可能会造成缓冲溢出的错误</p><p>strncpy函数：用来复制源字符串的前n个字符，src和dest所指的内存区域不能重叠，且dest必须有足够长的空间放置n个字符</p></li><li><p>如果目标长&gt;指定长&gt;源长,则源长全部拷贝到目标长，自动加上‘\0’</p><p>如果指定长&lt;源长，则将源长中按指定长度拷贝到目标字符串，不包括’\0’</p><p>如果指定长&gt;目标长，运行错误</p></li></ul><h2 id="为什么要用static-cast转换而不用c语言中的转换"><a href="#为什么要用static-cast转换而不用c语言中的转换" class="headerlink" title="为什么要用static_cast转换而不用c语言中的转换"></a>为什么要用static_cast转换而不用c语言中的转换</h2><ul><li>更加安全</li><li>更清楚直接，可读性好</li></ul><h2 id="成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="成员函数里memset(this, 0, sizeof(*this))会发生什么"></a>成员函数里memset(this, 0, sizeof(*this))会发生什么</h2><ul><li>有时候类里面定义了很多int，char，struct等c语言里哪些类型的变量，该函数可以将整个对象的内存全部置为零</li><li>类中含有虚函数时，会破坏虚函数表</li><li>类中含有C++类型的对象时，会破坏对象的内存</li></ul><h2 id="回调函数的作用"><a href="#回调函数的作用" class="headerlink" title="回调函数的作用"></a>回调函数的作用</h2><ul><li>当发生某事件时，系统或其他函数将会自动调用你定义的一段函数</li><li>回调函数就相当于一个中断处理函数，有系统在符合你设定的条件时自动调用。为此，你需要做三件事情：声明、定义、设置触发条件，就是在你的函数中吧你的回调函数名称转化为地址作为一个参数，以便系统调用</li><li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数</li><li>因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需要知道的，只是存在一个具有某种特定原型、某些限制条件的被调用函数</li></ul><h2 id="随机数的生成"><a href="#随机数的生成" class="headerlink" title="随机数的生成"></a>随机数的生成</h2><ul><li>#include &lt;time.h&gt; srand(unsigned)time(NULL);</li></ul><h2 id="为什么拷贝构造函数必须传引用不能传值"><a href="#为什么拷贝构造函数必须传引用不能传值" class="headerlink" title="为什么拷贝构造函数必须传引用不能传值"></a>为什么拷贝构造函数必须传引用不能传值</h2><ul><li>拷贝构造函数的作用就是用来赋值对象的，在使用这个对象的实例来初始化这个对象的一个新实例</li><li>参数传递的过程到底发生了什么</li><li>将地址传递和值传递统一起来，归根结底还是传递的是值（地址也是指，只不过可以通过它找到另一个值）<ul><li>值传递：对于内置数据类型的传递时，直接赋值拷贝给形参；对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参（局部对象）；如void foo(class_type obj_local){}，如果调用foo(obj)；首先class_type obj_local(obj)，这样就定义了局部变量obj_local供函数内部使用</li><li>引用传递：无论内置类型还是类类型，传递引用或指针最终都是传递地址值，而地址总是指针类型，显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用</li></ul></li><li>拷贝构造函数用值传递会产生无限递归调用，内存溢出</li></ul><h2 id="空类的大小是多少？为什么"><a href="#空类的大小是多少？为什么" class="headerlink" title="空类的大小是多少？为什么"></a>空类的大小是多少？为什么</h2><ul><li>C++空类的大小不为零，不同编译器设置不一样，vs设置为1；</li><li>C++标准指出，不允许一个对象的大小为0，不同对象不能具有相同地址</li><li>带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定</li><li>C++中要求对于类的每个实例都必须有杜伊五二的地址，那么编译器自动为空类分配一个字节大小，这样保证了每个实例均有独一无二的内存地址</li></ul><h2 id="大内存申请的时候选用哪种？C-变量存在哪？变量的大小存在哪？符号表存在哪？"><a href="#大内存申请的时候选用哪种？C-变量存在哪？变量的大小存在哪？符号表存在哪？" class="headerlink" title="大内存申请的时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？"></a>大内存申请的时候选用哪种？C++变量存在哪？变量的大小存在哪？符号表存在哪？</h2><ul><li>大内存申请时，采用堆申请空间，用new申请</li><li>不同变量存在不同的地方，局部变量、全局变量、静态变量</li><li>C++对变量名不做存储，在汇编以后不会出现变量名，变量名作用只是用于方便编译成汇编代码，是给编译器看的，是方便人阅读的</li></ul><h2 id="静态函数能定义为虚函数吗？常函数？"><a href="#静态函数能定义为虚函数吗？常函数？" class="headerlink" title="静态函数能定义为虚函数吗？常函数？"></a>静态函数能定义为虚函数吗？常函数？</h2><ul><li>static成员不属于任何类对象或类实例，所以即使给此函数加上virtual也是没有任何意义的</li><li>static函数中没有this指针</li><li>常函数可以</li></ul><h2 id="那些函数不能作为虚函数"><a href="#那些函数不能作为虚函数" class="headerlink" title="那些函数不能作为虚函数"></a>那些函数不能作为虚函数</h2><ul><li>普通函数、友元函数、静态函数、构造函数、拷贝构造函数</li></ul><h2 id="this调用成员变量时，堆栈会发生什么变化"><a href="#this调用成员变量时，堆栈会发生什么变化" class="headerlink" title="this调用成员变量时，堆栈会发生什么变化"></a>this调用成员变量时，堆栈会发生什么变化</h2><ul><li>当类的非静态成员函数访问类的非静态成员时，把编译器会自动将对象的地址作为隐函数参数传递给函数，这个隐含参数就是this指针。即使你并没有写this指针，编译器在连接时也会加上this，对各成员的访问都是通过this的。this指针首先入栈，然后成员函数的参数从右向左进行入栈，最后函数返回地址入栈</li></ul><h2 id="静态绑定和动态绑定的介绍"><a href="#静态绑定和动态绑定的介绍" class="headerlink" title="静态绑定和动态绑定的介绍"></a>静态绑定和动态绑定的介绍</h2><ul><li>对象的静态类型：对象在声明时采用的类型。在编译器确定</li><li>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，静态类型无法更改</li><li>静态绑定：当定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译器</li><li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期</li></ul><h2 id="设计一个类计算子类的个数"><a href="#设计一个类计算子类的个数" class="headerlink" title="设计一个类计算子类的个数"></a>设计一个类计算子类的个数</h2><ul><li>为类设计一个static变量count作为计数器</li><li>类定义结束后初始化count</li><li>在构造函数中对count+1</li><li>设计拷贝构造函数，在进行拷贝构造函数中count+1</li><li>在赋值构造函数中count+1</li><li>在析构函数中count-1</li></ul><h2 id="虚函数的代价"><a href="#虚函数的代价" class="headerlink" title="虚函数的代价"></a>虚函数的代价</h2><ul><li>带有虚函数的类，每一个类会产生一个虚函数表，用来存储指向虚函数成员的指针，增大类</li><li>带有虚函数的类发每一个对象，都会有一个指向虚表的指针，会增加对象的空间的大小</li><li>不能内联</li></ul><h2 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h2><ul><li>类的非静态成员变量大小，静态成员不占类的空间，成员函数也不占据类的空间大小</li><li>内存对齐另外分配的空间大小，类的数据也是需要进行内存对齐操作的</li><li>虚函数的话，会在类对象插入vptr指针</li><li>如果该类是某类的派生类，那么派生类继承基类部分数据成员也会存在派生类的空间中</li></ul><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><ul><li>有时我们会遇到这种情况，我们用对象a初始化对象b后对象a我们就不再使用了，但是对象a的空间还在，既然拷贝函数实际上就是把a对象的内容复制一份给b，那么为什么不能直接使用a的空间呢，因此有了移动构造函数</li><li>拷贝构造函数，对于指针，我们一定要采用深层复制，而在移动构造函数中，对于指针，我们采用浅复制</li><li>C++引入了移动构造函数，专门处理这种，用a初始化b后就将a析构的情况</li><li>与拷贝类似，移动也是使用一个对象的值设置另一个对象的值。但是又与拷贝不同的是，移动实现的是对象值真实的转移；源对象丢失其内容，被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象是时候（典型的就是函数返回值或类型转换返回值）。使用临时对象的值初始化另一个对象的值，不会要求对对象的复制，因为临时对象不会有其他使用，因而，它的值可以被移动到目的对象。</li></ul><h2 id="何时需要合成构造函数"><a href="#何时需要合成构造函数" class="headerlink" title="何时需要合成构造函数"></a>何时需要合成构造函数</h2><ul><li>如果一个类没有任何构造函数，但他有一个成员对象，该成员对象含有默认构造函数，那么编译器就会为该类合成一个默认构造函数。</li><li>没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要为该类合成一个构造函数</li><li>带有虚函数的类</li><li>带有一个虚基类的类</li></ul><h2 id="何时需要合成复制构造函数"><a href="#何时需要合成复制构造函数" class="headerlink" title="何时需要合成复制构造函数"></a>何时需要合成复制构造函数</h2><ul><li>对一个对象做显示的初始化操作</li><li>对象被当作参数交给某函数时</li><li>函数传回一个类对象时</li><li>如果一个类没有拷贝构造函数，但是含有一个类类型的成员变量，该类型有拷贝构造函数</li><li>如果一个类没有拷贝构造函数，但是该类继承自含有拷贝构造函数的基类</li><li>如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数</li><li>如果一个类没有拷贝构造函数，但是该类含有虚基类</li></ul><h2 id="何时需要成员初始化列表"><a href="#何时需要成员初始化列表" class="headerlink" title="何时需要成员初始化列表"></a>何时需要成员初始化列表</h2><ul><li>初始化一个引用成员变量时</li><li>初始化一个const成员变量时</li><li>调用一个基类构造函数，而构造函数拥有一组参数时</li><li>调用一个成员类的构造函数，而构造函数有一组参数</li><li>编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前</li></ul><h2 id="程序员定义的析构函数被扩展的过程"><a href="#程序员定义的析构函数被扩展的过程" class="headerlink" title="程序员定义的析构函数被扩展的过程"></a>程序员定义的析构函数被扩展的过程</h2><ul><li>析构函数函数体被执行</li><li>如果class 拥有成员类对象，而后者拥有析构函数，那么它们会以声明顺序的相反顺序被调用</li><li>如果对象有一个vptr，限制被重新定义</li><li>如果有任何直接的上一层非虚基类拥有析构函数，则它们会有声明顺序被调用</li><li>如果任何虚基类拥有析构函数</li></ul><h2 id="构造函数的执行算法"><a href="#构造函数的执行算法" class="headerlink" title="构造函数的执行算法"></a>构造函数的执行算法</h2><ul><li>虚基类及基类构造函数</li><li>vptr初始化</li><li>成员初始化列表</li><li>程序员提供的代码</li></ul><h2 id="迭代器-it，it-哪个好，为什么"><a href="#迭代器-it，it-哪个好，为什么" class="headerlink" title="迭代器++it，it++哪个好，为什么"></a>迭代器++it，it++哪个好，为什么</h2><ul><li><p>前置返回一个引用，后置返回一个对象</p><p>++i实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">iknt &amp; <span class="keyword">operator</span>++()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li><li><p>前置不会产生临时对象，后置必须产生临时对象</p><p>i++实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp = *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    ++*<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="C-如何处理多个异常"><a href="#C-如何处理多个异常" class="headerlink" title="C++如何处理多个异常"></a>C++如何处理多个异常</h2><ul><li><p>C++中的异常情况</p><p>语法错误、运行错误</p></li><li><p>C++异常处理机制</p><p>异常处理基本思想：执行一个函数过程中发生异常，可以不用在本函数立即进行处理，而是抛出异常，让函数的调用者直接或间接处理这个问题</p><p>C++异常处理机制由3个模块组成：try、throw、catch</p><p>抛出异常的语句个数为throw表达式；如果try快中程序段发生了异常则抛出异常</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li></ul><h2 id="模板和实现可不可以不写在一个文件里面？为什么"><a href="#模板和实现可不可以不写在一个文件里面？为什么" class="headerlink" title="模板和实现可不可以不写在一个文件里面？为什么"></a>模板和实现可不可以不写在一个文件里面？为什么</h2><ul><li>因为在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的cpp文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的cpp文件的存在，所以他只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于连接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果连接程序找不到地址只好报错</li><li>模板定义很特殊，由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为他分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一种机制能去掉制定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义</li></ul><h2 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h2><ul><li><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他函数的调用只要不涉及this指针的内容，都可以正常执行。一旦涉及this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p></li><li><p>delete this之后释放了类对象的内存空间，那么这段内存已经还给了系统，不再属于这个进程。照这个逻辑看应该发生指针错误，无访问权限之类的问题，但实际不是这样，内存空间并不是马上被挥手给系统，可能是缓冲或者其他什么原因，导致这段内存空间暂时没有被系统收回。此时这段内存是可以访问的，你可以操作他，但其中的值确实不确定的</p></li><li><p>如果在类的析构函数中调用delete this，会发生什么？</p><p>会导致堆栈溢出，因为delete里调用析构函数并释放内存，会形成无限递归</p></li></ul><h2 id="auto-ptr作用"><a href="#auto-ptr作用" class="headerlink" title="auto_ptr作用"></a>auto_ptr作用</h2><ul><li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄露”的问题；抛出异常，将异常导致指针p所指向的空间得不到释放而导致内存泄漏</li><li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏</li><li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象</li><li>由于auto_ptr对象析构时会删除它所拥有的指针，作用使用时避免多个auto_ptr对象管理同一个指针</li><li>auto_ptr内部实现，析构函数中删除对象用的时delete而不是delete[]，所以auto不能管理数组</li><li>auto_ptr支持所拥有的指针类型之间的隐式类型转换</li></ul><h2 id="class、union、struct的区别"><a href="#class、union、struct的区别" class="headerlink" title="class、union、struct的区别"></a>class、union、struct的区别</h2><ul><li>c语言中struct只是一个聚合数据类型，没有权限设置，无法添加成员函数，无法实现面向对象编程，且如果没有 typedef结构名，声明结构变量必须添加关键字struct</li><li>C++中struct功能大大扩展，可以有权限设置，可以有成员函数，继承，可以实现面向对象编程，允许声明时省略关键字strut</li><li>union：一种数据格式，能够存储不同数据类型，但只能同时存储其中的一种。C++中union时一种特殊的类，可以有访问权限，成员变量，成员函数，不能包含虚函数和静态数据，不能继承和派生</li></ul><h2 id="动态联编和静态联编"><a href="#动态联编和静态联编" class="headerlink" title="动态联编和静态联编"></a>动态联编和静态联编</h2><ul><li>在C++中，联编是指一个计算机程序的不同部分彼此关联的过程，按照联编所进行的阶段不同，可以分为静态联编和动态联编</li><li>静态联编是指联编工作在编译阶段完成，这种联编过程是在程序运行之前完成的，又称为早期联编。要实现静态联编，在编译阶段就必须确认程序中的操作调用与执行该操作代码间的关系，确定这种关系成为束定，在编译时的束定成为静态束定。静态联编对函数的选择基于指向对象或者引用的类型。其优点是效率高，但灵活性差</li><li>动态联编是指联编在程序运行时动态的进行，根据当时的情况来确定调用哪个同名函数，实际上时在运行时虚函数的实现。这种联编又称为晚期联编，或动态束定。动态联编对成员函数的选择时经济与对象的类型，针对不同的对象类型做出不同的编译结果</li></ul><h2 id="动态编译与静态编译"><a href="#动态编译与静态编译" class="headerlink" title="动态编译与静态编译"></a>动态编译与静态编译</h2><ul><li>静态编译，编译器在编译可执行文件时，需要用到的对应动态链接库中的部分提取出来，连接到可执行文件中去，使可执行文件在运行时不需要依赖于动态链接库</li><li>动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态连接库的命令。所以其优点一方面时缩小了执行文件文件本身的体积，另一方面加快了编译速度，节省了系统资源。缺点是哪怕很简单的程序，只用到连接库的一两条命令，也需要附带一个相对庞大的连接库；二是如果其他计算机上没有安装对应的运行库，则动态编译的可执行文件不能运行</li></ul><h2 id="动态链接和静态链接区别"><a href="#动态链接和静态链接区别" class="headerlink" title="动态链接和静态链接区别"></a>动态链接和静态链接区别</h2><ul><li>静态链接库就是把（lib）文件中用到的函数到目直接连接进目标程序，程序运行期间不需要其他库文件；动态链接时把调用的函数所在文件模块（dll）和调用函数在文件中的位置等信息连接进目标程序，程序运行的时候再从dll中寻找相应函数代码，因此需要相应dll文件支持</li><li>静态连接库与动态连接库都是共享代码的方式，如果采用静态连接库，无论你愿不愿意，lib中的指令都全部被直接包含在最终exe文件中，但若是使用dll，改dll不必被包含着最终exe文件中，exe文件执行时可以“动态”的引用和卸载这个与exe独立的dll文件。静态链接库和动态链接库的另外一个区别在于静态链接库中不能再包含其他静态库或动态链接库，动态链接库可以</li><li>动态链接库就是在需要调用其中函数的时候，根据函数映射表找到该函数然后调入堆栈执行。如果当前工程中有多处对dll文件中同意函数的调用，那么执行时，这个函数只会留下一份拷贝。但lib会留下多份拷贝</li></ul><h2 id="vloatile关键字的作用"><a href="#vloatile关键字的作用" class="headerlink" title="vloatile关键字的作用"></a>vloatile关键字的作用</h2><ul><li>用它声明的类型变量表示可以被某些编译器未知因素修改</li></ul><h2 id="空类会默认添加哪些东西"><a href="#空类会默认添加哪些东西" class="headerlink" title="空类会默认添加哪些东西"></a>空类会默认添加哪些东西</h2><ul><li>缺省构造函数</li><li>拷贝构造函数</li><li>析构函数</li><li>赋值运算符</li></ul><h2 id="new、delete、operator-new、operator-delete、placement-new、placementdelete"><a href="#new、delete、operator-new、operator-delete、placement-new、placementdelete" class="headerlink" title="new、delete、operator new、operator delete、placement new、placementdelete"></a>new、delete、operator new、operator delete、placement new、placementdelete</h2><ul><li>new 申请内存和初始化对象</li><li>operator new 只申请内存</li><li>placement new用于在给定内存中初始化对象</li></ul><h2 id="宏定义一个取两个数较大值的功能"><a href="#宏定义一个取两个数较大值的功能" class="headerlink" title="宏定义一个取两个数较大值的功能"></a>宏定义一个取两个数较大值的功能</h2><ul><li><pre><code class="c++"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x&gt;y)?x:y)</span></code></pre></li></ul><h2 id="define、const、typedef、inline使用方法"><a href="#define、const、typedef、inline使用方法" class="headerlink" title="define、const、typedef、inline使用方法"></a>define、const、typedef、inline使用方法</h2><ul><li>const、define区别<ul><li>const定义的常量是变量带类型，define只是常熟不带类型</li><li>define在预处理阶段起作用，const在编译连接过程起作用</li><li>define没有类型检查、const有</li><li>define占代码段，const占数据段</li><li>const不能重定义，define可以取消，然后重定义</li><li>define独特功能，可以防止文件重复引用</li></ul></li><li>define和别名typedef的区别<ul><li>执行时间不同，typedef在编译阶段，有类型检查，define在预处理阶段，没有类型检查</li><li>功能差异，typedef结合struct使用，define功能更多</li><li>define没有作用域限制，typedef有自己的作用域</li></ul></li><li>inline和define区别<ul><li>define是预处理阶段，inline是编译阶段</li><li>inline函数有类型检查，更安全</li></ul></li></ul><h2 id="printf实现原理"><a href="#printf实现原理" class="headerlink" title="printf实现原理"></a>printf实现原理</h2><ul><li>在C++中函数参数的扫描时从后往前的，通过压入堆栈的方式来给函数传参数，数据有两块，一块是堆，一块是栈，栈是从内存高地址向内存低地址生长的，控制生长的就是堆栈指针，最先压入的参数在最上面，所以最后压入的参数总能被函数找到。printf的第一个被找到的参数就是那个字符指针，就是被双引号括起来那一部分，函数通过判断字符串里控制参数的个数来判断参数个数及数据类型，通过这些就可以算出数据需要的堆栈指针的偏移量</li></ul><h2 id="include的顺序及尖括号和双引号的区别"><a href="#include的顺序及尖括号和双引号的区别" class="headerlink" title="include的顺序及尖括号和双引号的区别"></a>include的顺序及尖括号和双引号的区别</h2><ul><li>表示编译器只在系统默认目录或尖括号内的工作目录下搜索</li><li>表示现在用户工作目录下找头文件，找不到去系统默认目录下找</li></ul><h2 id="helloworld程序开始到打印到屏幕上的全过程"><a href="#helloworld程序开始到打印到屏幕上的全过程" class="headerlink" title="helloworld程序开始到打印到屏幕上的全过程"></a>helloworld程序开始到打印到屏幕上的全过程</h2><ul><li>开始</li><li>操作系统找到程序相关信息，检查是否是可执行文件，并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址</li><li>创建新进程，将程序可执行文件映射到该进程结构中</li><li>为程序设置cpu上下文环境，跳转到程序开始处</li><li>执行命令，发生缺页中断</li><li>分配一页物理内存，将代码从磁盘读入内存，继续执行程序</li><li>程序执行puts函数，在显示器上写一字符串</li><li>找到显示设备，将字符串送给管理设备的进程</li><li>设备的窗口系统确认是合法操作，将字符串转换成像素，写入存储映像区</li><li>解释信号</li></ul><h2 id="模板类和模板函数区别"><a href="#模板类和模板函数区别" class="headerlink" title="模板类和模板函数区别"></a>模板类和模板函数区别</h2><ul><li>函数模板的实例化时由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显示地指定。</li></ul><h2 id="为什么模板类一般都是放在一个h文件中"><a href="#为什么模板类一般都是放在一个h文件中" class="headerlink" title="为什么模板类一般都是放在一个h文件中"></a>为什么模板类一般都是放在一个h文件中</h2><ul><li>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</li><li>在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。</li></ul><h2 id="C-中访问权限和继承权限"><a href="#C-中访问权限和继承权限" class="headerlink" title="C++中访问权限和继承权限"></a>C++中访问权限和继承权限</h2><ul><li>public、private、protected</li></ul><h2 id="cout和printf区别"><a href="#cout和printf区别" class="headerlink" title="cout和printf区别"></a>cout和printf区别</h2><ul><li>cout&lt;&lt;是一个函数，有缓冲输出</li><li>printf没有缓冲输出，立即输出</li></ul><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><ul><li><p>我们只能重载已有的运算符，而无权发明新的运算符；对于一个重载的运算符，其优先级和结合律与内置类型一致才可以；不能改变运算符操作数个数；</p></li><li><p>：：  ？：  sizeof  typeid **不能重载；</p></li><li><p>两种重载方式，成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；</p></li><li><p>引入运算符重载，是为了实现类的多态性；</p></li><li><p>当重载的运算符是成员函数时，this绑定到左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；</p></li><li><p>从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符（+，-，*，&amp;）；</p></li><li><p>下标运算符必须是成员函数，下标运算符通常以所访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；</p></li><li><p>箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；</p></li></ul><h2 id="重载函数匹配原则"><a href="#重载函数匹配原则" class="headerlink" title="重载函数匹配原则"></a>重载函数匹配原则</h2><ul><li>名字查找</li><li>确定候选</li><li>寻找最佳</li></ul><h2 id="定义和声明的区别"><a href="#定义和声明的区别" class="headerlink" title="定义和声明的区别"></a>定义和声明的区别</h2><ul><li>如果是指变量的什么和定义，声明只是告诉编译器某个类型的变量会被使用，定义是指分配了内存</li><li>函数的声明和定义，声明不需要实现，定义需要实现</li></ul><h2 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h2><ul><li>static_cast 能进行基础类型之间的转换，也是最长看到的类型转换。它主要有如下几种用法：<ul><li>用于类层次结构中父类和子类之间指针或引用的转换。进行上行转换是安全的</li><li>进行下行转换时，没有动态类型检查，是不安全的</li><li>用于基本数据类型之间的转换，如把int转换成char，把int转换成enum，安全性需要开发人员保证</li><li>把void指针转成目标指针（不安全）</li><li>把其他指针转成void指针</li></ul></li><li>const_cast去除指向常熟对象的指针或引用的常量性</li><li>reinterpret_cast可以把指针转换成一个证书，或把证书转换成一个指针</li><li>dynamic_cast主要用在继承体系中的安全向下转型，会用运行时信息（RTTI）来进行类型安全性检查，必须包含虚函数（通过使用vtable中的信息来判断实际类型）</li></ul><h2 id="全局变量和static变量区别"><a href="#全局变量和static变量区别" class="headerlink" title="全局变量和static变量区别"></a>全局变量和static变量区别</h2><ul><li><p>全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</p></li><li><p>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</p></li><li><p>static函数与普通函数有什么区别？<br>static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。</p></li><li><p>static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p></li></ul><h2 id="静态成员与普通成员的区别"><a href="#静态成员与普通成员的区别" class="headerlink" title="静态成员与普通成员的区别"></a>静态成员与普通成员的区别</h2><ul><li><p>生命周期</p><p>静态成员变量从类被加载开始到类被卸载，一直存在；</p><p>普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束；</p></li><li><p>共享方式</p><p>静态成员变量是全类共享；普通成员变量是每个对象单独享用的；</p></li><li><p>定义位置</p><p>普通成员变量存储在栈或堆中，而静态成员变量存储在静态全局区；</p></li><li><p>初始化位置</p><p>普通成员变量在类中初始化；静态成员变量在类外初始化；</p></li><li><p>默认实参</p><p>可以使用静态成员变量作为默认实参</p></li></ul><h2 id="ifdef、endif"><a href="#ifdef、endif" class="headerlink" title="ifdef、endif"></a>ifdef、endif</h2><ul><li>满足条件时编译</li></ul><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><ul><li>C++的基本类型中并非完全的对立，部分数据类型之间是可以进行隐式转换的。所谓隐式转换，是指不需要用户干预，编译器私下进行的类型转换行为。很多时候用户可能都不知道进行了哪些转换</li><li>C++面向对象的多态特性，就是通过父类的类型实现对子类的封装。通过隐式转换，你可以直接将一个子类的对象使用父类的类型进行返回。在比如，数值和布尔类型的转换，整数和浮点数的转换等。某些方面来说，隐式转换给C++程序开发者带来了不小的便捷。C++是一门强类型语言，类型的检查是非常严格的。</li><li>基本数据类型 基本数据类型的转换以取值范围的作为转换基础（保证精度不丢失）。隐式转换发生在从小-&gt;大的转换中。比如从char转换为int。从int-&gt;long。自定义对象 子类对象可以隐式的转换为父类对象。</li><li>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。</li><li>如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++第三次总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://miracle-qsh.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://miracle-qsh.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++总结(2)</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/C++2/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/C++2/</id>
    <published>2020-03-08T11:45:31.050Z</published>
    <updated>2020-04-08T00:48:26.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++第二次总结，结合常见问题</p><a id="more"></a><h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><h3 id="C-程序内存分区"><a href="#C-程序内存分区" class="headerlink" title="C++程序内存分区"></a>C++程序内存分区</h3><ul><li>栈区：函数中定义的局部变量</li><li>堆区：动态分配的内存空间</li><li>全局区：全局变量、静态数据、常量</li><li>常量区：常量字符串</li><li>代码区：代码二进制码</li></ul><h3 id="存储在全局区的变量什么时候进行初始化"><a href="#存储在全局区的变量什么时候进行初始化" class="headerlink" title="存储在全局区的变量什么时候进行初始化"></a>存储在全局区的变量什么时候进行初始化</h3><ul><li>C语言中程序开始运行时即完成初始化</li><li>C++中初始化发生在执行相关代码之前</li></ul><h3 id="C-中是否可以使用变量初始化静态局部变量"><a href="#C-中是否可以使用变量初始化静态局部变量" class="headerlink" title="C++中是否可以使用变量初始化静态局部变量"></a>C++中是否可以使用变量初始化静态局部变量</h3><ul><li>只要变量的定义在静态局部变量执行之前即可</li></ul><h3 id="什么时浅复制与深复制"><a href="#什么时浅复制与深复制" class="headerlink" title="什么时浅复制与深复制"></a>什么时浅复制与深复制</h3><ul><li>浅复制：只是拷贝基本类型数据，而引用类型数据复制后仍指向原引用对象</li><li>深复制：在计算机中开辟新内存地址存放复制对象</li></ul><h3 id="浅复制会带来什么问题"><a href="#浅复制会带来什么问题" class="headerlink" title="浅复制会带来什么问题"></a>浅复制会带来什么问题</h3><ul><li>动态分配内存的变量A浅复制给变量B，则析构时会发生两次释放内存，出现运行错误</li></ul><h3 id="C中的struct与C-中的struct有什么区别"><a href="#C中的struct与C-中的struct有什么区别" class="headerlink" title="C中的struct与C++中的struct有什么区别"></a>C中的struct与C++中的struct有什么区别</h3><ul><li>C中struct是用户自定义数据类型；C++中的struct是抽象数据类型，支持成员函数、继承、多态</li><li>C中struct没有权限设置；C++中有权限控制</li><li>C中定义struct变量时要加上struct；C++不用</li></ul><h2 id="关键字相关"><a href="#关键字相关" class="headerlink" title="关键字相关"></a>关键字相关</h2><h3 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h3><ul><li>隐藏：修饰的函数与变量仅当前文件可见</li><li>持久：修饰的变量生存期到程序结束</li><li>初始化：修饰的变量默认初始化为0</li><li>公用：类中被修饰的变量和函数被该类所有对象共有</li></ul><h3 id="static修饰的成员函数（类中）能否使用this指针"><a href="#static修饰的成员函数（类中）能否使用this指针" class="headerlink" title="static修饰的成员函数（类中）能否使用this指针"></a>static修饰的成员函数（类中）能否使用this指针</h3><ul><li>不能使用，因为static修饰的成员函数被所有对象共有，且可通过类名::直接调用，故不能使用this指针</li></ul><h3 id="类内使用static有什么要注意的"><a href="#类内使用static有什么要注意的" class="headerlink" title="类内使用static有什么要注意的"></a>类内使用static有什么要注意的</h3><ul><li>static修饰的类对象必须在类外进行初始化</li><li>static修饰的成员函数不能访问非static成员变量</li><li>static修饰的成员函数不能被virtual修饰</li></ul><h3 id="为什么static类对象必须在类外初始化"><a href="#为什么static类对象必须在类外初始化" class="headerlink" title="为什么static类对象必须在类外初始化"></a>为什么static类对象必须在类外初始化</h3><ul><li>static修饰的变量在相关代码开始运行时即初始化，先于对象存在，因此需要类外初始化</li><li>如果不初始化会报连接错误</li></ul><h3 id="为什么static成员函数不能访问非static成员变量"><a href="#为什么static成员函数不能访问非static成员变量" class="headerlink" title="为什么static成员函数不能访问非static成员变量"></a>为什么static成员函数不能访问非static成员变量</h3><ul><li>C++访问成员变量的方法是通过this指针，但static函数没有this指针，因此不能访问非static成员函数</li></ul><h3 id="为什么static成员函数不能被virtual修饰"><a href="#为什么static成员函数不能被virtual修饰" class="headerlink" title="为什么static成员函数不能被virtual修饰"></a>为什么static成员函数不能被virtual修饰</h3><ul><li>虚函数的实现是为每一个对象分配一个vptr指针，指向虚函数表，而vptr是通过this指针调用的，static函数没有this指针，故不能被virtual修饰</li></ul><h3 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h3><ul><li>修饰变量：修饰的变量不可被改变</li><li>修饰指针：可指定指针或指针指向的数据不可改变</li><li>修饰引用：修饰的引用所指的对象不可改变</li><li>修饰参数：修饰的变量在函数内部不可改变</li><li>修饰成员函数：修饰函数不可改变成员变量</li></ul><h3 id="类的常对象可以访问类的非常成员函数吗"><a href="#类的常对象可以访问类的非常成员函数吗" class="headerlink" title="类的常对象可以访问类的非常成员函数吗"></a>类的常对象可以访问类的非常成员函数吗</h3><ul><li>不能，任何没被const修饰的成员函数被认为会修改类的成员变量</li></ul><h3 id="非const成员函数可以访问const对象的数据成员吗"><a href="#非const成员函数可以访问const对象的数据成员吗" class="headerlink" title="非const成员函数可以访问const对象的数据成员吗"></a>非const成员函数可以访问const对象的数据成员吗</h3><ul><li>不能，任何没被const修饰的成员函数被认为会修改类的成员变量</li></ul><h3 id="const成员函数可以访问非const对象的数据成员吗"><a href="#const成员函数可以访问非const对象的数据成员吗" class="headerlink" title="const成员函数可以访问非const对象的数据成员吗"></a>const成员函数可以访问非const对象的数据成员吗</h3><ul><li>可以访问，因为const成员函数只是不能修改成员变量，并非不能访问成员变量</li></ul><h3 id="使用const关键字需要注意些什么"><a href="#使用const关键字需要注意些什么" class="headerlink" title="使用const关键字需要注意些什么"></a>使用const关键字需要注意些什么</h3><ul><li>const变量定义时必须初始化</li></ul><h3 id="const修饰指针的几种情况"><a href="#const修饰指针的几种情况" class="headerlink" title="const修饰指针的几种情况"></a>const修饰指针的几种情况</h3><ul><li>指针不可变：<code>int * const p;</code></li><li>指针指向的值不可变：<code>int const *p;</code></li><li>指针与指针指向的值均不可变：<code>int const * const p;</code></li></ul><h3 id="extern的作用"><a href="#extern的作用" class="headerlink" title="extern的作用"></a>extern的作用</h3><ul><li>引入外部变量/函数：修饰的变量会自动去别的文件查找</li><li>指示调用C/C++库函数：<code>extern &quot;C&quot;</code>声明函数为C函数</li></ul><h3 id="有全局变量了为什么还要用extern"><a href="#有全局变量了为什么还要用extern" class="headerlink" title="有全局变量了为什么还要用extern"></a>有全局变量了为什么还要用extern</h3><ul><li>如果不同文件共同include同一个文件，则被引用文件中的变量定义会重复，使用extern可以只声明而不定义。</li></ul><h3 id="inline的作用"><a href="#inline的作用" class="headerlink" title="inline的作用"></a>inline的作用</h3><ul><li>内联函数，提高效率</li></ul><h3 id="内联函数的原理"><a href="#内联函数的原理" class="headerlink" title="内联函数的原理"></a>内联函数的原理</h3><ul><li>在编译期间，对调用内联函数的地方的代码替换成函数代码</li></ul><h2 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h2><h3 id="构造函数与析构函数的作用"><a href="#构造函数与析构函数的作用" class="headerlink" title="构造函数与析构函数的作用"></a>构造函数与析构函数的作用</h3><ul><li>构造函数起初始化值的作用，会在对象实例化时自动调用</li><li>析构函数用于撤销对象的操作，无参数，无返回值，不能重载，一个类只有一个析构函数，对象销毁时会自动调用析构函数</li></ul><h3 id="类成员初始化的方式有哪些"><a href="#类成员初始化的方式有哪些" class="headerlink" title="类成员初始化的方式有哪些"></a>类成员初始化的方式有哪些</h3><ul><li>赋值初始化：会产生临时对象</li><li>初始化列表</li></ul><h3 id="赋值初始化和列表初始化有什么区别"><a href="#赋值初始化和列表初始化有什么区别" class="headerlink" title="赋值初始化和列表初始化有什么区别"></a>赋值初始化和列表初始化有什么区别</h3><ul><li>赋值初始化在所有数据成员被分配内存空间后才进行</li><li>列表初始化在给数据成员分配内存空间时即进行</li></ul><h3 id="为什么列表初始化比赋值初始化要快一些"><a href="#为什么列表初始化比赋值初始化要快一些" class="headerlink" title="为什么列表初始化比赋值初始化要快一些"></a>为什么列表初始化比赋值初始化要快一些</h3><ul><li>对于内置类型，不会调用构造函数，因此列表初始化与赋值初始化性能相同</li><li>对于类类型，因为在进入函数体之前，所有对象已构造完成，列表初始化在进入函数体之前，因此只需要构造一次，而赋值初始化在进入函数体之后进行，需要在进行一次赋值操作，会产生临时对象，进行拷贝构造</li></ul><h3 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h3><ul><li>虚基类构造函数</li><li>基类构造函数</li><li>类类型成员对象构造函数</li><li>派生类自己的构造函数</li></ul><h3 id="解释一下什么是虚基类"><a href="#解释一下什么是虚基类" class="headerlink" title="解释一下什么是虚基类"></a>解释一下什么是虚基类</h3><ul><li>虚基类是为了防止重复继承而出现的机制，比如A继承于B和C，B和C均继承与D，那么A就会继承两份D的成员变量，将D声明为虚基类后，A只会继承一份</li></ul><h3 id="必须使用成员列表初始化的情况有哪些"><a href="#必须使用成员列表初始化的情况有哪些" class="headerlink" title="必须使用成员列表初始化的情况有哪些"></a>必须使用成员列表初始化的情况有哪些</h3><ul><li>初始化引用成员时，因为引用不可以被赋值</li><li>初始化常量成员时，因为常量不可以被赋值</li><li>基类构造函数有参数时，因为没有默认构造函数，无法空参构造</li><li>成员类构造函数有参数时，因为没有默认构造函数，无法空参构造</li></ul><h3 id="构造函数为什么不能是虚函数"><a href="#构造函数为什么不能是虚函数" class="headerlink" title="构造函数为什么不能是虚函数"></a>构造函数为什么不能是虚函数</h3><ul><li>虚函数是通过vptr指针实现指向虚函数表的，如果构造函数是虚函数，那么必须调用vptr指针，但此时对象还没实例化，昔找不到vptr，也就无法运行</li></ul><h3 id="基类析构函数为什么要是虚函数"><a href="#基类析构函数为什么要是虚函数" class="headerlink" title="基类析构函数为什么要是虚函数"></a>基类析构函数为什么要是虚函数</h3><ul><li>为了防止内存泄漏，因为如果基类析构函数不是虚函数，那么如果派生类中申请了内存空间，并且通过基类指针指向的派生类删除时，只会调用基类的析构函数，派生类申请的空间无法释放</li></ul><h3 id="构造函数和析构函数中可以调用虚函数吗"><a href="#构造函数和析构函数中可以调用虚函数吗" class="headerlink" title="构造函数和析构函数中可以调用虚函数吗"></a>构造函数和析构函数中可以调用虚函数吗</h3><ul><li>可以，但不提倡，构造函数和析构函数中调用虚函数，使用的是该类中定义的虚函数，不会进行动态联编，如果子类中没有定义虚函数但构造函数中调用了它，会报错</li></ul><h3 id="虚函数的调用关系"><a href="#虚函数的调用关系" class="headerlink" title="虚函数的调用关系"></a>虚函数的调用关系</h3><ul><li>this -&gt; vptr -&gt; ctable -&gt; virtual function</li></ul><h3 id="虚函数可以声明为inline吗"><a href="#虚函数可以声明为inline吗" class="headerlink" title="虚函数可以声明为inline吗"></a>虚函数可以声明为inline吗</h3><ul><li>不能，虚因为函数在运行时进行类型确定，而内联函数在编译时完成函数替代</li></ul><h2 id="泛型相关"><a href="#泛型相关" class="headerlink" title="泛型相关"></a>泛型相关</h2><h3 id="C-模板的底层实现"><a href="#C-模板的底层实现" class="headerlink" title="C++模板的底层实现"></a>C++模板的底层实现</h3><ul><li>编译器对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译</li></ul><h3 id="模板为什么要经过两次编译"><a href="#模板为什么要经过两次编译" class="headerlink" title="模板为什么要经过两次编译"></a>模板为什么要经过两次编译</h3><ul><li>模板函数要被是李丽华之后才能成为真正的函数，如果只进行一次编译，那么若是引入的头文件中只有声明，没有定义，那么编译器无法实例化，造成连接错误</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++第二次总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://miracle-qsh.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://miracle-qsh.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++总结(1)</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/C++1/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/C++1/</id>
    <published>2020-03-08T11:43:05.433Z</published>
    <updated>2020-04-08T00:48:22.955Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>C++第一次总结，结合常见问题</p><a id="more"></a><h4 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h4><p>修饰变量，修饰指针，修饰引用，修饰成员函数</p><h4 id="const与-define的区别"><a href="#const与-define的区别" class="headerlink" title="const与#define的区别"></a>const与#define的区别</h4><p>const带类型，define不带类型</p><p>const在编译和运行时起作用，define在预处理阶段起作用</p><p>define没有类型检查，const有类型检查</p><p>define占代码段空间，const占数据段空间</p><h4 id="static作用"><a href="#static作用" class="headerlink" title="static作用"></a>static作用</h4><p>修饰全局变量，修饰局部变量，修饰普通函数，修饰成员函数</p><h4 id="介绍一下this指针"><a href="#介绍一下this指针" class="headerlink" title="介绍一下this指针"></a>介绍一下this指针</h4><p>指向对象本身的指针</p><h4 id="介绍一下inline内联函数"><a href="#介绍一下inline内联函数" class="headerlink" title="介绍一下inline内联函数"></a>介绍一下inline内联函数</h4><p>相当于把函数体写在调用函数处，类中函数（除虚函数）隐式为内联函数，有类型检查，提高了效率，但导致了代码膨胀</p><h4 id="虚函数可以内联吗"><a href="#虚函数可以内联吗" class="headerlink" title="虚函数可以内联吗"></a>虚函数可以内联吗</h4><p>可以内联，但表现多态时不行</p><h4 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h4><p>使修饰的变量不会被优化</p><h4 id="assert-作用"><a href="#assert-作用" class="headerlink" title="assert()作用"></a>assert()作用</h4><p>如果它的条件返回错误，终止程序执行</p><h4 id="sizeof-作用"><a href="#sizeof-作用" class="headerlink" title="sizeof()作用"></a>sizeof()作用</h4><p>获得变量或数组的大小，sizeof(指针)为指针大小</p><h4 id="pragma-pack-n-作用"><a href="#pragma-pack-n-作用" class="headerlink" title="pragma pack(n)作用"></a>pragma pack(n)作用</h4><p>以n字节方式内存对齐</p><h4 id="extern作用"><a href="#extern作用" class="headerlink" title="extern作用"></a>extern作用</h4><p>引用另一个文件中的变量或函数</p><h4 id="struct和typedef-struct区别"><a href="#struct和typedef-struct区别" class="headerlink" title="struct和typedef struct区别"></a>struct和typedef struct区别</h4><p>struct是定义结构体类型</p><p>typedef struct是为结构体类型设置别名</p><h4 id="什么是函数指针"><a href="#什么是函数指针" class="headerlink" title="什么是函数指针"></a>什么是函数指针</h4><p>指向函数的指针，和指针变量一样，通过指针访问调用函数</p><h4 id="struct-和-class区别"><a href="#struct-和-class区别" class="headerlink" title="struct 和 class区别"></a>struct 和 class区别</h4><p>默认访问控制不同</p><p>struct是public，class是private</p><h4 id="union特点"><a href="#union特点" class="headerlink" title="union特点"></a>union特点</h4><p>默认访问控制public</p><p>可以有构造函数、析构函数</p><p>不能有引用</p><p>不能继承派生</p><p>不能有虚函数</p><p>同一时间只有一个变量有值</p><h4 id="struct和union的区别"><a href="#struct和union的区别" class="headerlink" title="struct和union的区别"></a>struct和union的区别</h4><p>union可以有构造函数和析构函数，struct没有</p><p>union不能有引用，struct可以</p><p>union不能有虚函数，struct可以</p><p>union同一时间只有一个变量有值</p><h4 id="explicit关键字的作用"><a href="#explicit关键字的作用" class="headerlink" title="explicit关键字的作用"></a>explicit关键字的作用</h4><p>声明类构造函数是显示调用的</p><h4 id="介绍一下友元"><a href="#介绍一下友元" class="headerlink" title="介绍一下友元"></a>介绍一下友元</h4><p>friend修饰，之后可以访问友元类的私有成语和函数</p><h4 id="using的作用"><a href="#using的作用" class="headerlink" title="using的作用"></a>using的作用</h4><p>引入命名空间</p><h4 id="运算符的作用"><a href="#运算符的作用" class="headerlink" title="::运算符的作用"></a>::运算符的作用</h4><p>范围解析（全局、类、命名空间）</p><h4 id="介绍一下enum类型"><a href="#介绍一下enum类型" class="headerlink" title="介绍一下enum类型"></a>介绍一下enum类型</h4><p>枚举类型</p><h4 id="介绍一下引用"><a href="#介绍一下引用" class="headerlink" title="介绍一下引用"></a>介绍一下引用</h4><p>左值引用，右值引用（右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值）</p><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><p>指针是一个变量，引用是一个别名</p><p>引用的大小是被引用对象的大小，指针大小是指针变量本身的大小</p><p>引用必须初始化，指针不用</p><p>引用不可修改，指针能修改</p><p>引用底层是指针实现的</p><h4 id="介绍一下宏"><a href="#介绍一下宏" class="headerlink" title="介绍一下宏"></a>介绍一下宏</h4><p>#define，一对一的替换</p><h4 id="介绍一下虚函数"><a href="#介绍一下虚函数" class="headerlink" title="介绍一下虚函数"></a>介绍一下虚函数</h4><p>用virtual关键字修饰，可以实现，也可以不实现（纯虚函数），存在纯虚函数的类叫抽象类，全部为纯虚函数的类叫接口类，用来实现多态，可以在子类中重新定义</p><h4 id="什么是是虚析构函数"><a href="#什么是是虚析构函数" class="headerlink" title="什么是是虚析构函数"></a>什么是是虚析构函数</h4><p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象</p><h4 id="什么是纯虚函数"><a href="#什么是纯虚函数" class="headerlink" title="什么是纯虚函数"></a>什么是纯虚函数</h4><p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做</p><h4 id="虚函数与纯虚函数的区别"><a href="#虚函数与纯虚函数的区别" class="headerlink" title="虚函数与纯虚函数的区别"></a>虚函数与纯虚函数的区别</h4><p>虚函数有具体实现，纯虚函数只是声明</p><h4 id="介绍一下虚函数指针"><a href="#介绍一下虚函数指针" class="headerlink" title="介绍一下虚函数指针"></a>介绍一下虚函数指针</h4><p>在含有虚函数类的对象中，指向虚函数表，在运行时确定</p><h4 id="介绍一下虚函数表"><a href="#介绍一下虚函数表" class="headerlink" title="介绍一下虚函数表"></a>介绍一下虚函数表</h4><p>在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原基类的那个虚函数指针</p><h4 id="介绍一下C-的内存分配和管理"><a href="#介绍一下C-的内存分配和管理" class="headerlink" title="介绍一下C++的内存分配和管理"></a>介绍一下C++的内存分配和管理</h4><p>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定</p><p>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0</p><p>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定</p><p>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca</p><h4 id="malloc和free的底层实现"><a href="#malloc和free的底层实现" class="headerlink" title="malloc和free的底层实现"></a>malloc和free的底层实现</h4><p>先搜索堆中的空闲链表，如果有合适大小，直接分配，否则就向系统重新申请一段内存，用完后标记为空闲状态</p><h4 id="C-数组越界会发生什么"><a href="#C-数组越界会发生什么" class="headerlink" title="C++数组越界会发生什么"></a>C++数组越界会发生什么</h4><p>数组越界会发生覆盖原有的数据，如果比较重要，可能会崩溃，如果不重要，肯就没有明显影响</p><h4 id="介绍一下智能指针"><a href="#介绍一下智能指针" class="headerlink" title="介绍一下智能指针"></a>介绍一下智能指针</h4><p>用来实现内存的自动回收</p><h4 id="智能指针是如何实现的"><a href="#智能指针是如何实现的" class="headerlink" title="智能指针是如何实现的"></a>智能指针是如何实现的</h4><p>RAII技术（资源获取即初始化）</p><h4 id="介绍一下shared-ptr"><a href="#介绍一下shared-ptr" class="headerlink" title="介绍一下shared_ptr"></a>介绍一下shared_ptr</h4><p>shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同内存，每使用一次，计数加一，析构一次计数减一，减为零时删除指向的堆内存</p><p>要注意不能用原始指针初始化多个shared_ptr</p><p>避免循环引用</p><h4 id="介绍一下weak-ptr"><a href="#介绍一下weak-ptr" class="headerlink" title="介绍一下weak_ptr"></a>介绍一下weak_ptr</h4><p>为了配合shared_ptr引入的，不具有普通指针行为，可以观测资源使用情况，use_count()观测引用计数，lock()获得shared_ptr对象</p><h4 id="什么是循环引用"><a href="#什么是循环引用" class="headerlink" title="什么是循环引用"></a>什么是循环引用</h4><p>两个shared_ptr相互引用</p><h4 id="如何解决循环引用"><a href="#如何解决循环引用" class="headerlink" title="如何解决循环引用"></a>如何解决循环引用</h4><p>将一个改为weak_ptr</p><h4 id="auto的用法"><a href="#auto的用法" class="headerlink" title="auto的用法"></a>auto的用法</h4><p>auto x = …；</p><h4 id="delete-this合法吗"><a href="#delete-this合法吗" class="headerlink" title="delete this合法吗"></a>delete this合法吗</h4><p>合法</p><h4 id="delete-this应用场景"><a href="#delete-this应用场景" class="headerlink" title="delete this应用场景"></a>delete this应用场景</h4><p>this对象必须是通过new（不是new[]）分配出来的；必须保证调用delete this的函数是最后一个调用this的函数，delete this 之后不能在使用this；不能delete this多次</p><h4 id="new和delete底层实现"><a href="#new和delete底层实现" class="headerlink" title="new和delete底层实现"></a>new和delete底层实现</h4><p>new 是调用operator new函数申请空间（malloc），在申请空间上执行构造函数构造对象</p><p>delete是在空间上执行析构函数清理对象资源，调用operator delete函数释放空间</p><h4 id="malloc-free和new-delete的区别"><a href="#malloc-free和new-delete的区别" class="headerlink" title="malloc/free和new/delete的区别"></a>malloc/free和new/delete的区别</h4><p>malloc/free是C的库函数，new/delete是C++的运算符，new/delete底层用malloc和free实现，malloc不能自动的调用构造函数和析构函数</p><h4 id="介绍一下模板"><a href="#介绍一下模板" class="headerlink" title="介绍一下模板"></a>介绍一下模板</h4><p>模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><p>通过模板就可以实现定义不同类型的结构和函数</p><h4 id="介绍一下常见的STL及用法"><a href="#介绍一下常见的STL及用法" class="headerlink" title="介绍一下常见的STL及用法"></a>介绍一下常见的STL及用法</h4><p>参考 huihut STL总结</p><p><a href="/STL.md">传送链接</a></p><h4 id="STL迭代器什么时候会失效"><a href="#STL迭代器什么时候会失效" class="headerlink" title="STL迭代器什么时候会失效"></a>STL迭代器什么时候会失效</h4><p>进行插入删除操作时，影响到的迭代器会失效</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++第一次总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://miracle-qsh.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="http://miracle-qsh.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统原理</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-08T11:40:36.900Z</published>
    <updated>2020-04-08T00:47:31.936Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>操作系统原理的总结，结合常见问题</p><a id="more"></a><h4 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h4><p>中断是指计算机运行过程中出现意外情况干预，机器暂停正在运行的程序，转入新程序，处理完后返回被暂停的程序继续执行</p><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><p>外中断（IO），异常，陷入（系统调用）</p><h4 id="什么是用户态"><a href="#什么是用户态" class="headerlink" title="什么是用户态"></a>什么是用户态</h4><p>只能受限的访问内存，且不允许访问外围设备，占有CPU的能力被剥夺，CPU资源可以被其他程序获取</p><h4 id="什么是内核态"><a href="#什么是内核态" class="headerlink" title="什么是内核态"></a>什么是内核态</h4><p>CPU可以访问内存所有数据，包括外围设备</p><h4 id="为什么要有用户态和内核态"><a href="#为什么要有用户态和内核态" class="headerlink" title="为什么要有用户态和内核态"></a>为什么要有用户态和内核态</h4><p>需要限制不同程序之间的访问能力</p><h4 id="如何从用户态进入内核态"><a href="#如何从用户态进入内核态" class="headerlink" title="如何从用户态进入内核态"></a>如何从用户态进入内核态</h4><p>系统调用、中断、异常</p><h4 id="介绍一下缓存"><a href="#介绍一下缓存" class="headerlink" title="介绍一下缓存"></a>介绍一下缓存</h4><p>通过将最近使用的资源存储到缓存中，实现资源的快速读取</p><h4 id="什么是缓存溢出"><a href="#什么是缓存溢出" class="headerlink" title="什么是缓存溢出"></a>什么是缓存溢出</h4><p>超出常规长度的字符填满一个域</p><h4 id="介绍一下进程与线程的区别以及使用场景"><a href="#介绍一下进程与线程的区别以及使用场景" class="headerlink" title="介绍一下进程与线程的区别以及使用场景"></a>介绍一下进程与线程的区别以及使用场景</h4><p>进程是资源调度的基本单位，线程是独立运行的基本单位</p><p>进程有资源，线程没有</p><p>进程开销大，线程开销小</p><p>线程可以直接读取同一进程的数据，进程通信需要IPC</p><p>需要安全稳定时用进程，等待慢速IO时交给线程，接着做其他事情</p><h4 id="进程状态有哪些"><a href="#进程状态有哪些" class="headerlink" title="进程状态有哪些"></a>进程状态有哪些</h4><p>执行状态，阻塞状态，就绪状态</p><h4 id="进程调度算法的特点"><a href="#进程调度算法的特点" class="headerlink" title="进程调度算法的特点"></a>进程调度算法的特点</h4><p>先来先服务（FCFS）短作业优先（SJF）最短剩余时间优先（SRTF）时间片轮转，优先级调度，多级反馈队列，重要进程立刻响应</p><h4 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h4><p>C++11引入<thread>，通过std::thread obj(函数指针/函数对象)实现多线程</p><h4 id="介绍一下协程"><a href="#介绍一下协程" class="headerlink" title="介绍一下协程"></a>介绍一下协程</h4><p>协程比线程更轻量，本质是单线程，一个线程可以拥有多个协程</p><h4 id="协程的作用"><a href="#协程的作用" class="headerlink" title="协程的作用"></a>协程的作用</h4><p>协程不被操作系统内核管理，完全由程序控制（用户态），开销远小于线程</p><h4 id="协程的缺点"><a href="#协程的缺点" class="headerlink" title="协程的缺点"></a>协程的缺点</h4><p>本质是单线程，进行阻塞操作时会阻塞整个程序</p><h4 id="进程同步的机制"><a href="#进程同步的机制" class="headerlink" title="进程同步的机制"></a>进程同步的机制</h4><p>临界区、同步与互斥、信号量、管程</p><h4 id="信号与信号量的区别"><a href="#信号与信号量的区别" class="headerlink" title="信号与信号量的区别"></a>信号与信号量的区别</h4><p>信号是处理进程间异步通信的</p><p>信号量是处理同步通信的</p><h4 id="生产者-消费者实现"><a href="#生产者-消费者实现" class="headerlink" title="生产者-消费者实现"></a>生产者-消费者实现</h4><p>队列不满时生产者可投放，队列不为空时消费者可取出</p><h4 id="读者写者实现"><a href="#读者写者实现" class="headerlink" title="读者写者实现"></a>读者写者实现</h4><p>允许多进程同时读，但不允许读和写，写和写同时发生</p><h4 id="哲学家进餐实现"><a href="#哲学家进餐实现" class="headerlink" title="哲学家进餐实现"></a>哲学家进餐实现</h4><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子</p><p>必须同时拿起左右两根筷子，两个邻居都不进餐时才可进餐</p><h4 id="进程通信的方式及特点、应用场景"><a href="#进程通信的方式及特点、应用场景" class="headerlink" title="进程通信的方式及特点、应用场景"></a>进程通信的方式及特点、应用场景</h4><p>管道（父子，半双工），命名管道（去除父子限制），消息队列（避免同步阻塞问题，有选择接收），信号量，共享存储，套接字</p><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4><p>互斥、占有等待、不可抢占、环路等待</p><h4 id="解决死锁的策"><a href="#解决死锁的策" class="headerlink" title="解决死锁的策"></a>解决死锁的策</h4><p>死锁检查与回复，死锁预防，死锁避免</p><h4 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h4><p>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><h4 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h4><p>扩充内存</p><h4 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h4><p>分页系统+页面置换算法</p><h4 id="页面置换算法原理"><a href="#页面置换算法原理" class="headerlink" title="页面置换算法原理"></a>页面置换算法原理</h4><p>最佳（OPT，最长时间未使用），LRU（最近最久未使用）时钟（clock）</p><h4 id="什么是分页管理"><a href="#什么是分页管理" class="headerlink" title="什么是分页管理"></a>什么是分页管理</h4><p>将地址空间分成固定大小的页，每一页与内存映射</p><h4 id="什么是分段管理"><a href="#什么是分段管理" class="headerlink" title="什么是分段管理"></a>什么是分段管理</h4><p>分段，每段一个独立地址空间，段长可变</p><h4 id="介绍一下段页式"><a href="#介绍一下段页式" class="headerlink" title="介绍一下段页式"></a>介绍一下段页式</h4><p>分段，每一段分页</p><h4 id="分页与分段的区别"><a href="#分页与分段的区别" class="headerlink" title="分页与分段的区别"></a>分页与分段的区别</h4><p>分页透明，分段需要显示划分段的大小</p><p>分页是一维地址，分段是二维地址</p><p>页的大小不可变，段的大小可变</p><p>分页是为了实现虚拟内存，分段是为了是程序和数据逻辑上独立</p><h4 id="静态链接的不足"><a href="#静态链接的不足" class="headerlink" title="静态链接的不足"></a>静态链接的不足</h4><h4 id="动态链接的特点"><a href="#动态链接的特点" class="headerlink" title="动态链接的特点"></a>动态链接的特点</h4><h4 id="向操作系统申请4G连续空间能分配吗"><a href="#向操作系统申请4G连续空间能分配吗" class="headerlink" title="向操作系统申请4G连续空间能分配吗"></a>向操作系统申请4G连续空间能分配吗</h4><p>不能，正常32位字体，一个进程的虚拟地址空间就是4G，栈，堆，数据段，代码段公用这4G</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统原理的总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://miracle-qsh.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://miracle-qsh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-03-08T11:37:47.169Z</published>
    <updated>2020-04-08T00:48:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机网络的总结，结合常见问题</p><a id="more"></a><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><p>物理层、链路层、网络层、传输层、应用层、会话层、表示层</p><h4 id="各层的作用"><a href="#各层的作用" class="headerlink" title="各层的作用"></a>各层的作用</h4><p>应用层：为应用程序提供数据传输服务</p><p>传输层：为进程提供数据传输服务</p><p>网络层：为主机提供数据传输服务</p><p>链路层：为同一链路主机提供数据传输服务</p><p>物理层：考虑怎样传输比特流</p><h4 id="每一层有哪些协议，各自有什么作用"><a href="#每一层有哪些协议，各自有什么作用" class="headerlink" title="每一层有哪些协议，各自有什么作用"></a>每一层有哪些协议，各自有什么作用</h4><p>应用层：HTTP协议（请求响应协议）DNS协议（域名解析）</p><p>传输层：TCP/UDP协议（传输控制协议）</p><p>网络层：ARP协议（MAC地址解析）IP协议（网络之间通信）ICMP协议（传输控制报文）</p><p>链路层：PPP协议（点对点传输）</p><h4 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h4><p>网络接口层、IP层、TCP/UDP层、应用层</p><h4 id="TCP-IP协议的特点"><a href="#TCP-IP协议的特点" class="headerlink" title="TCP/IP协议的特点"></a>TCP/IP协议的特点</h4><p>完全开发、独立于网络硬件系统、网络地址统一分配、高层协议标准化</p><h4 id="什么是以太网，它有什么特点"><a href="#什么是以太网，它有什么特点" class="headerlink" title="什么是以太网，它有什么特点"></a>什么是以太网，它有什么特点</h4><p>以太网是一种星型拓扑结构的局域网</p><h4 id="MAC帧的结构"><a href="#MAC帧的结构" class="headerlink" title="MAC帧的结构"></a>MAC帧的结构</h4><p>目的地址、源地址、类型（上层协议）、数据（46-1500）、FCS（帧检验序列，CRC方法）</p><h4 id="集线器、交换机、路由器的作用，已经它们工作在哪一层"><a href="#集线器、交换机、路由器的作用，已经它们工作在哪一层" class="headerlink" title="集线器、交换机、路由器的作用，已经它们工作在哪一层"></a>集线器、交换机、路由器的作用，已经它们工作在哪一层</h4><p>集线器提供各种物理接口，工作在物理层</p><p>交换机提供数据交互功能，工作在链路层</p><p>路由器起寻找、导向作用，工作在网络层</p><h4 id="IP数据报常见字段的作用"><a href="#IP数据报常见字段的作用" class="headerlink" title="IP数据报常见字段的作用"></a>IP数据报常见字段的作用</h4><p>版本：4和6两种</p><p>首部长度</p><p>区分服务（一般不使用）</p><p>总长度：首部长度+数据长度</p><p>生存时间（TTL）：防止绕圈子</p><p>协议：携带数据应该交给哪个协议</p><p>首部检验和</p><p>标识：相同数据不同分片拥有相同标识</p><p>片偏移：数据偏移量</p><h4 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h4><p>实现由IP地址得到MAC地址</p><h4 id="维护ARP缓存的过程"><a href="#维护ARP缓存的过程" class="headerlink" title="维护ARP缓存的过程"></a>维护ARP缓存的过程</h4><p>从ARP高速缓存中查找IP，如果有，直接使用</p><p>如果没有，广播ARP请求分组</p><p>目的主机收到请求分组后向源主机发送IP到MAC的映射，同时储存源主机IP到MAC的映射</p><p>源主机收到响应分组后存储IP到MAC的映射</p><h4 id="介绍一下ICMP协议"><a href="#介绍一下ICMP协议" class="headerlink" title="介绍一下ICMP协议"></a>介绍一下ICMP协议</h4><p>控制报文协议，用于在IP主机、路由器之间传递控制信息（主机是否可达，网络通不通）</p><h4 id="ICMP报文种类及作用"><a href="#ICMP报文种类及作用" class="headerlink" title="ICMP报文种类及作用"></a>ICMP报文种类及作用</h4><p>差错报告报文（终点不可达3，超时11，参数问题12，改变路由5）询问报文（回送请求和回答Echo8/0，时间戳请求或回答Timestamp13/14）</p><h4 id="ICMP数据报与IP数据报的关系"><a href="#ICMP数据报与IP数据报的关系" class="headerlink" title="ICMP数据报与IP数据报的关系"></a>ICMP数据报与IP数据报的关系</h4><p>ICMP是为了更有效的转发IP数据报和提高交付成功的机会的协议，封装在IP数据报中，不属于高层协议</p><h4 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h4><p>无连接，尽最大可能交付（不可靠），没有拥塞控制，面向报文，提供一对一、一对多、多对一、多对多交互通信（半双工）</p><h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><p>伪首部（为了计算检验和临时添加）源端口、目的端口、长度、检验和</p><h4 id="TCP的特点"><a href="#TCP的特点" class="headerlink" title="TCP的特点"></a>TCP的特点</h4><p>面向连接，可靠传输，有流量控制，拥塞控制，全双工，面向字节流，只能一对一</p><h4 id="TCP的首部格式"><a href="#TCP的首部格式" class="headerlink" title="TCP的首部格式"></a>TCP的首部格式</h4><p>源端口，目的端口，序列号，确认号，数据偏移（首部长度），URG（紧急指针），PSH（推送），RST（重新连接），SYN（同步），FIN（终止），ACK（确认），窗口（设置窗口大小）</p><h4 id="UDP与TCP的区别"><a href="#UDP与TCP的区别" class="headerlink" title="UDP与TCP的区别"></a>UDP与TCP的区别</h4><p>UDP无连接，TCP面向连接</p><p>UDP不可靠，TCP可靠</p><p>UDP没有拥塞控制，TCP有拥塞控制</p><p>UDP面向报文，TCP面向字节流</p><p>UDP支持一对一，一对多，多对一，多对多，TCP只支持一对一</p><p>UDP开销小，TCP开销大</p><h4 id="使用UDP和TCP的协议有哪些"><a href="#使用UDP和TCP的协议有哪些" class="headerlink" title="使用UDP和TCP的协议有哪些"></a>使用UDP和TCP的协议有哪些</h4><p>UDP：DNS、RIP（动态路由选择协议）</p><p>TCP：SMTP、TELNET、HTTP、FTP</p><h4 id="如何绑定TCP-UDP端口"><a href="#如何绑定TCP-UDP端口" class="headerlink" title="如何绑定TCP/UDP端口"></a>如何绑定TCP/UDP端口</h4><p>使用bind函数</p><h4 id="介绍一下host"><a href="#介绍一下host" class="headerlink" title="介绍一下host"></a>介绍一下host</h4><p>host是指与internet以TCP/IP协议项链的任何计算机</p><h4 id="介绍一下hosts"><a href="#介绍一下hosts" class="headerlink" title="介绍一下hosts"></a>介绍一下hosts</h4><p>hosts是一个没有拓展名的系统文件，作用就是把常用的网址域名与对应的IP地址建立一个关联数据库</p><h4 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h4><p>SYN=1,seq=x</p><p>SYN=1,ACK=1,seq=y,ack=x+1</p><p>ACK=1,seq=x+1,ack=y+1</p><h4 id="三次握手原因"><a href="#三次握手原因" class="headerlink" title="三次握手原因"></a>三次握手原因</h4><p>第三次握手时为了防止失效的连接请求到达服务器，让服务器错误打开连接</p><h4 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h4><p>FIN=1,seq=u</p><p>ACK=1,seq=v,ack=u+1</p><p>FIN=1=1,ACK=1,seq=w,ack=u+1</p><p>ACK=1,seq=u+1,ack=w+1</p><h4 id="四次挥手原因"><a href="#四次挥手原因" class="headerlink" title="四次挥手原因"></a>四次挥手原因</h4><p>客户端发送FIN之后进入CLOSE-WAIT状态，为了让服务端发送未传送完毕的数据</p><h4 id="TIME-WAIT的作用"><a href="#TIME-WAIT的作用" class="headerlink" title="TIME_WAIT的作用"></a>TIME_WAIT的作用</h4><p>客户端接收到服务端FIN后，没有立即结束，而是等待2MSL的时间，确保最后一个报文能够到达，让本连接发送的报文都从网络中消失</p><h4 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h4><p>超时重传</p><h4 id="设计可靠的UDP协议"><a href="#设计可靠的UDP协议" class="headerlink" title="设计可靠的UDP协议"></a>设计可靠的UDP协议</h4><p>等待一段时间之后如果没收到响应，就重新传输报文</p><h4 id="TCP拥塞控制的原理"><a href="#TCP拥塞控制的原理" class="headerlink" title="TCP拥塞控制的原理"></a>TCP拥塞控制的原理</h4><p>慢开始，拥塞避免，快重传，快恢复</p><h4 id="DNS端口号，使用什么协议"><a href="#DNS端口号，使用什么协议" class="headerlink" title="DNS端口号，使用什么协议"></a>DNS端口号，使用什么协议</h4><p>53，通常使用UDP</p><h4 id="DNS怎么减少传输时间"><a href="#DNS怎么减少传输时间" class="headerlink" title="DNS怎么减少传输时间"></a>DNS怎么减少传输时间</h4><p>更换DNS提供商，修改DNS缓存是生存周期，使用CDN</p><h4 id="DNS协议原理"><a href="#DNS协议原理" class="headerlink" title="DNS协议原理"></a>DNS协议原理</h4><p>ARP协议广播解析MAC地址</p><p>发送DNS查询报文，经网关后路由转发，到达DNS服务器后查询IP地址，并原路返回</p><h4 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h4><p>CDN是构建在现有网络上的智能虚拟网络，通过部署在各地的边缘服务器，使用户九讲获取资源，降低网络拥塞</p><h4 id="介绍一下缓存"><a href="#介绍一下缓存" class="headerlink" title="介绍一下缓存"></a>介绍一下缓存</h4><p>位于内存中，用于缓解服务器压力，降低客户端获取资源的延迟</p><h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>将一个任务分摊到多个操作单元上进行</p><h4 id="GET与POST区别"><a href="#GET与POST区别" class="headerlink" title="GET与POST区别"></a>GET与POST区别</h4><p>GET用于获取资源，POST用于传输实体主体</p><p>GET参数传递在URL中，只支持ASCII码，POST在实体主体中</p><p>GET安全，POST不安全（改变服务器数据）</p><p>GET是幂等的，POST是不幂等的</p><p>GET可缓存，POST大多数情况下不可缓存</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>100目前很正常，200成功，204成功但响应不包含主体，206范围请求，301永久重定向，302临时重定向，400报文语法错误，401认证失败，403请求被拒绝，404页面丢失，500执行请求时发生错误，503无法处理请求</p><h4 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h4><p>会话状态管理，个性化设置，浏览器行为跟踪</p><h4 id="Cookie是怎样被设置到浏览器的"><a href="#Cookie是怎样被设置到浏览器的" class="headerlink" title="Cookie是怎样被设置到浏览器的"></a>Cookie是怎样被设置到浏览器的</h4><p>服务器发送响应报文包含Set-Cookie首部字段，客户端得到响应报文后将Cookie内容保存到浏览器</p><h4 id="Cookie和Session的比较"><a href="#Cookie和Session的比较" class="headerlink" title="Cookie和Session的比较"></a>Cookie和Session的比较</h4><p>Cookie存储在浏览器，Session存储在服务器</p><p>Cookie限制了数据量（4KB），Session不限量</p><p>Cookie不安全，Session安全</p><p>Cookie可以设置生存周期，Session不行</p><p>Cookie开销小，Session开销大</p><h4 id="介绍一下缓存的Cache-Control字段"><a href="#介绍一下缓存的Cache-Control字段" class="headerlink" title="介绍一下缓存的Cache-Control字段"></a>介绍一下缓存的Cache-Control字段</h4><h4 id="Expires和max-age区别"><a href="#Expires和max-age区别" class="headerlink" title="Expires和max-age区别"></a>Expires和max-age区别</h4><p>Expries：绝对时间，max-age：相对时间</p><h4 id="长连接与短连接的原理及应用场景"><a href="#长连接与短连接的原理及应用场景" class="headerlink" title="长连接与短连接的原理及应用场景"></a>长连接与短连接的原理及应用场景</h4><p>短连接：一次HTTP通信建立一次TCP连接，应用于用户无需频繁操作，不需要一直获取服务端反馈情况</p><p>长连接：建立一次TCP连接，进行多次HTTP通信，应用于操作频繁，点对点通信，而且连接次数不能太多的情况</p><h4 id="介绍一下流水线"><a href="#介绍一下流水线" class="headerlink" title="介绍一下流水线"></a>介绍一下流水线</h4><p>在同一条长连接上连续发出请求，而不用等待响应返回</p><h4 id="HTTP存在的安全问题"><a href="#HTTP存在的安全问题" class="headerlink" title="HTTP存在的安全问题"></a>HTTP存在的安全问题</h4><p>使用明文通信，可能被窃听</p><p>不验证身份，可能遭遇伪装</p><p>无法验证报文完整性，报文可能被篡改</p><h4 id="介绍一下HTTPS"><a href="#介绍一下HTTPS" class="headerlink" title="介绍一下HTTPS"></a>介绍一下HTTPS</h4><p>HTTP+SSL隧道技术，端口443</p><h4 id="HTTPS特点"><a href="#HTTPS特点" class="headerlink" title="HTTPS特点"></a>HTTPS特点</h4><p>加密，认证，完整性保护</p><h4 id="HTTPS加密过程"><a href="#HTTPS加密过程" class="headerlink" title="HTTPS加密过程"></a>HTTPS加密过程</h4><p>服务端发送公钥给客户端，客户端生成一个随机数，产生密钥，使用公钥进行加密，将加密后的密文传输给服务端，服务端使用私钥进行解密。客户端与服务端使用密钥进行通信</p><h4 id="什么是数字签名，有什么作用"><a href="#什么是数字签名，有什么作用" class="headerlink" title="什么是数字签名，有什么作用"></a>什么是数字签名，有什么作用</h4><p>服务端运营人员向CA提出公钥申请，CA对公钥添加数字签名，作用时完成身份认证</p><h4 id="HTTPS认证过程"><a href="#HTTPS认证过程" class="headerlink" title="HTTPS认证过程"></a>HTTPS认证过程</h4><p>服务端发送证书，客户端使用数字签名进行认证</p><h4 id="介绍一下HTTPS的完整性保护"><a href="#介绍一下HTTPS的完整性保护" class="headerlink" title="介绍一下HTTPS的完整性保护"></a>介绍一下HTTPS的完整性保护</h4><p>认证和加密机制保证了HTTPS的完整性保护的特点</p><h4 id="HTTP1-x的缺陷"><a href="#HTTP1-x的缺陷" class="headerlink" title="HTTP1.x的缺陷"></a>HTTP1.x的缺陷</h4><p>客户端需要使用多连接才能实现并发和减少延迟</p><p>不会压缩请求和响应首部</p><p>不支持有效的资源优先级</p><h4 id="HTTP2的特点"><a href="#HTTP2的特点" class="headerlink" title="HTTP2的特点"></a>HTTP2的特点</h4><p>二进制分帧层、服务端推送、首部压缩</p><h4 id="HTTP1-1的新特性"><a href="#HTTP1-1的新特性" class="headerlink" title="HTTP1.1的新特性"></a>HTTP1.1的新特性</h4><p>默认长连接、支持流水线、支持多个TCP连接，新增状态码100，新增max-age</p><h4 id="HTTP与FTP比较"><a href="#HTTP与FTP比较" class="headerlink" title="HTTP与FTP比较"></a>HTTP与FTP比较</h4><p>HTTP访问网页，FTP传输文件</p><p>HTTP一个连接，FTP两个连接</p><p>HTTP端口80，FTP端口20/21（21控制）</p><p>HTTP传输文件小，FTP文件大</p><p>HTTP无法验证，FTP有验证</p><h4 id="浏览器输入一个url后发生了哪些"><a href="#浏览器输入一个url后发生了哪些" class="headerlink" title="浏览器输入一个url后发生了哪些"></a>浏览器输入一个url后发生了哪些</h4><p>ARP协议MAC地址解析，DNS域名解析，建立TCP连接，发送HTTP请求，响应，渲染</p><h4 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h4><p>利用网页开发留下的漏洞，注入恶意指令到网页</p><h4 id="输入一个url，如何改变成HTTPS，怎么确定用HTTP还是HTTPS"><a href="#输入一个url，如何改变成HTTPS，怎么确定用HTTP还是HTTPS" class="headerlink" title="输入一个url，如何改变成HTTPS，怎么确定用HTTP还是HTTPS"></a>输入一个url，如何改变成HTTPS，怎么确定用HTTP还是HTTPS</h4><p>服务器监听HTTP80端口，如果服务端购买认证证书，由302重定向到HTTPS</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计算机网络的总结，结合常见问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://miracle-qsh.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://miracle-qsh.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://miracle-qsh.github.io/2020/03/08/Linux/"/>
    <id>http://miracle-qsh.github.io/2020/03/08/Linux/</id>
    <published>2020-03-08T10:58:44.027Z</published>
    <updated>2020-04-08T00:48:42.797Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux的总结</p><a id="more"></a><h2 id="常用操作及概念"><a href="#常用操作及概念" class="headerlink" title="常用操作及概念"></a>常用操作及概念</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>Tab：命令和文件名补全</li><li>Ctrl+C：中断正在运行的程序</li><li>Ctrl+D：结束键盘输入（EOF）</li></ul><h3 id="求助"><a href="#求助" class="headerlink" title="求助"></a>求助</h3><h4 id="–help"><a href="#–help" class="headerlink" title="–help"></a>–help</h4><p>指令的基本用法与选项介绍</p><h4 id="man"><a href="#man" class="headerlink" title="man"></a>man</h4><p>将指令的具体信息显示出来</p><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>与man类似，做了分页处理</p><h4 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h4><p>/usr/share/doc存放着软件的一整套说明文件</p><h3 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h3><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>查看在线用户</p><h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><p>内存磁盘同步操作</p><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>-k 不会关机，只发送警告</p><p>-r  将系统服务停掉后重启</p><p>-h  将系统服务停掉后关机</p><p>-c  取消正在进行的shutdown</p><h3 id="PATH"><a href="#PATH" class="headerlink" title="PATH"></a>PATH</h3><p>可以在环境变量中声明可执行文件的路径，路径间以：分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;sbin:&#x2F;home&#x2F;dmtsai&#x2F;.local&#x2F;bin:&#x2F;home&#x2F;dmtsai&#x2F;bin</span></pre></td></tr></table></figure><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>sudo允许一般用户使用root可执行的命令</p><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><ul><li>RPM依赖管理和软件升级</li><li>DPKG与RPM相似</li></ul><h3 id="VIM三个模式"><a href="#VIM三个模式" class="headerlink" title="VIM三个模式"></a>VIM三个模式</h3><ul><li>一般指令模式：VIM默认模式，可用游标查看内容</li><li>编辑模式：按下i键后进入，可对文本进行编辑</li><li>指令列模式：按下:键进入，用于保存退出等操作</li></ul><p>在指令列模式下，有以下命令用于离开或者保存文件</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>写入磁盘</td></tr><tr><td>:w!</td><td>当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td></tr><tr><td>:q</td><td>离开</td></tr><tr><td>:q!</td><td>强制离开不保存</td></tr><tr><td>:wq</td><td>写入磁盘后离开</td></tr><tr><td>:wq!</td><td>强制写入磁盘后离开</td></tr></tbody></table><h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><h3 id="磁盘接口"><a href="#磁盘接口" class="headerlink" title="磁盘接口"></a>磁盘接口</h3><ul><li>IDE</li><li>SATA</li><li>SCSI</li><li>SAS</li></ul><h3 id="磁盘的文件名"><a href="#磁盘的文件名" class="headerlink" title="磁盘的文件名"></a>磁盘的文件名</h3><p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p><ul><li>IDE 磁盘：/dev/hd[a-d]</li><li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li></ul><p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><h3 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h3><h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p><p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p><p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p><h4 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h4><p>扇区是磁盘的最小存储单位，旧磁盘的扇区大小通常为 512 bytes，而最新的磁盘支持 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p><p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p><p>GPT 没有扩展分区概念，都是主分区，每个 LBA 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p><p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。</p><h3 id="开机检测程序"><a href="#开机检测程序" class="headerlink" title="开机检测程序"></a>开机检测程序</h3><ul><li>BIOS：不可以读取GPT分区表</li><li>UEFI：可用读取GPT分区表</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="分区与文件系统"><a href="#分区与文件系统" class="headerlink" title="分区与文件系统"></a>分区与文件系统</h3><p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>inode：一个文件占有一个inode，记录文件属性，同时记录此文件的内容所在的block编号</li><li>block：记录文件内容，文件太大时会占用多个block</li><li>superblock：记录文件系统的整体信息，包括inode和block的总量、使用量、剩余量、以及文件系统的格式与相关信息</li><li>block bitmap：记录block是否被使用的位图</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/BSD_disk.png" alt="img"></p><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><ul><li>Ext2文件系统：现在indoe中查找文件内容所在的block，然后把所有block内容读取出来</li><li>FAT文件系统：每个block中存储下一个block的编号</li></ul><h3 id="磁盘碎片"><a href="#磁盘碎片" class="headerlink" title="磁盘碎片"></a>磁盘碎片</h3><p>指一个文件内容所在的block过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>在Ext2文件系统中支持block的大小有1K、2K、4K三种，不同大小限制了单个文件和文件系统的最大大小</p><table><thead><tr><th>大小</th><th>1KB</th><th>2KB</th><th>4KB</th></tr></thead><tbody><tr><td>最大单一文件</td><td>16GB</td><td>256GB</td><td>2TB</td></tr><tr><td>最大文件系统</td><td>2TB</td><td>8TB</td><td>16TB</td></tr></tbody></table><p>一个block只能被一个文件使用，未使用部分直接浪费</p><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>具体信息包含：</p><ul><li>权限</li><li>拥有者与群组</li><li>容量</li><li>建立或状态改变的时间</li><li>最近读取时间</li><li>最近修改时间</li><li>定义文件特性的旗标（flag），如SetUID</li><li>该文件真正内容指向</li></ul><p>inode特点：</p><ul><li>每个indoe大小固定128 bytes</li><li>每个文件只占有一个indoe</li><li>indoe通过间接引用让block记录引用信息（下一个block）</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>建立一个目录时，会分配一个indoe和至少一个block。block记录的内容是目录下所有文件的indoe编号以及文件名</p><p>文件的indoe本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p><p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p><h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3><p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p><ul><li>/ (root, 根目录)</li><li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li><li>/var (variable)：存放系统或程序运行过程中的数据文件。</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/linux-filesystem.png" alt="img"></p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p><p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p><ul><li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li><li>3：链接数</li><li>root：文件拥有者</li><li>root：所属群组</li><li>17：文件大小</li><li>May 6 00:14：文件最后被修改的时间</li><li>.config：文件名</li></ul><p>常见的文件类型及其含义有：</p><ul><li>d：目录</li><li>-：文件</li><li>l：链接文件</li></ul><p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p><p>文件时间有以下三种：</p><ul><li>modification time (mtime)：文件的内容更新就会更新；</li><li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li><li>access time (atime)：读取文件时就会更新。</li></ul><h3 id="文件与目录的基本操作"><a href="#文件与目录的基本操作" class="headerlink" title="文件与目录的基本操作"></a>文件与目录的基本操作</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># ls [-aAdfFhilnrRSt] file|dir</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-a ：列出全部的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-d ：仅列出目录本身</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-l ：以长数据串行列出，包含文件的属性与权限等等数据</span></pre></td></tr></table></figure><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>更换当前目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cd [相对路径或绝对路径]</span></pre></td></tr></table></figure><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>创建目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># mkdir [-mp] 目录名称</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-m ：配置目录权限</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-p ：递归创建目录</span></pre></td></tr></table></figure><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><p>删除目录，目录必须为空。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-p ：递归删除目录</span></pre></td></tr></table></figure><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>更新文件时间或者建立新文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># touch [-acdmt] filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-a ： 更新 atime</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-c ： 更新 ctime，若该文件不存在则不建立新文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-m ： 更新 mtime</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date="日期或时间"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]</span></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>复制文件。如果源文件有两个以上，则目的文件一定要是目录才行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cp [-adfilprsu] source destination</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-a ：相当于 -dr --preserve=all</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-i ：若目标文件已经存在时，在覆盖前会先询问</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-p ：连同文件的属性一起复制过去</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-r ：递归复制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了</span></pre></td></tr></table></figure><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># rm [-fir] 文件或目录</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-r ：递归删除</span></pre></td></tr></table></figure><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>移动文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># mv [-fiu] source destination</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"># mv [options] source1 source2 source3 .... directory</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖</span></pre></td></tr></table></figure><h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># chmod [-R] xyz dirname/filenameCopy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># chmod 754 .bashrcCopy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>也可以使用符号来设定权限。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># chmod [ugoa]  [+-=] [rwx] dirname/filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">- u：拥有者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">- g：所属群组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- o：其他人</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">- a：所有人</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">- +：添加权限</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">- -：移除权限</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">- =：设定权限Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：为 .bashrc 文件的所有用户添加写权限。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># chmod a+w .bashrc</span></pre></td></tr></table></figure><h3 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h3><ul><li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li><li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li></ul><p>可以通过 umask 设置或者查看默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。</p><h3 id="目录的权限"><a href="#目录的权限" class="headerlink" title="目录的权限"></a>目录的权限</h3><p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p><p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="实体链接"><a href="#实体链接" class="headerlink" title="实体链接"></a>实体链接</h4><p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p><p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p><p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p><h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p><p>当源文件被删除了，链接文件就打不开了。</p><p>因为记录的是路径，所以可以为目录建立符号链接。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1e46fd03-0cda-4d60-9b1c-0c256edaf6b2.png" alt="img"></p><h3 id="获取文件内容"><a href="#获取文件内容" class="headerlink" title="获取文件内容"></a>获取文件内容</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>取得文件内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># cat [-AbEnTv] filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-n ：打印出行号，连同空白行也会有行号，-b 不会</span></pre></td></tr></table></figure><h4 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h4><p>是 cat 的反向操作，从最后一行开始打印。</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>和 more 类似，但是多了一个向前翻页的功能。</p><h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>取得文件前几行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># head [-n number] filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-n ：后面接数字，代表显示几行的意思</span></pre></td></tr></table></figure><h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>是 head 的反向操作，只是取得是后几行。</p><h4 id="od"><a href="#od" class="headerlink" title="od"></a>od</h4><p>以字符或者十六进制的形式显示二进制文件。</p><h3 id="指令与文件搜索"><a href="#指令与文件搜索" class="headerlink" title="指令与文件搜索"></a>指令与文件搜索</h3><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>指令搜索。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># which [-a] command</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-a ：将所有指令列出，而不是只列第一个</span></pre></td></tr></table></figure><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># whereis [-bmsu] dirname/filename</span></pre></td></tr></table></figure><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><p>文件搜索。可以用关键字或者正则表达式进行搜索。</p><p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># locate [-ir] keyword</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-r：正则表达式</span></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>文件搜索。可以使用文件的属性和权限进行搜索。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"># find [basedir] [option]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">example: find . -name "shadow*"Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>① 与时间有关的选项</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-mtime  n ：列出在 n 天前的那一天修改过内容的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-newer file ： 列出比 file 更新的文件Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>+4、4 和 -4 的指示的时间范围如下：</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/658fc5e7-79c0-4247-9445-d69bf194c539.png" alt="img"></p><p><strong>② 与文件拥有者和所属群组有关的选项</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-uid n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-gid n</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-user name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-group name</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-nouser ：搜索拥有者不存在 /etc/passwd 的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-nogroup：搜索所属群组不存在于 /etc/group 的文件Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>③ 与文件权限和名称有关的选项</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-name filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-type TYPE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-perm mode  ：搜索权限等于 mode 的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-perm -mode ：搜索权限包含 mode 的文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-perm /mode ：搜索权限包含任一 mode 的文件</span></pre></td></tr></table></figure><h2 id="压缩与打包"><a href="#压缩与打包" class="headerlink" title="压缩与打包"></a>压缩与打包</h2><h3 id="压缩文件名"><a href="#压缩文件名" class="headerlink" title="压缩文件名"></a>压缩文件名</h3><p>Linux 底下有很多压缩文件名，常见的如下：</p><table><thead><tr><th>扩展名</th><th>压缩程序</th></tr></thead><tbody><tr><td>*.Z</td><td>compress</td></tr><tr><td>*.zip</td><td>zip</td></tr><tr><td>*.gz</td><td>gzip</td></tr><tr><td>*.bz2</td><td>bzip2</td></tr><tr><td>*.xz</td><td>xz</td></tr><tr><td>*.tar</td><td>tar 程序打包的数据，没有经过压缩</td></tr><tr><td>*.tar.gz</td><td>tar 程序打包的文件，经过 gzip 的压缩</td></tr><tr><td>*.tar.bz2</td><td>tar 程序打包的文件，经过 bzip2 的压缩</td></tr><tr><td>*.tar.xz</td><td>tar 程序打包的文件，经过 xz 的压缩</td></tr></tbody></table><h3 id="压缩指令"><a href="#压缩指令" class="headerlink" title="压缩指令"></a>压缩指令</h3><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p><p>经过 gzip 压缩过，源文件就不存在了。</p><p>有 9 个不同的压缩等级可以使用。</p><p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ gzip [-cdtv#] filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-c ：将压缩的数据输出到屏幕上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-d ：解压缩</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-t ：检验压缩文件是否出错</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-v ：显示压缩比等信息</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6</span></pre></td></tr></table></figure><h4 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h4><p>提供比 gzip 更高的压缩比。</p><p>查看命令：bzcat、bzmore、bzless、bzgrep。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ bzip2 [-cdkzv#] filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-k ：保留源文件</span></pre></td></tr></table></figure><h4 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h4><p>提供比 bzip2 更佳的压缩比。</p><p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p><p>查看命令：xzcat、xzmore、xzless、xzgrep。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ xz [-dtlkc#] filename</span></pre></td></tr></table></figure><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gzip、bzip2、xz 将打包文件进行压缩。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-z ：使用 zip；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-j ：使用 bzip2；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-J ：使用 xz；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">-c ：新建打包文件；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">-t ：查看打包文件里面有哪些文件；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">-x ：解打包或解压缩的功能；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">-v ：在压缩/解压缩的过程中，显示正在处理的文件名；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">-f : filename：要处理的文件；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">-C 目录 ： 在特定目录解压缩。</span></pre></td></tr></table></figure><table><thead><tr><th>使用方式</th><th>命令</th></tr></thead><tbody><tr><td>打包压缩</td><td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td></tr><tr><td>查 看</td><td>tar -jtv -f filename.tar.bz2</td></tr><tr><td>解压缩</td><td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td></tr></tbody></table><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>命令历史：记录使用过的命令</li><li>命令与文件补全：快捷键：tab</li><li>命名别名：例如 ll 是 ls -al 的别名</li><li>shell scripts</li><li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li></ul><h3 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h3><p>对一个变量赋值直接使用 =。</p><p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p><p>输出变量使用 echo 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ x=abc</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span>Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>变量内容如果有空格，必须使用双引号或者单引号。</p><ul><li>双引号内的特殊字符可以保留原本特性，例如 x=”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；</li><li>单引号内的特殊字符就是特殊字符本身，例如 x=’lang is $LANG’，则 x 的值为 lang is $LANG。</li></ul><p>可以使用 <code>指令</code> 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p><p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p><p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ declare [-aixr] variable</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-a ： 定义为数组类型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-i ： 定义为整数类型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-x ： 定义为环境变量</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-r ： 定义为 readonly 类型Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>使用 [ ] 来对数组进行索引操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ array[1]=a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ array[2]=b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$&#123;array[1]&#125;</span></span></pre></td></tr></table></figure><h3 id="指令搜索顺序"><a href="#指令搜索顺序" class="headerlink" title="指令搜索顺序"></a>指令搜索顺序</h3><ul><li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li><li>由别名找到该指令来执行；</li><li>由 Bash 内置的指令来执行；</li><li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li></ul><h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p><table><thead><tr><th>1</th><th>代码</th><th>运算符</th></tr></thead><tbody><tr><td>标准输入 (stdin)</td><td>0</td><td>&lt; 或 &lt;&lt;</td></tr><tr><td>标准输出 (stdout)</td><td>1</td><td>&gt; 或 &gt;&gt;</td></tr><tr><td>标准错误输出 (stderr)</td><td>2</td><td>2&gt; 或 2&gt;&gt;</td></tr></tbody></table><p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p><p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p><p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span></pre></td></tr></table></figure><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p><p>在命令之间使用 | 分隔各个管道命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ ls -al /etc | less</span></pre></td></tr></table></figure><h3 id="提取指令"><a href="#提取指令" class="headerlink" title="提取指令"></a>提取指令</h3><p>cut 对数据进行切分，取出想要的部分。</p><p>切分过程一行一行地进行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ cut</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-d ：分隔符</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-c ：以字符为单位取出区间Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例 1：last 显示登入者的信息，取出用户名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ last</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">$ last | cut -d ' ' -f 1Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ export</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">declare -x HISTCONTROL="ignoredups"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">declare -x HISTSIZE="1000"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">declare -x HOME="/home/dmtsai"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">declare -x HOSTNAME="study.centos.vbird"</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">.....(其他省略).....</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">$ export | cut -c 12-</span></pre></td></tr></table></figure><h3 id="排序指令"><a href="#排序指令" class="headerlink" title="排序指令"></a>排序指令</h3><p><strong>sort</strong> 用于排序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ sort [-fbMnrtuk] [file or stdin]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-f ：忽略大小写</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-b ：忽略最前面的空格</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-M ：以月份的名字来排序，例如 JAN，DEC</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-n ：使用数字</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">-r ：反向排序</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">-u ：相当于 unique，重复的内容只出现一次</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">-t ：分隔符，默认为 tab</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">-k ：指定排序的区间Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ cat /etc/passwd | sort -t ':' -k 3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">alex:x:1001:1002::/home/alex:/bin/bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">arod:x:1002:1003::/home/arod:/bin/bashCopy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>uniq</strong> 可以将重复的数据只取一个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ uniq [-ic]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-i ：忽略大小写</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-c ：进行计数Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：取得每个人的登录总次数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ last | cut -d ' ' -f 1 | sort | uniq -c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">6 (unknown</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">47 dmtsai</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">4 reboot</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">7 root</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">1 wtmp</span></pre></td></tr></table></figure><h3 id="双向输出重定向"><a href="#双向输出重定向" class="headerlink" title="双向输出重定向"></a>双向输出重定向</h3><p>输出重定向会将输出内容重定向到文件中，而 <strong>tee</strong> 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ tee [-a] file</span></pre></td></tr></table></figure><h3 id="字符转换指令"><a href="#字符转换指令" class="headerlink" title="字符转换指令"></a>字符转换指令</h3><p><strong>tr</strong> 用来删除一行中的字符，或者对字符进行替换。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ tr [-ds] SET1 ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-d ： 删除行中 SET1 这个字符串Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例，将 last 输出的信息所有小写转换为大写。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ last | tr '[a-z]' '[A-Z]'Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>col</strong> 将 tab 字符转为空格字符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ col [-xb]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-x ： 将 tab 键转换成对等的空格键Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>expand</strong> 将 tab 转换一定数量的空格，默认是 8 个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ expand [-t] file</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-t ：tab 转为空格的数量Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>join</strong> 将有相同数据的那一行合并在一起。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ join [-ti12] file1 file2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-t ：分隔符，默认为空格</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-i ：忽略大小写的差异</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-1 ：第一个文件所用的比较字段</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-2 ：第二个文件所用的比较字段Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p><strong>paste</strong> 直接将两行粘贴在一起。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ paste [-d] file1 file2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-d ：分隔符，默认为 tab</span></pre></td></tr></table></figure><h3 id="分区指令"><a href="#分区指令" class="headerlink" title="分区指令"></a>分区指令</h3><p><strong>split</strong> 将一个文件划分成多个文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ split [-bl] file PREFIX</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-b ：以大小来进行分区，可加单位，例如 b, k, m 等</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-l ：以行数来进行分区。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">- PREFIX ：分区文件的前导名称</span></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ grep [-acinv] [--color=auto] 搜寻字符串 filename</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">-c ： 统计匹配到行的个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">-i ： 忽略大小写</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">-n ： 输出行号</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">--color=auto ：找到的关键字加颜色显示Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：把含有 the 字符串的行提取出来（注意默认会有 –color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ grep -n 'the' regular_express.txt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">8:I can't finish the test.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">12:the symbol '*' is represented as start.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">15:You are the best is mean you are the no. 1.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">16:The world Happy is the same with "glad".</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">18:google is the best tools for search keywordCopy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：正则表达式 a{m,n} 用来匹配字符 a m~n 次，这里需要将 { 和 } 进行转义，因为它们在 shell 是有特殊意义的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ grep -n 'a\&#123;2,5\&#125;' regular_express.txt</span></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    DmTsai    80    60    92    77.33</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">     VBird    75    55    80    70.00</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">       Ken    60    90    70    73.33</span></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>是由 Alfred Aho，Peter Weinberger 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p><p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p><p>示例：取出最近五个登录用户的用户名和 IP。首先用 last -n 5 取出用最近五个登录用户的所有信息，可以看到用户名和 IP 分别在第 1 列和第 3 列，我们用 $1 和 $3 就能取出这两个字段，然后用 print 进行打印。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ last -n 5</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)Copy to clipboardErrorCopied</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">$ last -n 5 | awk '&#123;print $1 "\t" $3&#125;'Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ awk '条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...' filenameCopy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;passwd | awk &#39;BEGIN &#123;FS&#x3D;&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\t &quot; $3&#125;&#39;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">root 0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">bin 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">daemon 2Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>awk 变量：</p><table><thead><tr><th>变量名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NF</td><td>每一行拥有的字段总数</td></tr><tr><td>NR</td><td>目前所处理的是第几行数据</td></tr><tr><td>FS</td><td>目前的分隔字符，默认是空格键</td></tr></tbody></table><p>示例：显示正在处理的行号以及每一行有多少字段</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ last -n 5 | awk '&#123;print $1 "\t lines: " NR "\t columns: " NF&#125;'</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dmtsai lines: 1 columns: 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dmtsai lines: 2 columns: 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">dmtsai lines: 3 columns: 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">dmtsai lines: 4 columns: 10</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">dmtsai lines: 5 columns: 9</span></pre></td></tr></table></figure><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>查看某个时间点的进程信息。</p><p>示例：查看自己的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps -lCopy to clipboardErrorCopied</span></span></pre></td></tr></table></figure><p>示例：查看系统所有进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps auxCopy to clipboardErrorCopied</span></span></pre></td></tr></table></figure><p>示例：查看特定的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># ps aux | grep threadx</span></span></pre></td></tr></table></figure><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p>查看进程树。</p><p>示例：查看所有进程树</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># pstree -A</span></span></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>实时显示进程信息。</p><p>示例：两秒钟刷新一次</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># top -d 2</span></span></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>查看占用端口的进程</p><p>示例：查看特定端口的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -anp | grep port</span></span></pre></td></tr></table></figure><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>R</td><td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。</td></tr><tr><td>D</td><td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。</td></tr><tr><td>S</td><td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。</td></tr><tr><td>Z</td><td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。</td></tr><tr><td>T</td><td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td></tr></tbody></table><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2bab4127-3e7d-48cc-914e-436be859fb05.png" alt="img"></p><h3 id="SIGCHLD"><a href="#SIGCHLD" class="headerlink" title="SIGCHLD"></a>SIGCHLD</h3><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p><ul><li>得到 SIGCHLD 信号；</li><li>waitpid() 或者 wait() 调用会返回。</li></ul><p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p><p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status)Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p><p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p><p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL</p><h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid()"></a>waitpid()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)Copy to clipboardErrorCopied</span></pre></td></tr></table></figure><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p><p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p><p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p><p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p><p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p><p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p><p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://miracle-qsh.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://miracle-qsh.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Linux" scheme="http://miracle-qsh.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统原理</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-07T13:19:59.788Z</published>
    <updated>2020-04-08T00:49:17.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库系统原理的总结</p><a id="more"></a><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务指满足ACID特性的一组操作</p><h3 id="ACID是什么"><a href="#ACID是什么" class="headerlink" title="ACID是什么"></a>ACID是什么</h3><p>原子性、一致性、隔离性、持久性</p><h4 id="什么是原子性"><a href="#什么是原子性" class="headerlink" title="什么是原子性"></a>什么是原子性</h4><p>要么操作全部成功，要么全部失败</p><h4 id="原子性实现原理"><a href="#原子性实现原理" class="headerlink" title="原子性实现原理"></a>原子性实现原理</h4><p>innoDB实现回滚，靠的是undo log，通过undo log做与之前相反的操作实现回滚，保证原子性</p><h4 id="什么是一致性"><a href="#什么是一致性" class="headerlink" title="什么是一致性"></a>什么是一致性</h4><p>所有事务对同一数据的读取结果相同</p><h4 id="一致性实现原理"><a href="#一致性实现原理" class="headerlink" title="一致性实现原理"></a>一致性实现原理</h4><p>原子性、隔离性、持久性以及应用层的保障</p><h4 id="什么是隔离性"><a href="#什么是隔离性" class="headerlink" title="什么是隔离性"></a>什么是隔离性</h4><p>一个事务完成前，对其他事务不可见</p><h4 id="隔离性实现原理"><a href="#隔离性实现原理" class="headerlink" title="隔离性实现原理"></a>隔离性实现原理</h4><p>锁机制和MVCC</p><h4 id="什么是持久性"><a href="#什么是持久性" class="headerlink" title="什么是持久性"></a>什么是持久性</h4><p>一旦事务提交（完成），则所作修改永远保存</p><h4 id="持久性实现原理"><a href="#持久性实现原理" class="headerlink" title="持久性实现原理"></a>持久性实现原理</h4><p>innoDB通过缓存（Buffer Pool，定期刷盘）提高读写数据效率，但MySQL宕机时会导致数据丢失，于是引入redo log，当数据修改时，先在redo log中记录本次操作所有修改，之后修改Buffer Pool数据；事务提交时，会调用fsync接口对redo log进行刷盘，如果宕机，重启时可以读取redo log中的数据，对数据库进行恢复</p><h5 id="redo-log与bin-log的区别"><a href="#redo-log与bin-log的区别" class="headerlink" title="redo log与bin log的区别"></a>redo log与bin log的区别</h5><p>作用不同：redo log保证宕机也不会影响持久性，bin log保证服务器可以基于时间点恢复数据和主从复制</p><p>层次不同：redo log时innoDB存储引擎实现的，bin log时服务器层实现的</p><p>内容不同：redo log是物理日志，内容基于磁盘Page；bin log内容是二进制的</p><p>写入时机不同：bin log在事务提交时写入； redo log写入时间相对多元</p><h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>按照粒度，分为表锁和行锁</p><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>X：写锁（互斥锁）、S：读锁（共享锁）</p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p><p>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><h5 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h5><ul><li>一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁</li><li>二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁</li><li>三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁</li></ul><h5 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h5><p>加索和解锁分两个阶段进行</p><h4 id="隐式与显示锁定"><a href="#隐式与显示锁定" class="headerlink" title="隐式与显示锁定"></a>隐式与显示锁定</h4><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span></pre></td></tr></table></figure><h4 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h4><p>丢失修改、脏读、不可重复读、幻影读</p><h5 id="什么是丢失修改"><a href="#什么是丢失修改" class="headerlink" title="什么是丢失修改"></a>什么是丢失修改</h5><p>A和B对同一数据修改，A改完后B改，A修改被覆盖</p><h5 id="什么是脏读"><a href="#什么是脏读" class="headerlink" title="什么是脏读"></a>什么是脏读</h5><p>A修改数据，B读取该数据，随后A撤销本次修改</p><h5 id="什么是不可重复读"><a href="#什么是不可重复读" class="headerlink" title="什么是不可重复读"></a>什么是不可重复读</h5><p>A读数据，B对该数据进行修改，A再读取该数据</p><h5 id="什么是幻影读"><a href="#什么是幻影读" class="headerlink" title="什么是幻影读"></a>什么是幻影读</h5><p>A读某个范围数据，B在该范围内插入新数据，A再读该范围数据</p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>未提交读、提交读、可重复读、可串行化</p><h5 id="未提交读"><a href="#未提交读" class="headerlink" title="未提交读"></a>未提交读</h5><p>未提交的事务对其他事务也有可见性</p><h5 id="提交读"><a href="#提交读" class="headerlink" title="提交读"></a>提交读</h5><p>一个事务提交前对其他事务不可见</p><h5 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h5><p>保证在同一事务多次读取同一数据结果一致</p><h5 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h5><p>强制事务串行执行</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>同一时刻不同事务读取的版本可能不同</p><h5 id="解决脏读"><a href="#解决脏读" class="headerlink" title="解决脏读"></a>解决脏读</h5><p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201139635-1779107964.png" alt="img"></p><h5 id="解决不可重复读"><a href="#解决不可重复读" class="headerlink" title="解决不可重复读"></a>解决不可重复读</h5><p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201149661-1275460669.png" alt="img"></p><h5 id="解决幻影读"><a href="#解决幻影读" class="headerlink" title="解决幻影读"></a>解决幻影读</h5><p><img src="https://img2018.cnblogs.com/blog/1174710/201901/1174710-20190128201206609-1998192060.png" alt="img"></p><h2 id="范式理论"><a href="#范式理论" class="headerlink" title="范式理论"></a>范式理论</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>A-&gt;B：B依赖A，A决定B</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>属性不可分</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th>Sno</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>课程-2</td><td>95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>学院-1</td><td>院长-1</td></tr><tr><td>学院-2</td><td>院长-2</td></tr></tbody></table><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.cnblogs.com/kismetv/p/10331633.html" target="_blank" rel="noopener">深入学习MySQL事务：ACID特性的实现原理</a></p><p><a href="https://cyc2018.github.io/CS-Notes/#/" target="_blank" rel="noopener">CS-Notes</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库系统原理的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>STL及常用算法</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/STL%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/STL%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-07T09:16:23.224Z</published>
    <updated>2020-03-07T09:17:05.275Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>STL及常用算法的总结</p><a id="more"></a><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    int data;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bool operator &lt; (const node &amp;b)const&#123; &#x2F;&#x2F;重载运算符</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        return data &lt; b.data;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;队列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    queue&lt;node&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;优先队列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    priority_queue&lt;int&gt;qu; &#x2F;&#x2F;从大到小</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qu; &#x2F;&#x2F;从小到大</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    priority_queue&lt;node&gt;qu; &#x2F;&#x2F;结构体</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    qu.push(&#123;1&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    qu.push(&#123;2&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    cout &lt;&lt; qu.top().data &lt;&lt; endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;集合</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    set&lt;int&gt;st;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    st.insert(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    set&lt;int&gt;::iterator it;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    it &#x3D; st.lower_bound(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    st.insert(st.begin(), st.end());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;映射</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    map&lt;int,int&gt;mp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    map&lt;int,int&gt;::iterator it;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    mp[1] &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    it &#x3D; mp.lower_bound(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 10010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">int pre[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int fin(int x)&#123;return x &#x3D;&#x3D; pre[x] ? x : pre[x] &#x3D; fin(pre[x]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int n &#x3D; maxn;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; n; i++)pre[i] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int x &#x3D; fin(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    int y &#x3D; fin(2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    if(x !&#x3D; y)pre[x] &#x3D; y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="搜索-DFS-amp-amp-BFS"><a href="#搜索-DFS-amp-amp-BFS" class="headerlink" title="搜索 DFS &amp;&amp; BFS"></a>搜索 DFS &amp;&amp; BFS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 10010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;mp[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int n, vis[maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">void dfs(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    vis[x] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; mp[x].size(); i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        int v &#x3D; mp[x][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        if(vis[v] &#x3D;&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            dfs(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    vis[x] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">void bfs(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    qu.push(x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    vis[x] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    while(!qu.empty())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        int w &#x3D; qu.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        qu.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 0; i &lt; mp[w].size(); i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            int v &#x3D; mp[w][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            if(vis[v] &#x3D;&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">                qu.push(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                vis[v] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="最短路-Dijstra-amp-amp-Floyd-amp-amp-SPFA"><a href="#最短路-Dijstra-amp-amp-Floyd-amp-amp-SPFA" class="headerlink" title="最短路 Dijstra &amp;&amp; Floyd &amp;&amp; SPFA"></a>最短路 Dijstra &amp;&amp; Floyd &amp;&amp; SPFA</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    mp[1].push_back(2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    mp[2].push_back(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    dfs(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    bfs(1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">#define inf 0x3f3f3f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1010;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">int mp[maxn][maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">int n &#x3D; 3, st &#x3D; 1, ed &#x3D; 3;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">void dij()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    int dis[maxn], vis[maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    vis[st] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    dis[st] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; -1, minn &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            if(dis[j] &lt; minn)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                minn &#x3D; dis[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                u &#x3D; j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        if(u &gt; 0)vis[u] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        else continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            if(vis[j] &#x3D;&#x3D; 0 &amp;&amp; dis[j] &gt; dis[u] + mp[u][j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">                dis[j] &#x3D; dis[u] + mp[u][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">void floyd()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    int i, j, k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    for(k &#x3D; 1; k &lt;&#x3D; n; k++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">            for(j &#x3D; 1; j &lt;&#x3D; n; j++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                if(mp[i][j] &gt; mp[i][k] + mp[k][j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                    mp[i][j] &#x3D; mp[i][k] + mp[k][j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">int spfa()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    int vis[maxn] &#x3D; &#123;0&#125;, dis[maxn], cnt[maxn] &#x3D; &#123;0&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    dis[st] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;qu;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    qu.push(st);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    vis[st] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    cnt[st]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    while(!qu.empty())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">        int w &#x3D; qu.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        qu.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            if(vis[i] &#x3D;&#x3D; 0 &amp;&amp; dis[i] &gt; dis[w] + mp[w][i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">                dis[i] &#x3D; dis[w] + mp[w][i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">                vis[i] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">                qu.push(i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">                cnt[i]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">        vis[w] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    return dis[ed];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    mp[1][2] &#x3D; mp[2][1] &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">    mp[1][3] &#x3D; mp[3][1] &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">    mp[2][3] &#x3D; mp[3][2] &#x3D; 4;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    cout &lt;&lt; spfa();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL及常用算法的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Polya</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/Polya/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/Polya/</id>
    <published>2020-03-07T09:15:41.589Z</published>
    <updated>2020-03-07T09:16:08.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Polya的总结</p><a id="more"></a><h2 id="Step1-Polya-定理"><a href="#Step1-Polya-定理" class="headerlink" title="Step1 - Polya-定理"></a>Step1 - Polya-定理</h2><h3 id="设-G-是-n-个对象的一个置换群-用m种颜色染图这-n-个对象，则不同的染色方案数为："><a href="#设-G-是-n-个对象的一个置换群-用m种颜色染图这-n-个对象，则不同的染色方案数为：" class="headerlink" title="设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为："></a>设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为：</h3><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D248/sign=d4a125768b13632711edc537a98ea056/d62a6059252dd42aed4ab801023b5bb5c8eab8dd.jpg" alt="img"></p><h3 id="其中-G-P1-P2-P3-…-Pg-C-Pk-表示-Pk-的循环节。"><a href="#其中-G-P1-P2-P3-…-Pg-C-Pk-表示-Pk-的循环节。" class="headerlink" title="其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。"></a>其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。</h3><h2 id="Step2-Polya-定理的引入与简单理解"><a href="#Step2-Polya-定理的引入与简单理解" class="headerlink" title="Step2 - Polya-定理的引入与简单理解"></a>Step2 - Polya-定理的引入与简单理解</h2><p>参考博客：<a href="https://blog.csdn.net/lyc1635566ty/article/details/52545355" target="_blank" rel="noopener">https://blog.csdn.net/lyc1635566ty/article/details/52545355</a></p><p>参考视频：<a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+60240013X+sp/about" target="_blank" rel="noopener">学堂在线-组合数学</a></p><h3 id="一、前置知识："><a href="#一、前置知识：" class="headerlink" title="一、前置知识："></a>一、前置知识：</h3><h4 id="1-置换："><a href="#1-置换：" class="headerlink" title="1.置换："></a>1.置换：</h4><p>其实就是集合 G 到 G 的一个双射，例如：</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D151/sign=9fe21a940df3d7ca08f63b73c31ebe3c/ac345982b2b7d0a20b345937caef76094a369a9e.jpg" alt="img"></p><p>也就是说每次变换，1 –&gt; a1，2 –&gt; a2，…，n –&gt; an。</p><h4 id="2-置换的乘法："><a href="#2-置换的乘法：" class="headerlink" title="2.置换的乘法："></a>2.置换的乘法：</h4><p>例如定义 P1, P2两个置换。<img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D135/sign=6490ef9ba08b87d65442af1c32092860/91529822720e0cf3004613510b46f21fbf09aae3.jpg" alt="img"></p><p><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D135/sign=61b8456fe1fe9925cf0c6d5301a95ee4/9e3df8dcd100baa196801a114610b912c9fc2eef.jpg" alt="img"></p><p>定义置换乘法：</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D266/sign=8e8ec5ae5882b2b7a39f3ec207accb0a/f11f3a292df5e0feb6efd4ab5d6034a85fdf72a0.jpg" alt="img"></p><p><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D346/sign=fe3b02fa0d33874498c52978670ed937/b3b7d0a20cf431adc3f01f934a36acaf2edd987d.jpg" alt="img"></p><p>表示先作 P1 的置换，再作 P2 的置换。</p><h4 id="3-Burnside引理"><a href="#3-Burnside引理" class="headerlink" title="3.Burnside引理:"></a>3.Burnside引理:</h4><p>设G={a1,a2,…ag}是目标集[1,n]上的置换群。每个置换都写成不相交循环的乘积。 是在置换ak的作用下不动点的个数，也就是长度为1的循环的个数。通过上述置换的变换操作后可以相等的元素属于同一个等价类。若G将[1,n]划分成l个等价类，则等价类个数为：</p><p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D249/sign=4819311e96eef01f49141fc1d9ff99e0/94cad1c8a786c91783a8da43cb3d70cf3bc75725.jpg" alt="img"></p><h3 id="二、Polya定理的引出："><a href="#二、Polya定理的引出：" class="headerlink" title="二、Polya定理的引出："></a>二、Polya定理的引出：</h3><p>设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为：</p><p><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D248/sign=d4a125768b13632711edc537a98ea056/d62a6059252dd42aed4ab801023b5bb5c8eab8dd.jpg" alt="img"></p><p>其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。</p><h2 id="Step3-Polya-定理的使用"><a href="#Step3-Polya-定理的使用" class="headerlink" title="Step3 - Polya-定理的使用"></a>Step3 - Polya-定理的使用</h2><ol><li>确定置换的个数（旋转角度，翻转）</li><li>确定循环节个数（旋转角度时考虑 gcd，翻转时特殊考虑）</li><li>套用 Polya 公式</li></ol><h2 id="Step4-Polya定理-例题-amp-amp-模板（POJ-1286）"><a href="#Step4-Polya定理-例题-amp-amp-模板（POJ-1286）" class="headerlink" title="Step4 - Polya定理-例题&amp;&amp;模板（POJ 1286）"></a>Step4 - Polya定理-例题&amp;&amp;模板（POJ 1286）</h2><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给你一个长度为 n 的项链（环），着 3 种颜色，问有多少种</p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ol><li>确定置换个数：旋转 (k * 360 / n)° n 种， 对称反转 n 种， 共 2 * n 种</li><li>确定循环节个数，旋转角度 (k * 360 / n)° 循环节为 gcd(n, k)，对称反转分奇数和偶数。</li><li>套用 Polya 公式求解</li></ol><h3 id="代码-模板："><a href="#代码-模板：" class="headerlink" title="代码+模板："></a>代码+模板：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ll n, m, i, j, k;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%lld&quot;, &amp;n) !&#x3D; EOF)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        if(n &#x3D;&#x3D; -1)break;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        if(n &#x3D;&#x3D; 0)&#123;printf(&quot;0\n&quot;);continue;&#125;&#x2F;&#x2F;特判0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        ll ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans +&#x3D; pow(3.0, __gcd(n, i) * 1.0);&#x2F;&#x2F;旋转（i * 360 &#x2F; n）°</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        if(n % 2 &#x3D;&#x3D; 1)&#123;ans +&#x3D; n * pow(3.0, (n + 1) &#x2F; 2);&#125;&#x2F;&#x2F;奇数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        else &#123;ans +&#x3D; n &#x2F; 2 * pow(3.0, n &#x2F; 2) + n &#x2F; 2 * pow(3.0, n &#x2F; 2 + 1);&#125;&#x2F;&#x2F;偶数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        ans &#x2F;&#x3D; (n * 2);&#x2F;&#x2F;除置换个数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%lld\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Polya的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Manacher</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/Manacher/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/Manacher/</id>
    <published>2020-03-07T09:14:34.612Z</published>
    <updated>2020-03-07T09:15:10.442Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Manacher的总结</p><a id="more"></a><h2 id="题目传送门：POJ-3974-Palindrome"><a href="#题目传送门：POJ-3974-Palindrome" class="headerlink" title="题目传送门：POJ-3974 Palindrome"></a>题目传送门：<a href="https://vjudge.net/problem/POJ-3974" target="_blank" rel="noopener">POJ-3974 Palindrome</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求最长回文字串</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>Manacher模板题</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">char a[1000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">char ma[2000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">int mp[2000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    int ca &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%s&quot;, a) !&#x3D; EOF &amp;&amp; strcmp(a, &quot;END&quot;) !&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        int n &#x3D; strlen(a), i, l &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        ma[l++] &#x3D; &#39;$&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        ma[l++] &#x3D; &#39;#&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            ma[l++] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            ma[l++] &#x3D; &#39;#&#39;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        ma[l] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        int mx &#x3D; 0, id &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        int ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 0; i &lt; l; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            mp[i] &#x3D; mx &gt; i ? min(mp[2 * id - i], mx - i):1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            while(ma[i + mp[i]] &#x3D;&#x3D; ma[i - mp[i]])mp[i]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            if(i + mp[i] &gt; mx)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                mx &#x3D; i + mp[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                id &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            ans &#x3D; max(ans, mp[i] - 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;Case %d: %d\n&quot;, ca++, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Manacher的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/KMP/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/KMP/</id>
    <published>2020-03-07T09:13:55.652Z</published>
    <updated>2020-03-07T09:14:17.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>KMP的总结</p><a id="more"></a><h2 id="题目传送门：POJ-2406-Power-Strings"><a href="#题目传送门：POJ-2406-Power-Strings" class="headerlink" title="题目传送门：POJ-2406 Power Strings"></a>题目传送门：<a href="https://cn.vjudge.net/problem/POJ-2406" target="_blank" rel="noopener">POJ-2406 Power Strings</a></h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个字符串，求它的最小循环节</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>最小循环节==len/（len-next[len]）（如果能整除）</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">char a[1000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int nex[1000005];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%s&quot;, a) &amp;&amp; a[0] !&#x3D; &#39;.&#39;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        int len &#x3D; strlen(a);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        int i &#x3D; 0, j &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        nex[0] &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        while(i &lt; len)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            if(j &#x3D;&#x3D; -1 || a[i] &#x3D;&#x3D; a[j])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                nex[++i] &#x3D; ++j;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            else j &#x3D; nex[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        if(len % (len - nex[len]) &#x3D;&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, len &#x2F; (len - nex[len]));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        else printf(&quot;1\n&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KMP的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</id>
    <published>2020-03-07T09:12:52.874Z</published>
    <updated>2020-03-07T09:13:42.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AC自动机的总结</p><a id="more"></a><h2 id="P3808-【模板】AC自动机（简单版）"><a href="#P3808-【模板】AC自动机（简单版）" class="headerlink" title="P3808 【模板】AC自动机（简单版）"></a>P3808 【模板】AC自动机（简单版）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_automaton</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class">&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> c[N][<span class="number">26</span>], val[N], fail[N], cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//c数组记录字典树节点，val数组为该节点是否为字符串结尾（个数）（记录字符串结束的位置）， fail记录失配指针， cnt记录节点标号(对应val)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//cnt作用：模拟动态开点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> *s)</span><span class="comment">//向字典树中插入字符串，s为模式串</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="keyword">int</span> now = <span class="number">0</span>;<span class="comment">//从根节点0开始</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> v = s[i] - <span class="string">'a'</span>;<span class="comment">//获取当前字符的值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(!c[now][v])c[now][v] = ++cnt;<span class="comment">//如果这个节点没开，则开点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            now = c[now][v];<span class="comment">//now移动到新节点，开始匹配下一个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        val[now]++;<span class="comment">//字符串插入完毕后在尾部打标记，val[u]表示以该点结尾的字符串个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span><span class="comment">//获取每个节点的失配指针</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>][i])fail[c[<span class="number">0</span>][i]] = <span class="number">0</span>, q.push(c[<span class="number">0</span>][i]);<span class="comment">//首先将与根节点相连的点入队，即首字母入队，并赋失配指针为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!q.empty())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();<span class="comment">//出队</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(c[u][i])fail[c[u][i]] = c[fail[u]][i], q.push(c[u][i]);<span class="comment">//如果该节点存在，则他的失配指针为它的上一个失配指针处的失配指针，并入队</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> c[u][i] = c[fail[u]][i];<span class="comment">//该点不存在只更新fail指针</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span><span class="comment">//查询文本串中模式串的个数，s为文本串</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="keyword">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;<span class="comment">//ans记录答案（模式串个数）， 从根节点开始</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            now = c[now][s[i] - <span class="string">'a'</span>];<span class="comment">//从当前节点向下走</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t = now; t &amp;&amp; ~val[t]; t = fail[t])ans += val[t], val[t] = <span class="number">-1</span>;<span class="comment">//遍历该节点前失配指针，并统计个数，清楚val（避免重复统计）</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;AC;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> p[<span class="number">1000005</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="built_in">scanf</span>(<span class="string">"%s"</span>, p), AC.ins(p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    AC.build();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = AC.query(p);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AC自动机的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最小费用最大流</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/</id>
    <published>2020-03-07T09:12:10.836Z</published>
    <updated>2020-03-07T09:12:45.062Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最小费用最大流的总结</p><a id="more"></a><h2 id="P4016-负载平衡问题"><a href="#P4016-负载平衡问题" class="headerlink" title="P4016 负载平衡问题"></a>P4016 负载平衡问题</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.org/problem/P4016" target="_blank" rel="noopener">https://www.luogu.org/problem/P4016</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分源点、汇点，源点所有超过均值的点流量为1，费用为0、所有未超过均值的点连汇点流量为1，费用为0、相邻两点连边，流量为INF，费用为1，跑最小费用最大流即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define maxn 2010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define maxm 1200010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define inf 0x3f3f3f3f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">struct Edge&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    int to, nex, cap, flow, cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;edge[maxm];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int head[maxn], tol, pre[maxn], dis[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">bool vis[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">int N;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">void init(int n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    N &#x3D; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    tol &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    memset(head, -1, sizeof(head));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">void addedge(int u, int v, int cap, int cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cap &#x3D; cap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cost &#x3D; cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[u];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    head[u] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; u;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cap &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    edge[tol].cost &#x3D; -cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[v];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    head[v] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">bool spfa(int s, int t)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    queue&lt;int&gt;q;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(int i &#x3D; 0; i &lt; N; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        dis[i] &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        vis[i] &#x3D; false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        pre[i] &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    dis[s] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    vis[s] &#x3D; true;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    q.push(s);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    while(!q.empty())&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; q.front();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        q.pop();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        vis[u] &#x3D; false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            int v &#x3D; edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                dis[v] &#x3D; dis[u] + edge[i].cost;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                pre[v] &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                if(!vis[v])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                    vis[v] &#x3D; true;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                    q.push(v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    if(pre[t] &#x3D;&#x3D; -1)return false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    else return true;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">int minCostMaxflow(int s, int t, int &amp;cost)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    int flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    cost &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    while(spfa(s, t))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        int Min &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">            if(Min &gt; edge[i].cap - edge[i].flow)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">                Min &#x3D; edge[i].cap - edge[i].flow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">            edge[i].flow +&#x3D; Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            edge[i^1].flow -&#x3D; Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">            cost +&#x3D; edge[i].cost * Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        flow +&#x3D; Min;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">    return flow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">int a[105];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    int n, sum &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    init(n + 2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)scanf(&quot;%d&quot;, &amp;a[i]), sum +&#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    sum &#x2F;&#x3D; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        if(a[i] &gt; sum)addedge(0, i, a[i] - sum, 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">        else addedge(i, n + 1, sum - a[i], 0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n-1)addedge(i,i+1,inf,1),addedge(i+1,i,inf,1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">    addedge(1,n,inf,1),addedge(n,1,inf,1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">    int ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">    minCostMaxflow(0,n+1,ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%d\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最小费用最大流的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最大流</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%A4%A7%E6%B5%81/</id>
    <published>2020-03-07T09:11:35.941Z</published>
    <updated>2020-03-07T09:11:55.262Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最大流的总结</p><a id="more"></a><h2 id="P2756-飞行员配对方案问题-最大流"><a href="#P2756-飞行员配对方案问题-最大流" class="headerlink" title="P2756 飞行员配对方案问题(最大流)"></a>P2756 飞行员配对方案问题(最大流)</h2><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.luogu.org/problem/P2756" target="_blank" rel="noopener">https://www.luogu.org/problem/P2756</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分源点、汇点，源点连英国飞行员点（流量为1）、每个英国飞行员点连可配合的外籍飞行员点（流量为1）、每个外籍飞行员点连汇点（流量为1），跑最大流即可。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">复制#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">#define maxn 2010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">#define maxm 1200010</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">#define inf 0x3f3f3f3f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">struct Edge&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    int to, nex, cap, flow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;edge[maxm];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int tol;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">int head[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">void init()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    tol &#x3D; 2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    memset(head, -1, sizeof(head));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">void addedge(int u, int v, int w, int rw &#x3D; 0)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; v; edge[tol].cap &#x3D; w; edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[u]; head[u] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    edge[tol].to &#x3D; u; edge[tol].cap &#x3D; rw; edge[tol].flow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    edge[tol].nex &#x3D; head[v]; head[v] &#x3D; tol++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">int Q[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">int dep[maxn], cur[maxn], sta[maxn];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">bool bfs(int s, int t, int n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    int fro &#x3D; 0, tail &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    memset(dep, -1, sizeof(dep[0]) * (n + 1));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    dep[s] &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    Q[tail++] &#x3D; s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    while(fro &lt; tail)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; Q[fro++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            int v &#x3D; edge[i].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            if(edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] &#x3D;&#x3D; -1)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">                dep[v] &#x3D; dep[u] + 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                if(v &#x3D;&#x3D; t)&#123;return true;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">                Q[tail++] &#x3D; v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    return false;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">int dinic(int s, int t, int n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    int maxflow &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    while(bfs(s, t, n))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)cur[i] &#x3D; head[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        int u &#x3D; s, tail &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        while(cur[s] !&#x3D; -1)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            if(u &#x3D;&#x3D; t)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">                int tp &#x3D; inf;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                    tp &#x3D; min(tp, edge[sta[i]].cap - edge[sta[i]].flow);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                maxflow +&#x3D; tp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                    edge[sta[i]].flow +&#x3D; tp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                    edge[sta[i]^1].flow -&#x3D; tp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">                    if(edge[sta[i]].cap-edge[sta[i]].flow &#x3D;&#x3D; 0)tail &#x3D; i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">                u &#x3D; edge[sta[tail]^1].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            else if(cur[u] !&#x3D; -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 &#x3D;&#x3D; dep[edge[cur[u]].to])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">                sta[tail++] &#x3D; cur[u];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">                u &#x3D; edge[cur[u]].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">            else &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">                while(u !&#x3D; s &amp;&amp; cur[u] &#x3D;&#x3D; -1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">                    u &#x3D; edge[sta[--tail]^1].to;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">                cur[u] &#x3D; edge[cur[u]].nex;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    return maxflow;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    int n, m, u, v;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;u, &amp;v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    while(u !&#x3D; -1 &amp;&amp; v !&#x3D; -1)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        addedge(u, v + n, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d %d&quot;, &amp;u, &amp;v);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)addedge(0, i, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">    go(i,1,m)addedge(i + n, n + m + 1, 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    int ans &#x3D; dinic(0, n + m + 1, n + m + 2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    if(!ans)&#123;printf(&quot;No Solution!\n&quot;); return 0;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    printf(&quot;%d\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    go(i,1,n)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        for(int j &#x3D; head[i]; j !&#x3D; -1; j &#x3D; edge[j].nex)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">            if(edge[j].flow &#x3D;&#x3D; 1)printf(&quot;%d %d\n&quot;, i, edge[j].to - n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最大流的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>主席树&amp;莫队</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/%E4%B8%BB%E5%B8%AD%E6%A0%91&amp;%E8%8E%AB%E9%98%9F/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/%E4%B8%BB%E5%B8%AD%E6%A0%91&amp;%E8%8E%AB%E9%98%9F/</id>
    <published>2020-03-07T09:10:29.269Z</published>
    <updated>2020-03-07T09:11:21.814Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主席树&amp;莫队的总结</p><a id="more"></a><h2 id="题目传送门：SPOJ-DQUERY-D-query（主席树-莫队-amp-amp-区间内不同数个数）"><a href="#题目传送门：SPOJ-DQUERY-D-query（主席树-莫队-amp-amp-区间内不同数个数）" class="headerlink" title="题目传送门：SPOJ-DQUERY D-query（主席树 | 莫队 &amp;&amp; 区间内不同数个数）"></a>题目传送门：<a href="https://cn.vjudge.net/problem/SPOJ-DQUERY" target="_blank" rel="noopener">SPOJ-DQUERY D-query</a>（主席树 | 莫队 &amp;&amp; 区间内不同数个数）</h2><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求区间内不同数的个数。</p><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>主席树做法：</p><p>倒序（从右向左）建立主席树，如果一个值还没出现过，则直接插入，否则删除后再重新插入（相当于保留这个数最左出现的位置）。之后要查询 [l, r] 时，选用 l 位置的主席树，这时树中的数据是 [l, n] 范围内的，因此查询时需要传入 r 作为挡板，仅统计小于等于 r 的个数，这样就可以实现 [l, r] 区间不同数的查询。</p><p>莫队做法：</p><p>莫队模板题</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><h3 id="主席树："><a href="#主席树：" class="headerlink" title="主席树："></a>主席树：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100001;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int sum, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125; hjt[MAXN * 40];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">int a[MAXN], sorted[MAXN], num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int root[MAXN], cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">int GetIdx(int v)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">void init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    cnt &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">int CreateNode(int sum, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    int idx &#x3D; ++cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].sum &#x3D; sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].l &#x3D; l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].r &#x3D; r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    return idx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">void Insert(int &amp;root, int pre_rt, int pos, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">int Query(int s, int e, int k, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    int n, m, i, j, k, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            sorted[i] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        sort(sorted + 1, sorted + 1 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        while(m--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h3 id="莫队："><a href="#莫队：" class="headerlink" title="莫队："></a>莫队：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">int num[1000010],vis[1000010],s[1000010];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">int m,block,ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int l,r,id;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    bool operator &lt; (const node &amp;c)const&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        if(l&#x2F;block&#x3D;&#x3D;c.l&#x2F;block)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            return r&lt;c.r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        return l&#x2F;block &lt; c.l&#x2F;block;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;q[1000010];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">void add(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    vis[s[x]]++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    if(vis[s[x]]&#x3D;&#x3D;1)ans++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">void del(int x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    vis[s[x]]--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    if(vis[s[x]]&#x3D;&#x3D;0)ans--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    int n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    block&#x3D;sqrt(n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d&quot;,&amp;s[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        q[i].id&#x3D;i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    sort(q+1,q+1+m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    int l&#x3D;1,r&#x3D;0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        while(l&lt;q[i].l)del(l),l++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        while(l&gt;q[i].l)l--,add(l);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        while(r&lt;q[i].r)r++,add(r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        while(r&gt;q[i].r)del(r),r--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        num[q[i].id]&#x3D;ans;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%d\n&quot;,num[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><h2 id="题目传送门：POJ-2104-K-th-Number（主席树-amp-amp-区间第-k-大）"><a href="#题目传送门：POJ-2104-K-th-Number（主席树-amp-amp-区间第-k-大）" class="headerlink" title="题目传送门：POJ-2104 K-th Number（主席树 &amp;&amp; 区间第 k 大）"></a>题目传送门：<a href="https://cn.vjudge.net/problem/POJ-2104" target="_blank" rel="noopener">POJ-2104 K-th Number</a>（主席树 &amp;&amp; 区间第 k 大）</h2><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求区间第 k 小的数。</p><h2 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h2><p>主席树模板题</p><h2 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 100001;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">struct node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    int sum, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125; hjt[MAXN * 40];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">int a[MAXN], sorted[MAXN], num;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">int root[MAXN], cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">int GetIdx(int v)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">void init()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    cnt &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">int CreateNode(int sum, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    int idx &#x3D; ++cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].sum &#x3D; sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].l &#x3D; l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    hjt[idx].r &#x3D; r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    return idx;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">void Insert(int &amp;root, int pre_rt, int pos, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">int Query(int s, int e, int k, int l, int r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    if(l &#x3D;&#x3D; r)return l;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    int m &#x3D; (l + r) &gt;&gt; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    int n, m, i, j, k, l, r;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">        init();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d&quot;, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            sorted[i] &#x3D; a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        sort(sorted + 1, sorted + 1 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        while(m--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">            printf(&quot;%d\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主席树&amp;amp;莫队的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>种类并查集</title>
    <link href="http://miracle-qsh.github.io/2020/03/07/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://miracle-qsh.github.io/2020/03/07/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-03-07T09:09:38.077Z</published>
    <updated>2020-03-07T09:10:17.453Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>种类并查集的总结</p><a id="more"></a><h2 id="POJ-1703-Find-them-Catch-them-种类并查集"><a href="#POJ-1703-Find-them-Catch-them-种类并查集" class="headerlink" title="POJ - 1703 Find them, Catch them (种类并查集)"></a>POJ - 1703 Find them, Catch them (种类并查集)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">300000</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fin</span><span class="params">(<span class="keyword">int</span> a)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pre[a]==a) <span class="keyword">return</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t=a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (pre[a]!=a)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        a=pre[a];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span> (pre[t]!=t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> t2=t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        t=pre[t];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        pre[t2]=a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> a;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sam</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> fin(x) == fin(y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = fin(x), b = fin(y);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(a != b)pre[a] = b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n, m, i, sum = <span class="number">0</span>, a1, a2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(sum--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">char</span> cmd[<span class="number">15</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++)pre[i] = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">            getchar();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s %d %d"</span>, &amp;cmd, &amp;a1, &amp;a2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"A"</span>) == <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">if</span>(sam(a1, a2 + n) || sam(a2, a1 + n))<span class="built_in">printf</span>(<span class="string">"In different gangs.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sam(a1, a2) || sam(a1 + n, a2 + n))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">                &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                    join(a1, a2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">                    join(a1 + n, a2 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">                    <span class="built_in">printf</span>(<span class="string">"In the same gang.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Not sure yet.\n"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">                join(a1,a2 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">                join(a2, a1 + n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;种类并查集的总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
