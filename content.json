{"meta":{"title":"QSH's blog","subtitle":"","description":"心如花木，向阳而生","author":"QSH","url":"http://miracle-qsh.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-03-07T09:52:50.566Z","updated":"2020-03-07T09:52:50.566Z","comments":true,"path":"categories/index.html","permalink":"http://miracle-qsh.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-07T09:53:33.191Z","updated":"2020-03-07T09:53:33.191Z","comments":true,"path":"tags/index.html","permalink":"http://miracle-qsh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"STL及常用算法","slug":"STL及常用算法","date":"2020-03-07T09:16:23.224Z","updated":"2020-03-07T09:17:05.275Z","comments":true,"path":"2020/03/07/STL及常用算法/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/STL%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"STL及常用算法的总结","text":"STL及常用算法的总结 STL1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3struct node4&#123;5 int data;6 bool operator &lt; (const node &amp;b)const&#123; &#x2F;&#x2F;重载运算符7 return data &lt; b.data;8 &#125;9&#125;;10int main()11&#123;12 &#x2F;&#x2F;队列13 queue&lt;int&gt;qu;14 queue&lt;node&gt;qu;15 &#x2F;&#x2F;优先队列16 priority_queue&lt;int&gt;qu; &#x2F;&#x2F;从大到小17 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qu; &#x2F;&#x2F;从小到大18 priority_queue&lt;node&gt;qu; &#x2F;&#x2F;结构体19 qu.push(&#123;1&#125;);20 qu.push(&#123;2&#125;);21 cout &lt;&lt; qu.top().data &lt;&lt; endl;22 &#x2F;&#x2F;集合23 set&lt;int&gt;st;24 st.insert(1);25 set&lt;int&gt;::iterator it;26 it &#x3D; st.lower_bound(1);27 st.insert(st.begin(), st.end());28 &#x2F;&#x2F;映射29 map&lt;int,int&gt;mp;30 map&lt;int,int&gt;::iterator it;31 mp[1] &#x3D; 2;32 it &#x3D; mp.lower_bound(1);33 cout &lt;&lt; it-&gt;second &lt;&lt; endl;3435&#125; 并查集1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3const int maxn &#x3D; 10010;4int pre[maxn];5int fin(int x)&#123;return x &#x3D;&#x3D; pre[x] ? x : pre[x] &#x3D; fin(pre[x]);&#125;6int main()7&#123;8 int n &#x3D; maxn;9 for(int i &#x3D; 0; i &lt;&#x3D; n; i++)pre[i] &#x3D; i;10 int x &#x3D; fin(1);11 int y &#x3D; fin(2);12 if(x !&#x3D; y)pre[x] &#x3D; y;13&#125; 搜索 DFS &amp;&amp; BFS1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3const int maxn &#x3D; 10010;4vector&lt;int&gt;mp[maxn];5int n, vis[maxn] &#x3D; &#123;0&#125;;6void dfs(int x)7&#123;8 vis[x] &#x3D; 1;9 for(int i &#x3D; 0; i &lt; mp[x].size(); i++)10 &#123;11 int v &#x3D; mp[x][i];12 if(vis[v] &#x3D;&#x3D; 0)13 &#123;14 dfs(v);15 &#125;16 &#125;17 vis[x] &#x3D; 0;18&#125;19void bfs(int x)20&#123;21 queue&lt;int&gt;qu;22 qu.push(x);23 vis[x] &#x3D; 1;24 while(!qu.empty())25 &#123;26 int w &#x3D; qu.front();27 qu.pop();28 for(int i &#x3D; 0; i &lt; mp[w].size(); i++)29 &#123;30 int v &#x3D; mp[w][i];31 if(vis[v] &#x3D;&#x3D; 0)32 &#123;33 qu.push(v);34 vis[v] &#x3D; 1;35 &#125;36 &#125;37 &#125;38&#125; 最短路 Dijstra &amp;&amp; Floyd &amp;&amp; SPFA1int main()2&#123;3 mp[1].push_back(2);4 mp[2].push_back(1);5 dfs(1);6 bfs(1);7&#125;89#include &lt;bits&#x2F;stdc++.h&gt;10#define inf 0x3f3f3f11using namespace std;12const int maxn &#x3D; 1010;13int mp[maxn][maxn] &#x3D; &#123;0&#125;;14int n &#x3D; 3, st &#x3D; 1, ed &#x3D; 3;15void dij()16&#123;17 int dis[maxn], vis[maxn] &#x3D; &#123;0&#125;;18 for(int i &#x3D; 0; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;19 vis[st] &#x3D; 1;20 dis[st] &#x3D; 0;21 for(int i &#x3D; 0; i &lt; n; i++)22 &#123;23 int u &#x3D; -1, minn &#x3D; inf;24 for(int j &#x3D; 1; j &lt;&#x3D; n; j++)25 &#123;26 if(dis[j] &lt; minn)27 &#123;28 minn &#x3D; dis[j];29 u &#x3D; j;30 &#125;31 &#125;32 if(u &gt; 0)vis[u] &#x3D; 1;33 else continue;34 for(int j &#x3D; 1; j &lt;&#x3D; n; j++)35 &#123;36 if(vis[j] &#x3D;&#x3D; 0 &amp;&amp; dis[j] &gt; dis[u] + mp[u][j])37 &#123;38 dis[j] &#x3D; dis[u] + mp[u][j];39 &#125;40 &#125;41 &#125;42&#125;43void floyd()44&#123;45 int i, j, k;46 for(k &#x3D; 1; k &lt;&#x3D; n; k++)47 &#123;48 for(i &#x3D; 1; i &lt;&#x3D; n; i++)49 &#123;50 for(j &#x3D; 1; j &lt;&#x3D; n; j++)51 &#123;52 if(mp[i][j] &gt; mp[i][k] + mp[k][j])53 &#123;54 mp[i][j] &#x3D; mp[i][k] + mp[k][j];55 &#125;56 &#125;57 &#125;58 &#125;59&#125;60int spfa()61&#123;62 int vis[maxn] &#x3D; &#123;0&#125;, dis[maxn], cnt[maxn] &#x3D; &#123;0&#125;;63 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)dis[i] &#x3D; inf;64 dis[st] &#x3D; 0;65 queue&lt;int&gt;qu;66 qu.push(st);67 vis[st] &#x3D; 1;68 cnt[st]++;69 while(!qu.empty())70 &#123;71 int w &#x3D; qu.front();72 qu.pop();73 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)74 &#123;75 if(vis[i] &#x3D;&#x3D; 0 &amp;&amp; dis[i] &gt; dis[w] + mp[w][i])76 &#123;77 dis[i] &#x3D; dis[w] + mp[w][i];78 vis[i] &#x3D; 1;79 qu.push(i);80 cnt[i]++;81 &#125;82 &#125;83 vis[w] &#x3D; 0;84 &#125;85 return dis[ed];86&#125;87int main()88&#123;89 mp[1][2] &#x3D; mp[2][1] &#x3D; 1;90 mp[1][3] &#x3D; mp[3][1] &#x3D; 2;91 mp[2][3] &#x3D; mp[3][2] &#x3D; 4;92 cout &lt;&lt; spfa();93&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Polya","slug":"Polya","date":"2020-03-07T09:15:41.589Z","updated":"2020-03-07T09:16:08.216Z","comments":true,"path":"2020/03/07/Polya/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/Polya/","excerpt":"Polya的总结","text":"Polya的总结 Step1 - Polya-定理设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为： 其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。Step2 - Polya-定理的引入与简单理解参考博客：https://blog.csdn.net/lyc1635566ty/article/details/52545355 参考视频：学堂在线-组合数学 一、前置知识：1.置换：其实就是集合 G 到 G 的一个双射，例如： 也就是说每次变换，1 –&gt; a1，2 –&gt; a2，…，n –&gt; an。 2.置换的乘法：例如定义 P1, P2两个置换。 定义置换乘法： 表示先作 P1 的置换，再作 P2 的置换。 3.Burnside引理:设G={a1,a2,…ag}是目标集[1,n]上的置换群。每个置换都写成不相交循环的乘积。 是在置换ak的作用下不动点的个数，也就是长度为1的循环的个数。通过上述置换的变换操作后可以相等的元素属于同一个等价类。若G将[1,n]划分成l个等价类，则等价类个数为： 二、Polya定理的引出：设 G 是 n 个对象的一个置换群, 用m种颜色染图这 n 个对象，则不同的染色方案数为： 其中 G = {P1, P2, P3,…, Pg}, C(Pk) 表示 Pk 的循环节。 Step3 - Polya-定理的使用 确定置换的个数（旋转角度，翻转） 确定循环节个数（旋转角度时考虑 gcd，翻转时特殊考虑） 套用 Polya 公式 Step4 - Polya定理-例题&amp;&amp;模板（POJ 1286）题目大意：给你一个长度为 n 的项链（环），着 3 种颜色，问有多少种 解题思路： 确定置换个数：旋转 (k * 360 / n)° n 种， 对称反转 n 种， 共 2 * n 种 确定循环节个数，旋转角度 (k * 360 / n)° 循环节为 gcd(n, k)，对称反转分奇数和偶数。 套用 Polya 公式求解 代码+模板：1#include &lt;cstdio&gt;2#include &lt;cmath&gt;3#include &lt;algorithm&gt;4using namespace std;5typedef long long ll;6int main()7&#123;8 ll n, m, i, j, k;9 while(scanf(&quot;%lld&quot;, &amp;n) !&#x3D; EOF)10 &#123;11 if(n &#x3D;&#x3D; -1)break;12 if(n &#x3D;&#x3D; 0)&#123;printf(&quot;0\\n&quot;);continue;&#125;&#x2F;&#x2F;特判013 ll ans &#x3D; 0;14 for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans +&#x3D; pow(3.0, __gcd(n, i) * 1.0);&#x2F;&#x2F;旋转（i * 360 &#x2F; n）°15 if(n % 2 &#x3D;&#x3D; 1)&#123;ans +&#x3D; n * pow(3.0, (n + 1) &#x2F; 2);&#125;&#x2F;&#x2F;奇数16 else &#123;ans +&#x3D; n &#x2F; 2 * pow(3.0, n &#x2F; 2) + n &#x2F; 2 * pow(3.0, n &#x2F; 2 + 1);&#125;&#x2F;&#x2F;偶数17 ans &#x2F;&#x3D; (n * 2);&#x2F;&#x2F;除置换个数18 printf(&quot;%lld\\n&quot;, ans);19 &#125;20 return 0;21&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Manacher","slug":"Manacher","date":"2020-03-07T09:14:34.612Z","updated":"2020-03-07T09:15:10.442Z","comments":true,"path":"2020/03/07/Manacher/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/Manacher/","excerpt":"Manacher的总结","text":"Manacher的总结 题目传送门：POJ-3974 Palindrome题目大意：求最长回文字串 解题思路：Manacher模板题 AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5char a[1000005];6char ma[2000005];7int mp[2000005];8int main()9&#123;10 int ca &#x3D; 1;11 while(scanf(&quot;%s&quot;, a) !&#x3D; EOF &amp;&amp; strcmp(a, &quot;END&quot;) !&#x3D; 0)12 &#123;13 int n &#x3D; strlen(a), i, l &#x3D; 0;14 ma[l++] &#x3D; &#39;$&#39;;15 ma[l++] &#x3D; &#39;#&#39;;16 for(i &#x3D; 0; i &lt; n; i++)17 &#123;18 ma[l++] &#x3D; a[i];19 ma[l++] &#x3D; &#39;#&#39;;20 &#125;21 ma[l] &#x3D; 0;22 int mx &#x3D; 0, id &#x3D; 0;23 int ans &#x3D; 0;24 for(i &#x3D; 0; i &lt; l; i++)25 &#123;26 mp[i] &#x3D; mx &gt; i ? min(mp[2 * id - i], mx - i):1;27 while(ma[i + mp[i]] &#x3D;&#x3D; ma[i - mp[i]])mp[i]++;28 if(i + mp[i] &gt; mx)29 &#123;30 mx &#x3D; i + mp[i];31 id &#x3D; i;32 &#125;33 ans &#x3D; max(ans, mp[i] - 1);34 &#125;35 printf(&quot;Case %d: %d\\n&quot;, ca++, ans);3637 &#125;38 return 0;39&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"KMP","slug":"KMP","date":"2020-03-07T09:13:55.652Z","updated":"2020-03-07T09:14:17.142Z","comments":true,"path":"2020/03/07/KMP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/KMP/","excerpt":"KMP的总结","text":"KMP的总结 题目传送门：POJ-2406 Power Strings题目大意：给你一个字符串，求它的最小循环节 解题思路：最小循环节==len/（len-next[len]）（如果能整除） AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3using namespace std;4char a[1000005];5int nex[1000005];6int main()7&#123;8 while(scanf(&quot;%s&quot;, a) &amp;&amp; a[0] !&#x3D; &#39;.&#39;)9 &#123;10 int len &#x3D; strlen(a);11 int i &#x3D; 0, j &#x3D; -1;12 nex[0] &#x3D; -1;13 while(i &lt; len)14 &#123;15 if(j &#x3D;&#x3D; -1 || a[i] &#x3D;&#x3D; a[j])16 &#123;17 nex[++i] &#x3D; ++j;18 &#125;19 else j &#x3D; nex[j];20 &#125;21 if(len % (len - nex[len]) &#x3D;&#x3D; 0)22 printf(&quot;%d\\n&quot;, len &#x2F; (len - nex[len]));23 else printf(&quot;1\\n&quot;);24 &#125;25 return 0;26&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"AC自动机","slug":"AC自动机","date":"2020-03-07T09:12:52.874Z","updated":"2020-03-07T09:13:42.887Z","comments":true,"path":"2020/03/07/AC自动机/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"AC自动机的总结","text":"AC自动机的总结 P3808 【模板】AC自动机（简单版）1#include&lt;bits/stdc++.h&gt;2using namespace std;3queue&lt;int&gt; q;4const int N = 500010;5struct AC_automaton6&#123;7 int c[N][26], val[N], fail[N], cnt;8 //c数组记录字典树节点，val数组为该节点是否为字符串结尾（个数）（记录字符串结束的位置）， fail记录失配指针， cnt记录节点标号(对应val)9 //cnt作用：模拟动态开点10 void ins(char *s)//向字典树中插入字符串，s为模式串11 &#123;12 int len = strlen(s); int now = 0;//从根节点0开始13 for(int i = 0; i &lt; len; i++)14 &#123;15 int v = s[i] - 'a';//获取当前字符的值16 if(!c[now][v])c[now][v] = ++cnt;//如果这个节点没开，则开点17 now = c[now][v];//now移动到新节点，开始匹配下一个18 &#125;19 val[now]++;//字符串插入完毕后在尾部打标记，val[u]表示以该点结尾的字符串个数20 &#125;21 void build()//获取每个节点的失配指针22 &#123;23 for(int i = 0; i &lt; 26; i++)24 if(c[0][i])fail[c[0][i]] = 0, q.push(c[0][i]);//首先将与根节点相连的点入队，即首字母入队，并赋失配指针为025 while(!q.empty())26 &#123;27 int u = q.front(); q.pop();//出队28 for(int i = 0; i &lt; 26; i++)29 &#123;30 if(c[u][i])fail[c[u][i]] = c[fail[u]][i], q.push(c[u][i]);//如果该节点存在，则他的失配指针为它的上一个失配指针处的失配指针，并入队31 else c[u][i] = c[fail[u]][i];//该点不存在只更新fail指针32 &#125;33 &#125;34 &#125;35 int query(char *s)//查询文本串中模式串的个数，s为文本串36 &#123;37 int len = strlen(s); int now = 0, ans = 0;//ans记录答案（模式串个数）， 从根节点开始38 for(int i = 0; i &lt; len; i++)39 &#123;40 now = c[now][s[i] - 'a'];//从当前节点向下走41 for(int t = now; t &amp;&amp; ~val[t]; t = fail[t])ans += val[t], val[t] = -1;//遍历该节点前失配指针，并统计个数，清楚val（避免重复统计）42 &#125;43 return ans;44 &#125;45&#125;AC;46int n;47char p[1000005];48int main()49&#123;50 scanf(\"%d\", &amp;n);51 for(int i = 1; i &lt;= n; i++)scanf(\"%s\", p), AC.ins(p);52 AC.build();53 scanf(\"%s\", p);54 int ans = AC.query(p);55 printf(\"%d\\n\", ans);56 return 0;57&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"最小费用最大流","slug":"最小费用最大流","date":"2020-03-07T09:12:10.836Z","updated":"2020-03-07T09:12:45.062Z","comments":true,"path":"2020/03/07/最小费用最大流/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"最小费用最大流的总结","text":"最小费用最大流的总结 P4016 负载平衡问题题目链接https://www.luogu.org/problem/P4016 解题思路分源点、汇点，源点所有超过均值的点流量为1，费用为0、所有未超过均值的点连汇点流量为1，费用为0、相邻两点连边，流量为INF，费用为1，跑最小费用最大流即可。 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)3#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)4#define maxn 20105#define maxm 12000106#define inf 0x3f3f3f3f7using namespace std;8struct Edge&#123;9 int to, nex, cap, flow, cost;10&#125;edge[maxm];11int head[maxn], tol, pre[maxn], dis[maxn];12bool vis[maxn];13int N;14void init(int n)&#123;15 N &#x3D; n;16 tol &#x3D; 0;17 memset(head, -1, sizeof(head));18&#125;19void addedge(int u, int v, int cap, int cost)&#123;20 edge[tol].to &#x3D; v;21 edge[tol].cap &#x3D; cap;22 edge[tol].cost &#x3D; cost;23 edge[tol].flow &#x3D; 0;24 edge[tol].nex &#x3D; head[u];25 head[u] &#x3D; tol++;26 edge[tol].to &#x3D; u;27 edge[tol].cap &#x3D; 0;28 edge[tol].cost &#x3D; -cost;29 edge[tol].flow &#x3D; 0;30 edge[tol].nex &#x3D; head[v];31 head[v] &#x3D; tol++;32&#125;33bool spfa(int s, int t)&#123;34 queue&lt;int&gt;q;35 for(int i &#x3D; 0; i &lt; N; i++)&#123;36 dis[i] &#x3D; inf;37 vis[i] &#x3D; false;38 pre[i] &#x3D; -1;39 &#125;40 dis[s] &#x3D; 0;41 vis[s] &#x3D; true;42 q.push(s);43 while(!q.empty())&#123;4445 int u &#x3D; q.front();46 q.pop();47 vis[u] &#x3D; false;48 for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;49 int v &#x3D; edge[i].to;5051 if(edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost)&#123;52 dis[v] &#x3D; dis[u] + edge[i].cost;53 pre[v] &#x3D; i;54 if(!vis[v])&#123;55 vis[v] &#x3D; true;56 q.push(v);57 &#125;58 &#125;59 &#125;60 &#125;61 if(pre[t] &#x3D;&#x3D; -1)return false;62 else return true;63&#125;64int minCostMaxflow(int s, int t, int &amp;cost)&#123;65 int flow &#x3D; 0;66 cost &#x3D; 0;67 while(spfa(s, t))&#123;68 int Min &#x3D; inf;69 for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;70 if(Min &gt; edge[i].cap - edge[i].flow)71 Min &#x3D; edge[i].cap - edge[i].flow;72 &#125;73 for(int i &#x3D; pre[t]; i !&#x3D; -1; i &#x3D; pre[edge[i^1].to])&#123;74 edge[i].flow +&#x3D; Min;75 edge[i^1].flow -&#x3D; Min;76 cost +&#x3D; edge[i].cost * Min;77 &#125;78 flow +&#x3D; Min;79 &#125;80 return flow;81&#125;82int a[105];83int main()84&#123;85 int n, sum &#x3D; 0;86 scanf(&quot;%d&quot;, &amp;n);87 init(n + 2);88 go(i,1,n)scanf(&quot;%d&quot;, &amp;a[i]), sum +&#x3D; a[i];89 sum &#x2F;&#x3D; n;90 go(i,1,n)&#123;91 if(a[i] &gt; sum)addedge(0, i, a[i] - sum, 0);92 else addedge(i, n + 1, sum - a[i], 0);93 &#125;94 go(i,1,n-1)addedge(i,i+1,inf,1),addedge(i+1,i,inf,1);95 addedge(1,n,inf,1),addedge(n,1,inf,1);96 int ans;97 minCostMaxflow(0,n+1,ans);98 printf(&quot;%d\\n&quot;, ans);99 return 0;100&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"最大流","slug":"最大流","date":"2020-03-07T09:11:35.941Z","updated":"2020-03-07T09:11:55.262Z","comments":true,"path":"2020/03/07/最大流/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%9C%80%E5%A4%A7%E6%B5%81/","excerpt":"最大流的总结","text":"最大流的总结 P2756 飞行员配对方案问题(最大流)题目链接https://www.luogu.org/problem/P2756 解题思路分源点、汇点，源点连英国飞行员点（流量为1）、每个英国飞行员点连可配合的外籍飞行员点（流量为1）、每个外籍飞行员点连汇点（流量为1），跑最大流即可。 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2#define go(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)3#define dip(i,a,b) for(int (i)&#x3D;(a);(i)&lt;&#x3D;(b);(i)++)4#define maxn 20105#define maxm 12000106#define inf 0x3f3f3f3f7using namespace std;8struct Edge&#123;9 int to, nex, cap, flow;10&#125;edge[maxm];11int tol;12int head[maxn];13void init()&#123;14 tol &#x3D; 2;15 memset(head, -1, sizeof(head));16&#125;17void addedge(int u, int v, int w, int rw &#x3D; 0)&#123;18 edge[tol].to &#x3D; v; edge[tol].cap &#x3D; w; edge[tol].flow &#x3D; 0;19 edge[tol].nex &#x3D; head[u]; head[u] &#x3D; tol++;20 edge[tol].to &#x3D; u; edge[tol].cap &#x3D; rw; edge[tol].flow &#x3D; 0;21 edge[tol].nex &#x3D; head[v]; head[v] &#x3D; tol++;22&#125;23int Q[maxn];24int dep[maxn], cur[maxn], sta[maxn];25bool bfs(int s, int t, int n)&#123;26 int fro &#x3D; 0, tail &#x3D; 0;27 memset(dep, -1, sizeof(dep[0]) * (n + 1));28 dep[s] &#x3D; 0;29 Q[tail++] &#x3D; s;30 while(fro &lt; tail)&#123;31 int u &#x3D; Q[fro++];32 for(int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].nex)&#123;33 int v &#x3D; edge[i].to;34 if(edge[i].cap &gt; edge[i].flow &amp;&amp; dep[v] &#x3D;&#x3D; -1)&#123;35 dep[v] &#x3D; dep[u] + 1;36 if(v &#x3D;&#x3D; t)&#123;return true;&#125;37 Q[tail++] &#x3D; v;38 &#125;39 &#125;40 &#125;41 return false;42&#125;43int dinic(int s, int t, int n)&#123;44 int maxflow &#x3D; 0;45 while(bfs(s, t, n))&#123;46 for(int i &#x3D; 0; i &lt; n; i++)cur[i] &#x3D; head[i];47 int u &#x3D; s, tail &#x3D; 0;48 while(cur[s] !&#x3D; -1)&#123;49 if(u &#x3D;&#x3D; t)&#123;50 int tp &#x3D; inf;51 for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)52 tp &#x3D; min(tp, edge[sta[i]].cap - edge[sta[i]].flow);53 maxflow +&#x3D; tp;54 for(int i &#x3D; tail - 1; i &gt;&#x3D; 0; i--)&#123;55 edge[sta[i]].flow +&#x3D; tp;56 edge[sta[i]^1].flow -&#x3D; tp;57 if(edge[sta[i]].cap-edge[sta[i]].flow &#x3D;&#x3D; 0)tail &#x3D; i;58 &#125;59 u &#x3D; edge[sta[tail]^1].to;60 &#125;61 else if(cur[u] !&#x3D; -1 &amp;&amp; edge[cur[u]].cap &gt; edge[cur[u]].flow &amp;&amp; dep[u] + 1 &#x3D;&#x3D; dep[edge[cur[u]].to])&#123;62 sta[tail++] &#x3D; cur[u];63 u &#x3D; edge[cur[u]].to;64 &#125;65 else &#123;66 while(u !&#x3D; s &amp;&amp; cur[u] &#x3D;&#x3D; -1)67 u &#x3D; edge[sta[--tail]^1].to;68 cur[u] &#x3D; edge[cur[u]].nex;69 &#125;70 &#125;71 &#125;72 return maxflow;73&#125;74int main()75&#123;76 int n, m, u, v;77 scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;u, &amp;v);78 init();79 while(u !&#x3D; -1 &amp;&amp; v !&#x3D; -1)&#123;80 addedge(u, v + n, 1);81 scanf(&quot;%d %d&quot;, &amp;u, &amp;v);82 &#125;83 go(i,1,n)addedge(0, i, 1);84 go(i,1,m)addedge(i + n, n + m + 1, 1);85 int ans &#x3D; dinic(0, n + m + 1, n + m + 2);86 if(!ans)&#123;printf(&quot;No Solution!\\n&quot;); return 0;&#125;87 printf(&quot;%d\\n&quot;, ans);88 go(i,1,n)&#123;89 for(int j &#x3D; head[i]; j !&#x3D; -1; j &#x3D; edge[j].nex)&#123;90 if(edge[j].flow &#x3D;&#x3D; 1)printf(&quot;%d %d\\n&quot;, i, edge[j].to - n);91 &#125;92 &#125;93 return 0;94&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"主席树&莫队","slug":"主席树&莫队","date":"2020-03-07T09:10:29.269Z","updated":"2020-03-07T09:11:21.814Z","comments":true,"path":"2020/03/07/主席树&莫队/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E4%B8%BB%E5%B8%AD%E6%A0%91&%E8%8E%AB%E9%98%9F/","excerpt":"主席树&amp;莫队的总结","text":"主席树&amp;莫队的总结 题目传送门：SPOJ-DQUERY D-query（主席树 | 莫队 &amp;&amp; 区间内不同数个数）题目大意：求区间内不同数的个数。 解题思路：主席树做法： 倒序（从右向左）建立主席树，如果一个值还没出现过，则直接插入，否则删除后再重新插入（相当于保留这个数最左出现的位置）。之后要查询 [l, r] 时，选用 l 位置的主席树，这时树中的数据是 [l, n] 范围内的，因此查询时需要传入 r 作为挡板，仅统计小于等于 r 的个数，这样就可以实现 [l, r] 区间不同数的查询。 莫队做法： 莫队模板题 AC代码：主席树：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5const int MAXN &#x3D; 100001;6struct node7&#123;8 int sum, l, r;9&#125; hjt[MAXN * 40];10int a[MAXN], sorted[MAXN], num;11int root[MAXN], cnt;12int GetIdx(int v)13&#123;14 return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;15&#125;16void init()17&#123;18 cnt &#x3D; 0;19&#125;20int CreateNode(int sum, int l, int r)21&#123;22 int idx &#x3D; ++cnt;23 hjt[idx].sum &#x3D; sum;24 hjt[idx].l &#x3D; l;25 hjt[idx].r &#x3D; r;26 return idx;27&#125;28void Insert(int &amp;root, int pre_rt, int pos, int l, int r)29&#123;30 root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);31 if(l &#x3D;&#x3D; r)return ;32 int m &#x3D; (l + r) &gt;&gt; 1;33 if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);34 else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);35&#125;36int Query(int s, int e, int k, int l, int r)37&#123;38 if(l &#x3D;&#x3D; r)return l;39 int m &#x3D; (l + r) &gt;&gt; 1;40 int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;41 if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);42 else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);43&#125;44int main()45&#123;46 int n, m, i, j, k, l, r;47 while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;48 init();49 for(i &#x3D; 1; i &lt;&#x3D; n; i++)50 &#123;51 scanf(&quot;%d&quot;, &amp;a[i]);52 sorted[i] &#x3D; a[i];53 &#125;54 sort(sorted + 1, sorted + 1 + n);55 num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);56 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)57 &#123;58 Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);59 &#125;60 while(m--)61 &#123;62 scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);63 printf(&quot;%d\\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);64 &#125;65 &#125;66 return 0;67&#125; 莫队：1#include &lt;iostream&gt;2#include &lt;bits&#x2F;stdc++.h&gt;3using namespace std;4int num[1000010],vis[1000010],s[1000010];5int m,block,ans;6struct node7&#123;8 int l,r,id;9 bool operator &lt; (const node &amp;c)const&#123;10 if(l&#x2F;block&#x3D;&#x3D;c.l&#x2F;block)11 return r&lt;c.r;12 return l&#x2F;block &lt; c.l&#x2F;block;13 &#125;14&#125;q[1000010];15161718void add(int x)19&#123;20 vis[s[x]]++;21 if(vis[s[x]]&#x3D;&#x3D;1)ans++;22&#125;2324void del(int x)25&#123;26 vis[s[x]]--;27 if(vis[s[x]]&#x3D;&#x3D;0)ans--;28&#125;2930int main()31&#123;32 int n;33 scanf(&quot;%d&quot;,&amp;n);34 block&#x3D;sqrt(n);35 for(int i&#x3D;1;i&lt;&#x3D;n;i++)36 &#123;37 scanf(&quot;%d&quot;,&amp;s[i]);38 &#125;39 scanf(&quot;%d&quot;,&amp;m);40 for(int i&#x3D;1;i&lt;&#x3D;m;i++)41 &#123;42 scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);43 q[i].id&#x3D;i;44 &#125;45 sort(q+1,q+1+m);46 int l&#x3D;1,r&#x3D;0;47 for(int i&#x3D;1;i&lt;&#x3D;m;i++)48 &#123;49 while(l&lt;q[i].l)del(l),l++;50 while(l&gt;q[i].l)l--,add(l);51 while(r&lt;q[i].r)r++,add(r);52 while(r&gt;q[i].r)del(r),r--;53 num[q[i].id]&#x3D;ans;54 &#125;55 for(int i&#x3D;1;i&lt;&#x3D;m;i++)56 &#123;57 printf(&quot;%d\\n&quot;,num[i]);58 &#125;59 return 0;60&#125; 题目传送门：POJ-2104 K-th Number（主席树 &amp;&amp; 区间第 k 大）题目大意：求区间第 k 小的数。 解题思路：主席树模板题 AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5const int MAXN &#x3D; 100001;6struct node7&#123;8 int sum, l, r;9&#125; hjt[MAXN * 40];10int a[MAXN], sorted[MAXN], num;11int root[MAXN], cnt;12int GetIdx(int v)13&#123;14 return lower_bound(sorted + 1, sorted + 1 + num, v) - sorted;15&#125;16void init()17&#123;18 cnt &#x3D; 0;19&#125;20int CreateNode(int sum, int l, int r)21&#123;22 int idx &#x3D; ++cnt;23 hjt[idx].sum &#x3D; sum;24 hjt[idx].l &#x3D; l;25 hjt[idx].r &#x3D; r;26 return idx;27&#125;28void Insert(int &amp;root, int pre_rt, int pos, int l, int r)29&#123;30 root &#x3D; CreateNode(hjt[pre_rt].sum + 1, hjt[pre_rt].l, hjt[pre_rt].r);31 if(l &#x3D;&#x3D; r)return ;32 int m &#x3D; (l + r) &gt;&gt; 1;33 if(pos &lt;&#x3D; m)Insert(hjt[root].l, hjt[pre_rt].l, pos, l, m);34 else Insert(hjt[root].r, hjt[pre_rt].r, pos, m + 1, r);35&#125;36int Query(int s, int e, int k, int l, int r)37&#123;38 if(l &#x3D;&#x3D; r)return l;39 int m &#x3D; (l + r) &gt;&gt; 1;40 int sum &#x3D; hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;41 if(k &lt;&#x3D; sum)return Query(hjt[s].l, hjt[e].l, k, l, m);42 else Query(hjt[s].r, hjt[e].r, k - sum, m + 1, r);43&#125;44int main()45&#123;46 int n, m, i, j, k, l, r;47 while(scanf(&quot;%d %d&quot;, &amp;n, &amp;m) !&#x3D; EOF)&#123;48 init();49 for(i &#x3D; 1; i &lt;&#x3D; n; i++)50 &#123;51 scanf(&quot;%d&quot;, &amp;a[i]);52 sorted[i] &#x3D; a[i];53 &#125;54 sort(sorted + 1, sorted + 1 + n);55 num &#x3D; unique(sorted + 1, sorted + 1 + n) - (sorted + 1);56 for(int i &#x3D; 1; i &lt;&#x3D; n; i++)57 &#123;58 Insert(root[i], root[i - 1], GetIdx(a[i]), 1, num);59 &#125;60 while(m--)61 &#123;62 scanf(&quot;%d %d %d&quot;, &amp;l, &amp;r, &amp;k);63 printf(&quot;%d\\n&quot;, sorted[Query(root[l - 1], root[r], k, 1, num)]);64 &#125;65 &#125;66 return 0;67&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"种类并查集","slug":"种类并查集","date":"2020-03-07T09:09:38.077Z","updated":"2020-03-07T09:10:17.453Z","comments":true,"path":"2020/03/07/种类并查集/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"种类并查集的总结","text":"种类并查集的总结 POJ - 1703 Find them, Catch them (种类并查集)1#include &lt;algorithm&gt;2#include &lt;iostream&gt;3#include &lt;cstring&gt;4#include &lt;cstdio&gt;5using namespace std;6int pre[300000];7int fin(int a)8&#123;9 if (pre[a]==a) return a;10 int t=a;11 while (pre[a]!=a)12 &#123;13 a=pre[a];14 &#125;15 while (pre[t]!=t)16 &#123;17 int t2=t;18 t=pre[t];19 pre[t2]=a;20 &#125;21 return a;22&#125;23int sam(int x, int y)24&#123;25 return fin(x) == fin(y);26&#125;27void join(int x, int y)28&#123;29 int a = fin(x), b = fin(y);30 if(a != b)pre[a] = b;31&#125;32int main()33&#123;34 std::ios::sync_with_stdio(0);35 int n, m, i, sum = 0, a1, a2;36 scanf(\"%d\", &amp;sum);37 while(sum--)38 &#123;39 scanf(\"%d %d\", &amp;n, &amp;m);40 char cmd[15];41 for(i = 1; i &lt;= 2 * n; i++)pre[i] = i;42 for(i = 1; i &lt;= m; i++)43 &#123;44 getchar();45 scanf(\"%s %d %d\", &amp;cmd, &amp;a1, &amp;a2);46 if(strcmp(cmd, \"A\") == 0)47 &#123;48 if(sam(a1, a2 + n) || sam(a2, a1 + n))printf(\"In different gangs.\\n\");49 else if(sam(a1, a2) || sam(a1 + n, a2 + n))50 &#123;51 join(a1, a2);52 join(a1 + n, a2 + n);53 printf(\"In the same gang.\\n\");54 &#125;55 else printf(\"Not sure yet.\\n\");56 &#125;57 else58 &#123;59 join(a1,a2 + n);60 join(a2, a1 + n);61 &#125;62 &#125;63 &#125;64 return 0;65&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"斜率DP","slug":"斜率DP","date":"2020-03-07T09:08:35.252Z","updated":"2020-03-07T09:09:24.246Z","comments":true,"path":"2020/03/07/斜率DP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%96%9C%E7%8E%87DP/","excerpt":"斜率DP的总结","text":"斜率DP的总结 斜率DP用来优化一类形如 dp[i]=min(dp[j]+f(i,j))dp[i]=min(dp[j]+f(i,j)) 的动态规划问题 从HDU3507入手题目大意将长度为 nn 的数组划分成若干段，每段的花费为这段数字和的平方加 MM,求最小花费。 DP解法定义 dp[i]dp[i] 为到i为止划分为若干段的最小花费，则有转移方程： dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i) 可以发现复杂度为n2n2的。 优化方法 设 k&lt;j&lt;ik&lt;j&lt;i 若 jj 转移至 ii 比 kk 转移至 ii 更优(本题中为 jj 转移至 ii 花费更小) 则有 dp[j]+M+(sum[i]−sum[j])2&lt;dp[k]+M+(sum[i]−sum[k])2dp[j]+M+(sum[i]−sum[j])2&lt;dp[k]+M+(sum[i]−sum[k])2 移项化简得 (dp[j]+sum[j]2)−(dp[k]+sum[k]2)2sum[j]−2sum[k]&lt;sumi−(dp[k]+sum[k]2)2sum[j]−2sum[k]&lt;sum[i] 设Y(x)=dp[x]+sum[x]2Y(x)=dp[x]+sum[x]2,X(x)=2sum[x]X(x)=2sum[x],g[i,j]=Y(i)−Y(j)X(i)−X(j)g[i,j]=Y(i)−Y(j)X(i)−X(j) 则有当g[j,k]&lt;sum[i]g[j,k]&lt;sum[i]时，jj转移至ii要比kk转移至ii更优 分析当g[i,j]&lt;g[j,k]g[i,j]&lt;g[j,k]时，若g[i,j]&lt;sum[i]g[i,j]&lt;sum[i],则ii比jj优，若g[i,j]&gt;=sum[i]g[i,j]&gt;=sum[i],则g[j,k]&gt;sum[i]g[j,k]&gt;sum[i]，即jj不如kk优 结论:对于ii点当g[j,k]&lt;g[i,j]g[j,k]&lt;g[i,j]时，jj必然不是最优的转移方案 用单调队列维护有效解集，则有效解集的斜率为递增的 随着i的增长，sum[i]sum[i]单调递增，因此若对于一个jj为ii的最优转移方案，则对于ii之后的任意一点，jj之前的点一定不如jj优。 那么对于新入队的元素ii，若队尾元素与ii的斜率小于队尾元素与上一个元素的斜率，则不断删除队尾元素，直至单调 对于每次转移，找到第一个斜率大于sum[i]sum[i]的点jj，从那jj点转移，并将jj点前的元素出队 算法复杂度为O(n)O(n) AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 5000056#define p2(x) (x)*(x)7ll a[N],dp[N],n,m,head,tail,q[N],sum[N];8ll getdp(ll i,ll j)&#123;return dp[j]+m+p2(sum[i]-sum[j]);&#125;9ll getup(ll i,ll j)&#123;return dp[i]+p2(sum[i])-(dp[j]+p2(sum[j]));&#125;10ll getdown(ll i,ll j)&#123;return 2ll*(sum[i]-sum[j]);&#125;11void init()&#123;12 head&#x3D;tail&#x3D;dp[0]&#x3D;sum[0]&#x3D;0;13 q[tail++]&#x3D;0;14&#125;15int main()16&#123;17 while(cin&gt;&gt;n&gt;&gt;m)&#123;18 go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];19 init();20 go(i,1,n)&#123;21 while(head+1&lt;tail&amp;&amp;getup(q[head],q[head+1])&gt;sum[i]*getdown(q[head],q[head]+1))head++;22 dp[i]&#x3D;getdp(i,q[head]);23 while(head+1&lt;tail&amp;&amp;getdown(q[tail-1],q[tail-2])*getup(i,q[tail-1])&lt;&#x3D;getdown(i,q[tail-1])*getup(q[tail-1],q[tail-2]))tail--;24 q[tail++]&#x3D;i;25 &#125;26 printf(&quot;%lld\\n&quot;,dp[n]);27 &#125;28 return 0;29&#125; HDU3507链接http://acm.hdu.edu.cn/showproblem.php?pid=3507 备注dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)dp[i]=min{dp[j]+(sum[i]−sum[j])2+M}(j&lt;=i)+斜率优化，入门题 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 5000056#define p2(x) (x)*(x)7ll a[N],dp[N],n,m,head,tail,q[N],sum[N];8ll getdp(ll i,ll j)&#123;return dp[j]+m+p2(sum[i]-sum[j]);&#125;9ll getup(ll i,ll j)&#123;return dp[i]+p2(sum[i])-(dp[j]+p2(sum[j]));&#125;10ll getdown(ll i,ll j)&#123;return 2ll*(sum[i]-sum[j]);&#125;11void init()&#123;12 head&#x3D;tail&#x3D;dp[0]&#x3D;sum[0]&#x3D;0;13 q[tail++]&#x3D;0;14&#125;15int main()16&#123;17 while(cin&gt;&gt;n&gt;&gt;m)&#123;18 go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];19 init();20 go(i,1,n)&#123;21 while(head+1&lt;tail&amp;&amp;getup(q[head],q[head+1])&gt;sum[i]*getdown(q[head],q[head]+1))head++;22 dp[i]&#x3D;getdp(i,q[head]);23 while(head+1&lt;tail&amp;&amp;getdown(q[tail-1],q[tail-2])*getup(i,q[tail-1])&lt;&#x3D;getdown(i,q[tail-1])*getup(q[tail-1],q[tail-2]))tail--;24 q[tail++]&#x3D;i;25 &#125;26 printf(&quot;%lld\\n&quot;,dp[n]);27 &#125;28 return 0;29&#125; BZOJ1010链接https://www.lydsy.com/JudgeOnline/problem.php?id=1010 备注dp[i]=min{dp[j]+(sum[i]−sum[j]+i−j−1−L)2}dp[i]=min{dp[j]+(sum[i]−sum[j]+i−j−1−L)2}，思路为将括号里的内容分为两个函数，便于展开。打错了函数名，调了一上午。。。 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 5000056#define p2(x) (x)*(x)7ll a[N],sum[N],tail,head,q[N],L,n,m,dp[N];8void init()&#123;head&#x3D;tail&#x3D;sum[0]&#x3D;dp[0]&#x3D;0;q[tail++]&#x3D;0;&#125;9ll getx(ll x)&#123;return x+sum[x];&#125;10ll gety(ll x)&#123;return x+sum[x]+1+L;&#125;11ll getdp(ll i,ll j)&#123;return dp[j]+p2(getx(i)-gety(j));&#125;12ll getup(ll j,ll k)&#123;return (dp[j]+p2(gety(j)))-(dp[k]+p2(gety(k)));&#125;13ll getdown(ll j,ll k)&#123;return 2ll*(gety(j)-gety(k));&#125;14int main()15&#123;16 cin&gt;&gt;n&gt;&gt;L;17 init();18 go(i,1,n)scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]&#x3D;sum[i-1]+a[i];19 go(i,1,n)&#123;20 while(head+1&lt;tail&amp;&amp;getup(q[head+1],q[head])&lt;getx(i)*getdown(q[head+1],q[head]))head++;21 dp[i]&#x3D;getdp(i,q[head]);22 while(head+1&lt;tail&amp;&amp;getup(i,q[tail-1])*getdown(q[tail-1],q[tail-2])&lt;getup(q[tail-1],q[tail-2])*getdown(i,q[tail-1]))tail--;23 q[tail++]&#x3D;i;24 &#125;25 printf(&quot;%lld\\n&quot;,dp[n]);26 return 0;27&#125; 牛客2019多校十J题目大意给定n块木板长与高，要求分为k组，每组经过切割变为等高，切割部分不能再利用，求最小浪费面积 分析 将n块木板按从高到低排序，则每组木板必是连续的一段区间，且统一高度为该组中高度最小的木板高度。 求最小浪费面积即是求最大剩余面积 DP方程dp[k][i]=maxdp[k−1][j]+h[j]∗(sum[i]−sum[j])dp[k][i]=maxdp[k−1][j]+h[j]∗(sum[i]−sum[j]) 备注 二维斜率dp类似背包，可以倒着跑开一维或正着跑开二维 每维开一个单调队列，用上一组单调队列转移，新元素添加至本组 注意整数范围，过程爆long long,使用 __int128 AC代码1复制#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3#define ll long long4#define go(i,a,b) for(ll i&#x3D;(a);i&lt;&#x3D;(b);i++)5#define N 50056#define lll __int1287#define p2(x) (x)*(x)8struct node&#123;9 ll a,b;10 bool operator&lt;(const node &amp;x)const&#123;11 return a&gt;x.a;12 &#125;13&#125;s[N];14ll dp[N][N],sum[N],head[N],tail[N],q[N][N],n,m;15ll getdp(ll i,ll j,ll y)&#123;return dp[y-1][j]+s[i].a*(sum[i]-sum[j]);&#125;16ll gety(ll i,ll y)&#123;return (dp[y-1][i]);&#125;17ll getup(ll j,ll k,ll y)&#123;return gety(j,y)-gety(k,y);&#125;18ll getdown(ll j,ll k)&#123;return sum[j]-sum[k];&#125;19ll getx(ll i)&#123;return s[i].a;&#125;20int main()21&#123;22 scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);ll sum1&#x3D;0;23 go(i,1,n)scanf(&quot;%lld%lld&quot;,&amp;s[i].b,&amp;s[i].a),sum1+&#x3D;s[i].b*s[i].a;24 sort(s+1,s+1+n);25 go(i,1,n)sum[i]&#x3D;sum[i-1]+s[i].b;26 go(i,0,m-1)head[i]&#x3D;tail[i]&#x3D;0,q[i][tail[i]++]&#x3D;0;27 go(j,1,m)&#123;28 go(i,1,n)&#123;29 while(head[j-1]+1&lt;tail[j-1]&amp;&amp;30 (lll)getup(q[j-1][head[j-1]+1],q[j-1][head[j-1]],j)31 &gt;(lll)getx(i)*(lll)getdown(q[j-1][head[j-1]+1],q[j-1][head[j-1]]))32 head[j-1]++;33 dp[j][i]&#x3D;getdp(i,q[j-1][head[j-1]],j);34 while(head[j]+1&lt;tail[j]&amp;&amp;35 (lll)getup(i,q[j][tail[j]-1],j+1)36 *(lll)getdown(q[j][tail[j]-1],q[j][tail[j]-2])37 &gt;(lll)getup(q[j][tail[j]-1],q[j][tail[j]-2],j+1)38 *(lll)getdown(i,q[j][tail[j]-1]))tail[j]--;39 q[j][tail[j]++]&#x3D;i;40 &#125;41 &#125;42 printf(&quot;%lld\\n&quot;,sum1-dp[m][n]);43 return 0;44&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"线性基","slug":"线性基","date":"2020-03-07T09:07:47.349Z","updated":"2020-03-07T09:08:26.585Z","comments":true,"path":"2020/03/07/线性基/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%BA%BF%E6%80%A7%E5%9F%BA/","excerpt":"线性基的总结","text":"线性基的总结 线性基详解线性基是什么你可以理解为将一个序列处理完之后得到的产物，并且有如下性质（后面有证明）： 线性基的性质 原序列里面的任意一个数都可以由线性基里面的一些数异或得到 线性基里面的任意一些数异或起来都不能得到00 线性基里面的数的个数唯一，并且在保持性质一的前提下，数的个数是最少的 线性基的构造过程那么它是怎么构造的呢？ 我们设有一个数组dd，表示序列aa的线性基，下标从00开始算。对于序列里面的每一个数，我们尝试将它插入到线性基里面去，具体如何插入这里给出伪代码（为了方便理解，我们设 x(2)x(2) 为xx的二进制数）： 1复制for i&#x3D;60 to 02if(x(2)的第i+1位为1)3&#123;4 if(d[i]为0)5 &#123;6 d[i]&#x3D;x;7 break;8 &#125;9 else x&#x3D;x^d[i];10&#125; 据此，我们可以得到一个关于dd数组的性质：若d[i]d[i]不为00，则d[i]（2）d[i]（2）的第i+1i+1位为11，并且d[i]（2）d[i]（2）的最高位就是第i+1i+1位。为了更好地进行线性基的讲解，我们要先知道关于异或的一个小性质：如果满足aa ^ bb ^ c=0c=0 ，那么aa ^ b=cb=c，所以如果aa ^ b=cb=c，那么aa ^ c=bc=b证明虽然简单但是这里就不给出了，不明白的读者手动模拟一下就明白了 线性基性质的证明性质1我们知道了线性基的构造方法后，其实就可以很容易想到如何证明性质1了，我们设原序列里面有一个数x，我们尝试用它来构造线性基，那么会有两种结果：1、不能成功插入线性基；2、成功插入线性基。 分类讨论一下： 不能成功插入线性基 什么时候不能插入进去呢？显然就是它在尝试插入时异或若干个数之后变成了00那么就有如下式子：xx ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=0=0根据上面的那个小性质，则有：d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=x=x所以，如果xx不能成功插入线性基，一定是因为当前线性基里面的一些数异或起来可以等于xx。 可以成功插入线性基 我们假设xx插入到了线性基的第ii个位置，显然，它在插入前可能异或若干个数，那么就有：xx ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=d[i]=d[i]d[i]d[i] ^ d[a]d[a] ^ d[b]d[b] ^ d[c]d[c] ^…=x=x所以显然，xx此时也可以由线性基里面的若干个数异或得到。 综上，性质1得证 性质2我们使用反证法设d[a]d[a] ^ d[b]d[b] ^ d[c]=0d[c]=0（其中d[c]d[c]比d[a]d[a]和d[b]d[b]要更晚被插入线性基）那么有d[a]d[a] ^ d[b]=d[c]d[b]=d[c]∵d[c]∵d[c]可以由d[a]d[a] ^ d[b]d[b]得到∴d[c]∴d[c]不可能插入线性基故假设不成立，所以线性基中不存在有任何数异或起来可以得到00。 性质3分类讨论一下 假如序列里面的所有元素都可以插入到线性基里面 显然如果是这种情况的话，不管是用什么顺序将序列里的数插入到线性基里，线性基中的元素一定与原序列元素数量相同。所以性质3成立。 假如序列里面的一些元素不能插入到线性基里面 我们设xx不能插入到线性基里面，那么一定满足形如d[a]d[a] ^ d[b]d[b] ^ d[c]=xd[c]=x的式子，那我们尝试将插入顺序改变，变成：d[a]d[a]、d[b]d[b]、xx、d[c]d[c]。那么显然，d[c]d[c]是不可能插入成功的，简单的证明：∵d[a]∵d[a] ^ d[b]d[b] ^ d[c]=xd[c]=x∴d[a]∴d[a] ^ d[b]d[b] ^ x=d[c]x=d[c]（根据上面那条异或性质）原来是xx插入不进去，改变顺序后，d[c]d[c]插入不进去，也就是说，对于插入不进去的元素，改变插入顺序后，要么还是插入不进去，要么就是插入进去了，同时另一个原来插入的进去的元素插入不进去了，所以，可以插入进去的元素数量一定是固定的。显然，如果你去掉线性基里面的任意一个数，都会使得原序列里的一些（或一个）数无法通过用线性基里的元素异或得到，所以，每一个元素都是必要的，换句话说，这里面没有多余的元素，所以，这个线性基的元素个数在保持性质1的前提下，一定是最少的。 模板1复制void add(ll x)2&#123;3 for(int i&#x3D;50;i&gt;&#x3D;0;i--)4 &#123;5 if(x&amp;(1ll&lt;&lt;i))&#x2F;&#x2F;注意，如果i大于31，前面的1的后面一定要加ll6 &#123;7 if(d[i])x^&#x3D;d[i];8 else9 &#123;10 d[i]&#x3D;x;11 break;&#x2F;&#x2F;记得如果插入成功一定要退出12 &#125;13 &#125;14 &#125;15&#125; 线性基的应用求异或最大值1复制ll ans()2&#123;3 ll anss&#x3D;0;4 for(int i&#x3D;50;i&gt;&#x3D;0;i--)&#x2F;&#x2F;记得从线性基的最高位开始5 if((anss^d[i])&gt;anss)anss^&#x3D;d[i];6 return anss;7 &#125; 求异或最小值显然的，最小值一定是最小的d[i]d[i] 求异或第 K 小值完整的说，应该是——从一个序列中取任意个元素进行异或，求能异或出的所有数字中第kk小的那个。首先，要对这个序列的线性基处理一下，对于每一个d[i]d[i]，枚举j=ito1j=ito1，如果d[i]（2）d[i]（2）的第jj位为11，那么d[i]d[i]异或d[j−1]d[j−1]。那么处理完一个线性基之后，应该大致是长这个样子的（x表示0或1）：1xxxx0xxx0x1xxxx0xxx0x……1xxx0x……1xxx0x………..1x………..1x求解过程：将k先转成二进制，假如kk的第ii位为11，ansans就异或上线性基中第ii个元素（注意不是直接异或d[i−1]d[i−1]）。 1复制void work()&#x2F;&#x2F;处理线性基2&#123;3 for(int i&#x3D;1;i&lt;&#x3D;60;i++)4 for(int j&#x3D;1;j&lt;&#x3D;i;j++)5 if(d[i]&amp;(1&lt;&lt;(j-1)))d[i]^&#x3D;d[j-1];6&#125;7ll k_th(ll k)8&#123;9 if(k&#x3D;&#x3D;1&amp;&amp;tot&lt;n)return 0;&#x2F;&#x2F;特判一下，假如k&#x3D;1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度10 if(tot&lt;n)k--;&#x2F;&#x2F;类似上面，去掉0的情况，因为线性基中只能异或出不为0的解11 work();12 ll ans&#x3D;0;13 for(int i&#x3D;0;i&lt;&#x3D;60;i++)14 if(d[i]!&#x3D;0)15 &#123;16 if(k%2&#x3D;&#x3D;1)ans^&#x3D;d[i];17 k&#x2F;&#x3D;2;18 &#125;19&#125; 判断能否被当前线性基中元素异或得到把它尝试插入进线性基里面去，假如可以插入，说明不能异或得到，假如插不进去，说明能异或得到 题集P3812 【模板】线性基“https://www.luogu.org/problem/P3812&quot; P4570 [BJWC2011]元素“https://www.luogu.org/problem/P4570&quot; P3857 [TJOI2008]彩灯“https://www.luogu.org/problem/P3857&quot; P3292 [SCOI2016]幸运数字“https://www.luogu.org/problem/P3292&quot; 参考博客“https://blog.csdn.net/a_forever_dream/article/details/83654397&quot;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"线段树","slug":"线段树","date":"2020-03-07T09:07:10.299Z","updated":"2020-03-07T09:07:40.155Z","comments":true,"path":"2020/03/07/线段树/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"线段树的总结","text":"线段树的总结 HYSBZ - 1012 最大数maxnumber (线段树)1#include &lt;bits/stdc++.h&gt;2#define ll long long3#define maxn 2000054using namespace std;5struct node6&#123;7 ll left, right;8 ll maxx;9&#125;;10node tree[maxn &lt;&lt; 2];11ll a[maxn] = &#123;0&#125;;12ll n;13ll p = 0, q;14void build(int m, int l, int r)15&#123;16 tree[m].left = l;17 tree[m].right = r;18 if (l == r)&#123;19 tree[m].maxx = a[l];20 return;21 &#125;22 int mid = (l + r) &gt;&gt; 1;23 build(m &lt;&lt; 1, l, mid);24 build(m &lt;&lt; 1 | 1, mid + 1, r);25 tree[m].maxx = max(tree[m &lt;&lt; 1].maxx, tree[m &lt;&lt; 1 | 1].maxx);26&#125;27void update(int m, int a, int val)28&#123;29 if (tree[m].left == a &amp;&amp; tree[m].right == a)&#123;30 tree[m].maxx += val;31 return;32 &#125;33 int mid = (tree[m].left + tree[m].right) &gt;&gt; 1;34 if (a &lt;= mid)&#123;35 update(m &lt;&lt; 1, a, val);36 &#125;37 else&#123;38 update(m &lt;&lt; 1 | 1, a, val);39 &#125;40 tree[m].maxx = max(tree[m &lt;&lt; 1].maxx, tree[m &lt;&lt; 1 | 1].maxx);41&#125;42ll queryMax(int m, int l, int r)43&#123;44 if (l == tree[m].left &amp;&amp; r == tree[m].right)&#123;45 return tree[m].maxx;46 &#125;47 int mid = (tree[m].left + tree[m].right) &gt;&gt; 1;48 if (r &lt;= mid)&#123;49 return queryMax(m &lt;&lt; 1, l, r);50 &#125;51 else if (l &gt; mid)&#123;52 return queryMax(m &lt;&lt; 1 | 1, l, r);53 &#125;54 return max(queryMax(m &lt;&lt; 1, l, mid), queryMax(m &lt;&lt; 1 | 1, mid + 1, r));55&#125;56int main()57&#123;58 ll t = 0,i,j, k, MOD, l;59 char cmd;60 scanf(\"%lld %lld\", &amp;n, &amp;MOD);61 build(1, 1, n);62 for(k = 1; k &lt;= n; k++)63 &#123;64 getchar();65 scanf(\"%c %lld\", &amp;cmd, &amp;l);66 if(cmd == 'Q')67 &#123;68 //cout &lt;&lt; p - l + 1 &lt;&lt; \" \" &lt;&lt; p &lt;&lt; endl;69 t = queryMax(1, p - l + 1,p);70 printf(\"%lld\\n\", t);71 &#125;72 else73 &#123;74 update(1, p + 1, (l + t) % MOD);75 p++;76 &#125;77 &#125;78 return 0;79&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"拓扑排序","slug":"拓扑排序","date":"2020-03-07T09:06:14.470Z","updated":"2020-03-07T09:07:00.722Z","comments":true,"path":"2020/03/07/拓扑排序/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"拓扑排序的总结","text":"拓扑排序的总结 题目传送门：POJ-2367 Genealogical tree题目大意：给定一个有向无环图，求拓扑排序序列 解题思路：拓扑排序模板题 AC代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4using namespace std;5const int maxn &#x3D; 100010;6int head[maxn], links, ans[maxn], pi, n, in[maxn], vis[maxn];7struct node8&#123;9 int v, nex;10&#125;edge[maxn];11void init()12&#123;13 memset(head, 0, sizeof(head));14 memset(in, 0, sizeof(in));15 memset(vis, 0, sizeof(vis));16 links &#x3D; 0;17 pi &#x3D; 0;18&#125;19void add_edge(int u, int v)20&#123;21 edge[++links].v &#x3D; v;22 edge[links].nex &#x3D; head[u];23 head[u] &#x3D; links;24&#125;25void tsort()26&#123;27 int i, j;28 for(i &#x3D; 1; i &lt;&#x3D; n; i++)29 &#123;30 for(j &#x3D; 1; j &lt;&#x3D; n; j++)31 &#123;32 if(!vis[j] &amp;&amp; !in[j])33 &#123;34 vis[j] &#x3D; 1;35 ans[pi++] &#x3D; j;36 break;37 &#125;38 &#125;39 int u &#x3D; j;40 for(j &#x3D; head[u]; j; j &#x3D; edge[j].nex)41 &#123;42 in[edge[j].v]--;43 &#125;44 &#125;45&#125;46int main()47&#123;48 int m, i, j, k;49 while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)50 &#123;51 init();52 for(i &#x3D; 1; i &lt;&#x3D; n; i++)53 &#123;54 while(1)55 &#123;56 scanf(&quot;%d&quot;, &amp;j);57 if(j &#x3D;&#x3D; 0)break;58 in[j]++;59 add_edge(i, j);60 &#125;61 &#125;62 tsort();63 for(i &#x3D; 0; i &lt; pi; i++)64 &#123;65 if(i !&#x3D; 0)printf(&quot; &quot;);66 printf(&quot;%d&quot;, ans[i]);67 &#125;68 printf(&quot;\\n&quot;);69 &#125;70 return 0;71&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数位DP","slug":"数位DP","date":"2020-03-07T09:03:30.592Z","updated":"2020-03-07T09:04:25.579Z","comments":true,"path":"2020/03/07/数位DP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E4%BD%8DDP/","excerpt":"数位DP的总结","text":"数位DP的总结 基础：https://blog.csdn.net/Miracle_QSH/article/details/85067535进阶：https://blog.csdn.net/Miracle_QSH/article/details/85079176","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"数论四大定理","slug":"数论四大定理","date":"2020-03-07T09:02:31.253Z","updated":"2020-03-07T09:03:18.162Z","comments":true,"path":"2020/03/07/数论四大定理/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%95%B0%E8%AE%BA%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86/","excerpt":"数论四大定理的总结","text":"数论四大定理的总结 威尔逊定理(p−1)!=p−1(mod**p) 当且仅当p 为质数 威尔逊定理模板题2019 HDU 多校第三场 1006 HDU-6608 欧拉定理若n,a为正整数，且n,a互质，即gcd(a,n)=1，则a ^ φ(n) ≡ 1 (mod n) 孙子定理（中国剩余定理）用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组： 中国剩余定理说明：假设整数m1,m2, … ,mn两两互质，则对任意的整数：a1,a2, … ,an，方程组 &amp;(S)&amp;有解。 并且通解可以用如下方式构造得到： 设M=m_1 \\times m_2 \\times … \\times m_n = \\prod_{i=1}^n{m_i} 是整数m1,m2,… ,mn的乘积，并设M_i = {M \\over m_i}, \\forall i \\in {1,2,…,n}是除了mi以外的n- 1个整数的乘积。设t_i = M_i^-1这个就是逆元了，则t_i M_i=1(mod m_i), \\forall i \\in {1,2,…,n} 通解形式为: 在模M的意义下，方程组(S)只有一个解： 费马小定理若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1。 补充费马大定理当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^$n￥ 没有正整数解","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"树状数组","slug":"树状数组","date":"2020-03-07T09:01:44.629Z","updated":"2020-03-07T09:02:20.289Z","comments":true,"path":"2020/03/07/树状数组/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"树状数组的总结","text":"树状数组的总结 HDU - 1166 敌兵布阵1#include &lt;bits/stdc++.h&gt;2using namespace std;3int a[50005];4char cmd[1005];5int main()6&#123;7 int t, n, m, i, j, k, ca = 1;8 scanf(\"%d\", &amp;t);9 while(t--)10 &#123;11 scanf(\"%d\", &amp;n);12 for(i = 0; i &lt;= n; i++)a[i] = 0;13 for(i = 1; i &lt;= n; i++)14 &#123;15 scanf(\"%d\", &amp;k);16 for(j = i; j &lt;= n; j += j &amp; -j)a[j] += k;17 &#125;18 printf(\"Case %d:\\n\", ca++);19 while(scanf(\"%s\", cmd) != EOF)20 &#123;21 if(cmd[0] == 'E')break;22 else if(cmd[0] == 'Q')23 &#123;24 int l, r;25 scanf(\"%d %d\", &amp;l, &amp;r);26 int ans1 = 0, ans2 = 0;27 for(i = r; i &gt; 0; i -= i &amp; -i)ans1 += a[i];28 for(i = l - 1; i &gt; 0; i -= i &amp; -i)ans2 += a[i];29 printf(\"%d\\n\", ans1 - ans2);30 &#125;31 else if(cmd[0] == 'A')32 &#123;33 int x, y;34 scanf(\"%d %d\", &amp;x, &amp;y);35 for(;x &lt;= n; x += x &amp; -x)a[x] += y;36 &#125;37 else38 &#123;39 int x, y;40 scanf(\"%d %d\", &amp;x, &amp;y);41 for(;x &lt;= n; x += x &amp; -x)a[x] -= y;42 &#125;43 &#125;44 &#125;45 return 0;46&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"容斥原理","slug":"容斥原理","date":"2020-03-07T09:00:49.253Z","updated":"2020-03-07T09:01:31.472Z","comments":true,"path":"2020/03/07/容斥原理/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/","excerpt":"容斥原理的总结","text":"容斥原理的总结 HDU - 1796 How many integers can you find （容斥原理）1#include&lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4ll n, m, a[15], ans, p;5ll lcm(ll a, ll b)&#123;return a * b / __gcd(a, b);&#125;6void dfs(ll x, ll sum, ll num)7&#123;8 if(num &gt; m)return;9 if(num % 2 == 1)&#123;ans += (n - 1) / sum;&#125;10 if(num % 2 == 0)&#123;ans -= (n - 1) / sum;&#125;11 for(ll i = x + 1; i &lt; m; i++)12 &#123;13 dfs(i, lcm(sum, a[i]), num + 1);14 &#125;15 return ;16&#125;17int main()18&#123;19 while(scanf(\"%lld %lld\", &amp;n, &amp;p) != EOF)20 &#123;21 m = 0;22 for(ll i = 0; i &lt; p; i++)23 &#123;24 scanf(\"%lld\", &amp;a[m++]);25 if(a[i] == 0 || a[i] &gt; n)m--;26 &#125;27 ans = 0;28 ll flag = 0;29 for(ll i = 0; i &lt; m; i++)30 &#123;31 dfs(i, a[i], 1);32 if(n % a[i] == 0)flag = 1;33 &#125;34 printf(\"%lld\\n\", ans);35 &#125;36 return 0;37&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"米勒罗宾素数测试","slug":"米勒罗宾素数测试","date":"2020-03-07T09:00:05.667Z","updated":"2020-03-07T09:00:39.535Z","comments":true,"path":"2020/03/07/米勒罗宾素数测试/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%B1%B3%E5%8B%92%E7%BD%97%E5%AE%BE%E7%B4%A0%E6%95%B0%E6%B5%8B%E8%AF%95/","excerpt":"米勒罗宾素数测试的总结","text":"米勒罗宾素数测试的总结 模板1复制&#x2F;&#x2F; 18位素数：154590409516822759 2&#x2F;&#x2F; 19位素数：2305843009213693951 (梅森素数) 3&#x2F;&#x2F; 19位素数：4384957924686954497 4LL prime[6] &#x3D; &#123;2, 3, 5, 233, 331&#125;; 5LL qmul(LL x, LL y, LL mod) &#123; &#x2F;&#x2F; 乘法防止溢出， 如果p * p不爆LL的话可以直接乘； O(1)乘法或者转化成二进制加法 678 return (x * y - (long long)(x &#x2F; (long double)mod * y + 1e-3) *mod + mod) % mod; 9 &#x2F;*10 LL ret &#x3D; 0;11 while(y) &#123;12 if(y &amp; 1)13 ret &#x3D; (ret + x) % mod;14 x &#x3D; x * 2 % mod;15 y &gt;&gt;&#x3D; 1;16 &#125;17 return ret;18 *&#x2F; 19&#125; 20LL qpow(LL a, LL n, LL mod) &#123; 21 LL ret &#x3D; 1; 22 while(n) &#123; 23 if(n &amp; 1) ret &#x3D; qmul(ret, a, mod); 24 a &#x3D; qmul(a, a, mod); 25 n &gt;&gt;&#x3D; 1; 26 &#125; 27 return ret; 28&#125; 29bool Miller_Rabin(LL p) &#123; 30 if(p &lt; 2) return 0; 31 if(p !&#x3D; 2 &amp;&amp; p % 2 &#x3D;&#x3D; 0) return 0; 32 LL s &#x3D; p - 1; 33 while(! (s &amp; 1)) s &gt;&gt;&#x3D; 1; 34 for(int i &#x3D; 0; i &lt; 5; ++i) &#123; 35 if(p &#x3D;&#x3D; prime[i]) return 1; 36 LL t &#x3D; s, m &#x3D; qpow(prime[i], s, p); 37 while(t !&#x3D; p - 1 &amp;&amp; m !&#x3D; 1 &amp;&amp; m !&#x3D; p - 1) &#123; 38 m &#x3D; qmul(m, m, p); 39 t &lt;&lt;&#x3D; 1; 40 &#125; 41 if(m !&#x3D; p - 1 &amp;&amp; !(t &amp; 1)) return 0; 42 &#125; 43 return 1; 44&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"类欧几里得","slug":"类欧几里得","date":"2020-03-07T08:59:02.288Z","updated":"2020-03-07T08:59:45.091Z","comments":true,"path":"2020/03/07/类欧几里得/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"类欧几里得的总结","text":"类欧几里得的总结 类欧几里得的作用类欧几里得主要用于加速下列三种函数（log）: f(a,b,c,n)=∑ni=0⌊ai+bc⌋f(a,b,c,n)=∑i=0n⌊ai+bc⌋ g(a,b,c,n)=∑ni=0⌊ai+bc⌋2g(a,b,c,n)=∑i=0n⌊ai+bc⌋2 h(a,b,c,n)=∑ni=0i⌊ai+bc⌋h(a,b,c,n)=∑i=0ni⌊ai+bc⌋ 模板1复制#pragma GCC optimize(3)2#include &lt;bits&#x2F;stdc++.h&gt;3typedef long long ll;45constexpr int mod &#x3D; 998244353;67constexpr ll inv2 &#x3D; 499122177;8constexpr ll inv6 &#x3D; 166374059;910ll f(ll a, ll b, ll c, ll n);11ll g(ll a, ll b, ll c, ll n);12ll h(ll a, ll b, ll c, ll n);1314struct Query &#123;15 ll f, g, h;16&#125;;1718Query solve(ll a, ll b, ll c, ll n) &#123;19 Query ans, tmp;20 if (a &#x3D;&#x3D; 0) &#123;21 ans.f &#x3D; (n + 1) * (b &#x2F; c) % mod;22 ans.g &#x3D; (b &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod;23 ans.h &#x3D; (n + 1) * (b &#x2F; c) % mod * (b &#x2F; c) % mod;24 return ans;25 &#125;26 if (a &gt;&#x3D; c || b &gt;&#x3D; c) &#123;27 tmp &#x3D; solve(a % c, b % c, c, n);28 ans.f &#x3D; (tmp.f + (a &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod + (b &#x2F; c) * (n + 1) % mod) % mod;29 ans.g &#x3D; (tmp.g + (a &#x2F; c) * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod + (b &#x2F; c) * n % mod * (n + 1) % mod * inv2 % mod) % mod;30 ans.h &#x3D; ((a &#x2F; c) * (a &#x2F; c) % mod * n % mod * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod +31 (b &#x2F; c) * (b &#x2F; c) % mod * (n + 1) % mod + (a &#x2F; c) * (b &#x2F; c) % mod * n % mod * (n + 1) % mod +32 tmp.h + 2 * (a &#x2F; c) % mod * tmp.g % mod + 2 * (b &#x2F; c) % mod * tmp.f % mod) % mod;33 return ans;34 &#125;35 ll m &#x3D; (a * n + b) &#x2F; c;36 tmp &#x3D; solve(c, c - b - 1, a, m - 1);37 ans.f &#x3D; (n * (m % mod) % mod - tmp.f) % mod;38 ans.g &#x3D; (n * (n + 1) % mod * (m % mod) % mod - tmp.f - tmp.h) % mod * inv2 % mod;39 ans.h &#x3D; (n * (m % mod) % mod * ((m + 1) % mod) % mod - 2 * tmp.g - 2 * tmp.f - ans.f) % mod;40 return ans;41&#125;4243inline char nc() &#123;44 static char buf[1000000], *p1 &#x3D; buf, *p2 &#x3D; buf;45 return p1 &#x3D;&#x3D; p2 &amp;&amp; (p2 &#x3D; (p1 &#x3D; buf) + fread(buf, 1, 1000000, stdin), p1 &#x3D;&#x3D; p2) ? EOF : *p1++;46&#125;4748inline ll read() &#123;49 ll res &#x3D; 0;50 char ch;51 do ch &#x3D; nc(); while (ch &lt; 48 || ch &gt; 57);52 do res &#x3D; res * 10 + ch - 48, ch &#x3D; nc(); while (ch &gt;&#x3D; 48 &amp;&amp; ch &lt;&#x3D; 57);53 return res;54&#125;5556char pbuf[1 &lt;&lt; 20], *pp &#x3D; pbuf;57inline void push(const char &amp;c) &#123;58 if (pp - pbuf &#x3D;&#x3D; 1 &lt;&lt; 20) fwrite(pbuf, 1, 1 &lt;&lt; 20, stdout), pp &#x3D; pbuf;59 *pp++ &#x3D; c;60&#125;61inline void write(int x) &#123;62 static ll sta[35];63 ll top &#x3D; 0;64 do &#123;65 sta[top++] &#x3D; x % 10, x &#x2F;&#x3D; 10;66 &#125; while (x);67 while (top) push(sta[--top] + &#39;0&#39;);68&#125;6970int main() &#123;71 ll t &#x3D; read();72 ll n, a, b, c;73 while (t--) &#123;74 n &#x3D; read(), a &#x3D; read(), b &#x3D; read(), c &#x3D; read();75 Query ans &#x3D; solve(a, b, c, n);76 printf(&quot;%lld %lld %lld\\n&quot;, (ans.f + mod) % mod, (ans.h + mod) % mod, (ans.g + mod) % mod);77 &#125;78 return 0;79&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"扩展KMP","slug":"扩展KMP","date":"2020-03-07T08:58:06.322Z","updated":"2020-03-07T08:58:50.745Z","comments":true,"path":"2020/03/07/扩展KMP/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E6%89%A9%E5%B1%95KMP/","excerpt":"扩展KMP的总结","text":"扩展KMP的总结 题目传送门：HDU-6153 A Secret题目大意：给定两个串，求其中一个串s的每个后缀在另一个串t中出现的次数乘以其长度之和。 解题思路： 将S与T串反转，转换成求前缀问题 扩展KMP求S的每个后缀与T串的最长公共前缀（extend[i] 表示 S[i..n-1] 与 T 的最长公共前缀）。 然后遍历 extend 数组， 值不为零的加上一个等差数列的和（1，2，3…extend[i]）。 AC代码：1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3typedef long long ll;4const ll maxn &#x3D; 1000005;5const ll mod &#x3D; 1000000007;6ll nex[maxn], extend[maxn];7char a[maxn], b[maxn];8void pre_EKMP(char x[], ll m, ll nex[])9&#123;10 nex[0] &#x3D; m;11 ll j &#x3D; 0;12 while(j + 1 &lt; m &amp;&amp; x[j] &#x3D;&#x3D; x[j + 1])j++;13 nex[1] &#x3D; j;14 ll k &#x3D; 1;15 for(ll i &#x3D; 2; i &lt; m; i++)&#123;16 ll p &#x3D; nex[k] + k - 1;17 ll L &#x3D; nex[i - k];18 if(i + L &lt; p + 1)nex[i] &#x3D; L;19 else &#123;20 j &#x3D; max((ll)0, p - i + 1);21 while(i + j &lt; m &amp;&amp; x[i + j] &#x3D;&#x3D; x[j])j++;22 nex[i] &#x3D; j;23 k &#x3D; i;24 &#125;25 &#125;26&#125;27void EKMP(char x[], ll m, char y[], ll n, ll nex[], ll extend[])&#123;28 pre_EKMP(x, m, nex);29 ll j &#x3D; 0;30 while(j &lt; n &amp;&amp; j &lt; m &amp;&amp; x[j] &#x3D;&#x3D; y[j])j++;31 extend[0] &#x3D; j;32 ll k &#x3D; 0;33 for(ll i &#x3D; 1; i &lt; n; i++)34 &#123;35 ll p &#x3D; extend[k] + k - 1;36 ll L &#x3D; nex[i - k];37 if(i + L &lt; p + 1)extend[i] &#x3D; L;38 else39 &#123;40 j &#x3D; max((ll)0, p - i + 1);41 while(i + j &lt; n &amp;&amp; j &lt; m &amp;&amp; y[i + j] &#x3D;&#x3D; x[j])j++;42 extend[i] &#x3D; j;43 k &#x3D; i;44 &#125;45 &#125;46&#125;47int main()48&#123;49 ll t, n, m, i;50 scanf(&quot;%lld&quot;, &amp;t);51 while(t--)52 &#123;53 scanf(&quot;%s %s&quot;, a, b);54 n &#x3D; strlen(a), m &#x3D; strlen(b);55 for(i &#x3D; 0; i &lt; n &#x2F; 2; i++)swap(a[i],a[n - 1 - i]);56 for(i &#x3D; 0; i &lt; m &#x2F; 2; i++)swap(b[i],b[m - 1 - i]);57 EKMP(b, strlen(b), a, strlen(a), nex, extend);58 ll ans &#x3D; 0;59 for(i &#x3D; 0; i &lt; n; i++)60 &#123;61 ans +&#x3D; (1 + extend[i]) * extend[i] &#x2F; 2;62 ans %&#x3D; mod;63 &#125;64 printf(&quot;%lld\\n&quot;, ans);65 &#125;66&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"回文树","slug":"回文树","date":"2020-03-07T08:57:15.678Z","updated":"2020-03-07T08:57:55.734Z","comments":true,"path":"2020/03/07/回文树/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%9B%9E%E6%96%87%E6%A0%91/","excerpt":"回文树的总结","text":"回文树的总结 回文树详解今天我们来学习一个神奇的数据结构：Palindromic Tree。中译过来就是——回文树。 那么这个回文树有何功能？ 回文树的功能假设我们有一个串S，S下标从0开始，则回文树能做到如下几点： 1.求串S前缀0~i内本质不同回文串的个数（两个串长度不同或者长度相同且至少有一个字符不同便是本质不同） 2.求串S内每一个本质不同回文串出现的次数 3.求串S内回文串的个数（其实就是1和2结合起来） 4.求以下标i结尾的回文串的个数 回文树的构造过程那么我们该如何构造回文树？ 首先我们定义一些变量。 1.len[i]表示编号为i的节点表示的回文串的长度（一个节点表示一个回文串） 2.next[i][c]表示编号为i的节点表示的回文串在两边添加字符c以后变成的回文串的编号（和字典树类似）。 3.fail[i]表示节点i失配以后跳转不等于自身的节点i表示的回文串的最长后缀回文串（和AC自动机类似）。 4.cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的） 5.num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数。 6.last指向新添加一个字母后所形成的最长回文串表示的节点。 7.S[i]表示第i次添加的字符（一开始设S[0] = -1（可以是任意一个在串S中不会出现的字符））。 8.p表示添加的节点个数。 9.n表示添加的字符个数。 一开始回文树有两个节点，0表示偶数长度串的根和1表示奇数长度串的根，且len[0] = 0，len[1] = -1，last = 0，S[0] = -1，n = 0，p = 2（添加了节点0、1）。 假设现在我们有串S = abbaabba。 首先我们添加第一个字符’a’，S[++ n] = ‘a’，然后判断此时S[n - len[last] - 1]是否等于S[n]，即上一个串-1的位置和新添加的位置是否相同，相同则说明构成回文。否则，last = fail[last]。此时last = 0，我们发现S[1 - 0 - 1] != S[1]，所以last = fail[last] = 1，然后我们发现S[1 - (-1) - 1] == S[1]（即自己等于自己，所以我们让len[1]等于-1可以让这一步更加方便）。 令cur等于此时的last（即cur = last = 1），判断此时next[cur][‘a’]是否已经有后继，如果next[cur][‘a’]没有后继，我们就进行如下的步骤：新建节点（节点数p++，且之后p = 3），并让now等于新节点的编号（now = 2），则len[now] = len[cur] + 2（每一个回文串的长度总是在其最长子回文串的基础上在两边加上两个相同的字符构成的，所以是+2，同时体现出我们让len[1] = -1的优势，一个字符自成一个奇回文串时回文串的长度为(-1) + 2 = 1）。然后我们让fail[now] = next[get_fail ( fail[cur] )][‘a’]，即得到fail[now]（此时为fail[2] = 0），其中的get_fail函数就是让找到第一个使得S[n - len[last] - 1] == S[n]的last。然后next[cur][‘a’] = now。 当上面步骤完成后我们让last = next[cur][c]（不管next[cur][‘a’]是否有后继），然后cnt[last] ++。 此时回文树为下图状态： 现在我们添加第二个字符字符’b’到回文树中： 继续添加第三个字符’b’到回文树中： 继续添加第四个字符’a’到回文树中： 继续添加第五个字符’a’到回文树中： 继续添加第六个字符’b’到回文树中： 继续添加第七个字符’b’到回文树中： 继续添加第八个字符’a’到回文树中： 到此，串S已经完全插入到回文树中了，现在所有的数据如下： 然后我们将节点x在fail指针树中将自己的cnt累加给父亲，从叶子开始倒着加，最后就能得到串S中出现的每一个本质不同回文串的个数。 回文树的复杂度构造回文树需要的空间复杂度为O（N字符集大小），时间复杂度为O（Nlog（字符集大小）），这个时间复杂度比较神奇。如果空间需求太大，可以改成邻接表的形式存储，不过相应的要牺牲一些时间。 模板1复制#include &lt;iostream&gt;2#include&lt;bits&#x2F;stdc++.h&gt;3using namespace std;4const int MAXN &#x3D; 210005 ;5const int N &#x3D; 26 ;67struct Palindromic_Tree &#123;8 int next[MAXN][N] ;&#x2F;&#x2F;next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成9 int fail[MAXN] ;&#x2F;&#x2F;fail指针，失配后跳转到fail指针指向的节点10 long long cnt[MAXN] ;11 &#x2F;&#x2F;cnt[i]表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的）12 int num[MAXN] ; &#x2F;&#x2F;num[i]表示以节点i表示的最长回文串的最右端点为回文串结尾的回文串个数13 int len[MAXN] ;&#x2F;&#x2F;len[i]表示节点i表示的回文串的长度14 int S[MAXN] ;&#x2F;&#x2F;存放添加的字符15 int last ;&#x2F;&#x2F;指向上一个字符所在的节点，方便下一次add16 int n ;&#x2F;&#x2F;字符数组指针17 int p ;&#x2F;&#x2F;节点指针1819 int newnode ( int l ) &#123;&#x2F;&#x2F;新建节点20 for ( int i &#x3D; 0 ; i &lt; N ; ++ i ) next[p][i] &#x3D; 0 ;21 cnt[p] &#x3D; 0 ;22 num[p] &#x3D; 0 ;23 len[p] &#x3D; l ;24 return p ++ ;25 &#125;2627 void init () &#123;&#x2F;&#x2F;初始化28 p &#x3D; 0 ;29 newnode (0) ;30 newnode (-1) ;31 last &#x3D; 0 ;32 n &#x3D; 0 ;33 S[n] &#x3D; -1 ;&#x2F;&#x2F;开头放一个字符集中没有的字符，减少特判34 fail[0] &#x3D; 1 ;35 &#125;3637 int get_fail ( int x ) &#123;&#x2F;&#x2F;和KMP一样，失配后找一个尽量最长的38 while ( S[n - len[x] - 1] !&#x3D; S[n] ) x &#x3D; fail[x] ;39 return x ;40 &#125;4142 void add ( int c ) &#123;43 c -&#x3D; &#39;a&#39; ;44 S[++ n] &#x3D; c ;45 &#x2F;&#x2F; cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;(char)(S[n]+&#39;a&#39;)&lt;&lt;endl;46 int cur &#x3D; get_fail ( last ) ;&#x2F;&#x2F;通过上一个回文串找这个回文串的匹配位置47 if ( !next[cur][c] ) &#123;&#x2F;&#x2F;如果这个回文串没有出现过，说明出现了一个新的本质不同的回文串48 int now &#x3D; newnode ( len[cur] + 2 ) ;&#x2F;&#x2F;新建节点49 fail[now] &#x3D; next[get_fail ( fail[cur] )][c] ;&#x2F;&#x2F;和AC自动机一样建立fail指针，以便失配后跳转50 next[cur][c] &#x3D; now ;51 num[now] &#x3D; num[fail[now]] + 1 ;52 &#125;53 last &#x3D; next[cur][c] ;54 cnt[last] ++ ;55 &#125;5657 void count () &#123;58 for ( int i &#x3D; p - 1 ; i &gt;&#x3D; 0 ; -- i ) cnt[fail[i]] +&#x3D; cnt[i] ;59 &#x2F;&#x2F;父亲累加儿子的cnt，因为如果fail[v]&#x3D;u，则u一定是v的子回文串！60 &#125;61 void print()62 &#123;63 &#x2F;&#x2F;S[i]表示第i次添加的字符（一开始设S[0] &#x3D; -1（可以是任意一个在串S中不会出现的字符））64 for(int i&#x3D;1;i&lt;&#x3D;p-2;i++)65 &#123;66 printf(&quot;%c &quot;,S[i]+&#39;a&#39;);67 &#125;68 printf(&quot;\\n&quot;);69 for(int i&#x3D;2;i&lt;p;i++)70 &#123;71 printf(&quot;%d &quot;,cnt[i]);72 &#125;73 printf(&quot;\\n&quot;);74 for(int i&#x3D;2;i&lt;p;i++)75 &#123;76 printf(&quot;%d &quot;,num[i]);77 &#125;78 printf(&quot;\\n&quot;);79 &#125;80&#125; ;81Palindromic_Tree a1,b1;82long long ans;83char a[201312],b[223123];84void dfs(int x,int y)85&#123;8687 for(int i&#x3D;0;i&lt;N;i++)88 &#123;89 int x1 &#x3D;a1.next[x][i];90 int y1 &#x3D;b1.next[y][i];9192 if(x1&amp;&amp;y1)93 &#123;94 ans+&#x3D;(long long)(a1.cnt[x1]*b1.cnt[y1]);95 cout&lt;&lt;a1.cnt[x1]&lt;&lt;&quot; &quot;&lt;&lt;b1.cnt[y1]&lt;&lt;endl;96 dfs(x1,y1);97 &#125;98 &#125;99&#125;100int main()101&#123;102103 int T;104 cin&gt;&gt;T;105 int yy &#x3D;0;106 while(T--)107 &#123;108 scanf(&quot;%s%s&quot;,a,b);109 yy++;110 printf(&quot;Case #%d: &quot;,yy);111 int len1 &#x3D;strlen(a);112 int len2 &#x3D;strlen(b);113 a1.init();114 b1.init();115 for(int i&#x3D;0;i&lt;len1;i++)116 &#123;117 a1.add(a[i]);118 &#125;119 for(int i&#x3D;0;i&lt;len2;i++)120 &#123;121 b1.add(b[i]);122 &#125;123 a1.count();124 b1.count();125 a1.print();126 cout&lt;&lt;endl;127 b1.print();128 ans &#x3D;0 ;129 dfs(0,0);130 cout&lt;&lt;endl;131 cout&lt;&lt;endl;132 dfs(1,1);133 cout&lt;&lt;ans&lt;&lt;endl;134135 &#125;136 return 0;137&#125; 题集题集链接“https://cn.vjudge.net/contest/283852#overview&quot; 简易题解A UVALive 7041 【裸】题意：求两个串的公共回文串的个数。 B HDU 3068【裸】题意：求最长回文串的长度 C HDU 3948 【裸】题意：求出本质不同的回文串个数。 D HYSBZ 2565题意：求最长双回文子串的长度正着跑一遍，反着跑一遍即可。 E URAL 1960题意：求字符串的所有前缀 本质不同的回文串个数。在添加字符的过程中直接输出即可。 F HYSBZ 3676题意：我们定义s的一个子串t的“出现值”为t在s中的出现次数乘以t的长度。请你求出s的所有回文子串中的最大出现值。 G HDU 5658题意：给定一个串，询问l到r右多少本质不同的回文串。 H HDU 5157 题意 ：给定一个字符串str，求str的不相交的回文子串的对数。回文树num数组的运用。 I HYSBZ 2160题意：给一个字符串，求最长的k个回文子串（此处回文子串长度必须为奇数）长度的乘积。字符串长度≤1000000，即要将回文串按照长度从大到小选择k个出来,并求出长度乘积。 J HDU - 5785题意：给你一个串，定义了一个权值，每个权值是两个回文串拼起来的左右坐标乘积。求所有权值的和。 注意细节，不然会爆空间 K CodeForces 17E题意：求一个字符串中相交回文串的对数。 L HDU 5421（回文树扩展——可左右添加字符的回文树）题意：有n种操作，开始给你一个空串，给你4种操作。1 c 在字符串的首部添加字符c2 c 在字符串的尾部添加字符c3 询问字符中的本质不同的回文串的个数4 询问字符串中回文串的个数 参考博客https://blog.csdn.net/u013368721/article/details/42100363http://axuhongbo.top/tree/","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"后缀数组","slug":"后缀数组","date":"2020-03-07T08:56:07.340Z","updated":"2020-03-07T08:56:57.479Z","comments":true,"path":"2020/03/07/后缀数组/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/","excerpt":"后缀数组的总结","text":"后缀数组的总结 Step1 - 后缀数组模板+详细注释1#include &lt;cstdio&gt;2using namespace std;3const int MAXN &#x3D; 100005;4&#x2F;&#x2F;rnk从0开始5&#x2F;&#x2F;sa从1开始,因为最后一个字符(最小的)排在第0位6&#x2F;&#x2F;height从1开始,因为表示的是sa[i - 1]和sa[i]7&#x2F;&#x2F;倍增算法 O(nlogn)8int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];9&#x2F;&#x2F;Suffix函数的参数m代表字符串中字符的取值范围,是基数排序的一个参数,如果原序列都是字母可以直接取128,如果原序列本身都是整数的话,则m可以取比最大的整数大1的值10&#x2F;&#x2F;待排序的字符串放在r数组中,从r[0]到r[n-1]，长度为n11&#x2F;&#x2F;为了方便比较大小,可以在字符串后面添加一个字符,这个字符没有在前面的字符中出现过,而且比前面的字符都要小12&#x2F;&#x2F;同上,为了函数操作的方便,约定除r[n-1]外所有的r[i]都大于0,r[n-1]&#x3D;013&#x2F;&#x2F;函数结束后,结果放在sa数组中,从sa[0]到sa[n-1]14void Suffix(int *r, int *sa, int n, int m)15&#123;16 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;17 &#x2F;&#x2F;对长度为1的字符串排序18 &#x2F;&#x2F;一般来说,在字符串的题目中,r的最大值不会很大,所以这里使用了基数排序19 &#x2F;&#x2F;如果r的最大值很大,那么把这段代码改成快速排序20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;&#x2F;&#x2F;统计字符的个数22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];&#x2F;&#x2F;统计不大于字符i的字符个数23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;&#x2F;&#x2F;计算字符排名24 &#x2F;&#x2F;基数排序25 &#x2F;&#x2F;x数组保存的值相当于是rank值26 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)27 &#123;28 &#x2F;&#x2F;j是当前字符串的长度,数组y保存的是对第二关键字排序的结果29 &#x2F;&#x2F;第二关键字排序30 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;&#x2F;&#x2F;第二关键字为0的排在前面31 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;&#x2F;&#x2F;长度为j的子串sa[i]应该是长度为2 * j的子串sa[i] - j的后缀（第二关键字）,对所有的长度为2 * j的子串根据第二关键字来排序32 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];&#x2F;&#x2F;提取第一关键字33 &#x2F;&#x2F;按第一关键字排序 (原理同对长度为1的字符串排序)34 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;35 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;36 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];37 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];&#x2F;&#x2F;按第一关键字,计算出了长度为2 * j的子串排名情况38 &#x2F;&#x2F;此时数组x是长度为j的子串的排名情况,数组y仍是根据第二关键字排序后的结果39 &#x2F;&#x2F;计算长度为2 * j的子串的排名情况,保存到数组x40 t &#x3D; x;41 x &#x3D; y;42 y &#x3D; t;43 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)44 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;45 &#x2F;&#x2F;若长度为2 * j的子串sa[i]与sa[i - 1]完全相同,则他们有相同的排名46 &#125;47&#125;48int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];49void calheight(int *r,int *sa,int n)50&#123;51 int i,j,k&#x3D;0;52 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;53 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)54 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);55&#125; Step2 - 模板的使用1scanf(&quot;%s&quot;, str);2int len &#x3D; strlen(str);3for(i &#x3D; 0; i &lt; len; i++)4&#123;5 r[i] &#x3D; str[i] - &#39;a&#39; + 1;&#x2F;&#x2F;将字符串填入r数组6&#125;7r[i] &#x3D; 0;&#x2F;&#x2F;末尾添加一个字符集中没有的树，保证字典序最小，便于编排数组8Suffix(r, sa, len + 1, m);&#x2F;&#x2F;m为字符集大小9calheight(r, sa, len);&#x2F;&#x2F;求 Height 数组 Step3 - 后缀数组的应用Step3.1 - 最长公共前缀题目大意：给定一个字符串，询问某两个后缀的最长公共前缀。 解题思路：按照上面所说的做法，求两个后缀的最长公共前缀可以转化为求某个区间上 的最小值。对于这个 RMQ 问题（如果对 RMQ 问题不熟悉，请阅读其他相关资料）， 可以用 O(nlogn)的时间先预处理，以后每次回答询问的时间为 O(1)。所以对于 本问题，预处理时间为 O(nlogn)，每次回答询问的时间为 O(1)。如果 RMQ 问题 用 O(n)的时间预处理，那么本问题预处理的时间可以做到 O(n)。 代码：1#include &lt;cstdio&gt;2#include &lt;cstring&gt;3#include &lt;cmath&gt;4#include &lt;algorithm&gt;5using namespace std;6&#x2F;&#x2F;后缀数组部分7const int MAXN &#x3D; 100005;8int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];9void Suffix(int *r, int *sa, int n, int m)10&#123;11 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;12 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;13 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;14 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];15 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;16 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)17 &#123;18 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;19 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;20 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];21 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;22 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;23 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];24 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];25 t &#x3D; x;26 x &#x3D; y;27 y &#x3D; t;28 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)29 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;30 &#125;31&#125;32int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];33void calheight(int *r,int *sa,int n)34&#123;35 int i,j,k&#x3D;0;36 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;37 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)38 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);39&#125;40&#x2F;&#x2F;RMQ部分41int n,minnum[MAXN][17];42void RMQ() &#x2F;&#x2F;预处理 O(nlogn)43&#123;44 int i,j;45 int m&#x3D;(int)(log(n*1.0)&#x2F;log(2.0));46 for(i&#x3D;1;i&lt;&#x3D;n;i++)47 minnum[i][0]&#x3D;height[i];48 for(j&#x3D;1;j&lt;&#x3D;m;j++)49 for(i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;i++)50 minnum[i][j]&#x3D;min(minnum[i][j-1],minnum[i+(1&lt;&lt;(j-1))][j-1]);51&#125;52int ask(int a,int b) &#x2F;&#x2F;O(1)53&#123;54 int k&#x3D;int(log(b-a+1.0)&#x2F;log(2.0));55 return min(minnum[a][k],minnum[b-(1&lt;&lt;k)+1][k]);56&#125;57int askpre(int a,int b)58&#123;59 a&#x3D;Rank[a],b&#x3D;Rank[b];60 if(a&gt;b)61 swap(a,b);62 return ask(a+1,b);63&#125;64char str[MAXN];65int main()66&#123;67 scanf(&quot;%s&quot;, str);68 n &#x3D; strlen(str);69 int i;70 for(i &#x3D; 0; i &lt; n; i++)71 &#123;72 r[i] &#x3D; str[i] - &#39;a&#39; + 1;73 &#125;74 r[i] &#x3D; 0;75 Suffix(r, sa, n + 1, 27);76 calheight(r, sa, n);77 RMQ();78 int q;79 scanf(&quot;%d&quot;, &amp;q);80 while(q--)81 &#123;82 int l, r;&#x2F;&#x2F; 0 &lt;&#x3D; l &lt;&#x3D; r &lt; n83 scanf(&quot;%d %d&quot;, &amp;l, &amp;r);84 printf(&quot;%d\\n&quot;, askpre(l, r));85 &#125;86 return 0;87&#125; Step3.2 - 单个字符串的相关问题这类问题的一个常用做法是先求后缀数组和 height 数组，然后利用 height 数组进行求解。 1. 重复子串1.1 可重叠最长重复子串题目大意：给定一个字符串，求最长重复子串，这两个子串可以重叠。 解题思路：这道题是后缀数组的一个简单应用。做法比较简单，只需要求 height 数组 里的最大值即可。首先求最长重复子串，等价于求两个后缀的最长公共前缀的最 大值。因为任意两个后缀的最长公共前缀都是 height 数组里某一段的最小值， 那么这个值一定不大于 height 数组里的最大值。所以最长重复子串的长度就是 height 数组里的最大值。这个做法的时间复杂度为 O(n)。 1.2 不可重叠最长重复子串（poj 1743）题目大意：给定一个字符串，求最长重复子串，这两个子串不能重叠。 解题思路：这题比上一题稍复杂一点。先二分答案，把题目变成判定性问题：判断是否 存在两个长度为 k 的子串是相同的，且不重叠。解决这个问题的关键还是利用 height 数组。把排序后的后缀分成若干组，其中每组的后缀之间的 height 值都 不小于 k。例如，字符串为“aabaaaab”，当 k=2 时，后缀分成了 4 组，如图 所示。 容易看出，有希望成为最长公共前缀不小于 k 的两个后缀一定在同一组。然 后对于每组后缀，只须判断每个后缀的 sa 值的最大值和最小值之差是否不小于 k。如果有一组满足，则说明存在，否则不存在。整个做法的时间复杂度为 O(nlogn)。本题中利用 height 值对后缀进行分组的方法很常用，请读者认真体 会。 代码（待测）1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#define ll long long5using namespace std;6const int MAXN &#x3D; 100005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n;40int check(int k)41&#123;42 int mx &#x3D; -0x3f3f3f, mm &#x3D; 0x3f3f3f;43 for(int i &#x3D; 2; i &lt;&#x3D; n; i++)44 &#123;45 if(height[i] &gt;&#x3D; k)46 &#123;47 mm &#x3D; min(mm, min(sa[i], sa[i - 1]));48 mx &#x3D; max(mx, max(sa[i], sa[i - 1]));49 if(mx - mm &gt; k)return 1;&#x2F;&#x2F;如果两个sa相差大于k（等于k不行）则答案可行50 &#125;51 else52 &#123;53 mx &#x3D; -0x3f3f3f, mm &#x3D; 0x3f3f3f;&#x2F;&#x2F;重新分组54 &#125;55 &#125;56 return 0;57&#125;58int main()59&#123;60 int i;61 while(scanf(&quot;%d&quot;, &amp;n) !&#x3D; EOF)62 &#123;63 if(n &#x3D;&#x3D; 0)break;64 for(i &#x3D; 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;r[i]);65 n--;66 for(i &#x3D; 0; i &lt; n; i++)r[i] &#x3D; r[i + 1] - r[i] + 89;&#x2F;&#x2F;求差值去掉负数67 r[i] &#x3D; 0;68 Suffix(r, sa, n + 1, 300);69 calheight(r, sa, n);70 int l &#x3D; 0, r &#x3D; n &#x2F; 2;71 while(l &lt; r)&#x2F;&#x2F;二分答案72 &#123;73 int mid &#x3D; (l + r + 1) &#x2F; 2;74 if(check(mid))l &#x3D; mid;75 else r &#x3D; mid - 1;76 &#125;77 if(l &gt;&#x3D; 4)printf(&quot;%d\\n&quot;, l + 1);&#x2F;&#x2F;78 else printf(&quot;0\\n&quot;);79 &#125;80 return 0;81&#125; 1.3 可重叠的 k 次最长重复子串（poj3261）题目大意：给定一个字符串，求至少出现 k 次的最长重复子串，这 k 个子串可以重叠。 解题思路：这题的做法和上一题差不多，也是先二分答案，然后将后缀分成若干组。不 同的是，这里要判断的是有没有一个组的后缀个数不小于 k。如果有，那么存在 k 个相同的子串满足条件，否则不存在。这个做法的时间复杂度为 O(nlogn)。 代码（待测）1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#define ll long long5using namespace std;6const int MAXN &#x3D; 1000005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n;40int check(int k, int x)41&#123;42 int sum &#x3D; 1;43 for(int i &#x3D; 2; i &lt;&#x3D; n; i++)44 &#123;45 if(height[i] &gt;&#x3D; k)46 &#123;47 sum++;48 &#125;49 else50 &#123;51 sum &#x3D; 1;52 &#125;53 if(sum &gt;&#x3D; x)return 1;54 &#125;55 return 0;56&#125;57int main()58&#123;59 int i, k;60 scanf(&quot;%d %d&quot;, &amp;n, &amp;k);61 for(i &#x3D; 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;r[i]);62 r[i] &#x3D; 0;63 Suffix(r, sa, n + 1, 1000005);64 calheight(r, sa, n);65 if(k &#x3D;&#x3D; 1)66 &#123;67 printf(&quot;%d\\n&quot;, n);68 &#125;69 else70 &#123;71 if(k &#x3D;&#x3D; 2)72 &#123;73 int ans &#x3D; 0;74 for(i &#x3D; 1; i &lt;&#x3D; n; i++)ans &#x3D; max(ans, height[i]);75 printf(&quot;%d\\n&quot;, ans);76 &#125;77 else78 &#123;79 int l &#x3D; 0, r &#x3D; n;80 while(l &lt; r)81 &#123;82 int mid &#x3D; (l + r + 1) &#x2F; 2;83 if(check(mid, k))l &#x3D; mid;84 else r &#x3D; mid - 1;85 &#125;86 printf(&quot;%d\\n&quot;, l);87 &#125;88 &#125;89 return 0;90&#125; 2. 子串的个数2.1 不相同的子串的个数（spoj694,spoj705）题目大意：给定一个字符串，求不相同的子串的个数。 解题思路：每个子串一定是某个后缀的前缀，那么原问题等价于求所有后缀之间的不相 同的前缀的个数。如果所有的后缀按照 suffix(sa[1]), suffix(sa[2]), suffix(sa[3]), …… ,suffix(sa[n])的顺序计算，不难发现，对于每一次新加 进来的后缀 suffix(sa[k]),它将产生 n-sa[k]+1 个新的前缀。但是其中有 height[k]个是和前面的字符串的前缀是相同的。所以 suffix(sa[k])将“贡献” 出 n-sa[k]+1- height[k]个不同的子串。累加后便是原问题的答案。这个做法 的时间复杂度为 O(n)。 代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#define ll long long5using namespace std;6const int MAXN &#x3D; 1000005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n;40char str[MAXN];41int main()42&#123;43 int t, i;44 scanf(&quot;%d&quot;, &amp;t);45 while (t--) &#123;46 scanf(&quot;%s&quot;, str);47 n &#x3D; strlen(str);48 for(i &#x3D; 0; i &lt; n; i++)r[i] &#x3D; str[i];49 r[i] &#x3D; 0;50 Suffix(r, sa, n + 1, 300);51 calheight(r, sa, n);52 ll ans &#x3D; 0;53 for (i &#x3D; 1; i &lt;&#x3D; n; i++) ans +&#x3D; n-sa[i]-height[i];54 printf(&quot;%lld\\n&quot;, ans);55 &#125;56 return 0;&#x2F;&#x2F;57&#125; 3. 回文子串留坑4. 连续重复字串4.1 连续重复子串(poj2406)题目大意：给定一个字符串 L，已知这个字符串是由某个字符串 S 重复 R 次而得到的， 求 R 的最大值。 解题思路：做法比较简单，穷举字符串 S 的长度 k，然后判断是否满足。判断的时候， 先看字符串 L 的长度能否被 k 整除，再看 suffix(1)和 suffix(k+1)的最长公共 前缀是否等于 n-k。在询问最长公共前缀的时候，suffix(1)是固定的，所以 RMQ 问题没有必要做所有的预处理，只需求出 height 数组中的每一个数到 height[rank[1]]之间的最小值即可。整个做法的时间复杂度为 O(n)。 也可以使用 KMP 最小循环节解决 代码（待测）留坑4.2 重复次数最多的连续重复子串(SPOJ-REPEATS)题目大意：给定一个字符串，求重复次数最多的连续重复子串。 解题思路：先穷举长度 L，然后求长度为 L 的子串最多能连续出现几次。首先连续出现 1 次是肯定可以的，所以这里只考虑至少 2 次的情况。假设在原字符串中连续出 现 2 次，记这个子字符串为 S，那么 S 肯定包括了字符 r[0], r[L], r[L2], r[L3], ……中的某相邻的两个。所以只须看字符 r[Li]和 r[L(i+1)]往前和 往后各能匹配到多远，记这个总长度为 K，那么这里连续出现了 K/L+1 次。最后 看最大值是多少。如图所示。 穷举长度 L 的时间是 n，每次计算的时间是 n/L。所以整个做法的时间复杂 度是 O(n/1+n/2+n/3+……+n/n)=O(nlogn)。 代码：1#include &lt;cstdio&gt;2#include &lt;cmath&gt;3#include &lt;cstring&gt;4#include &lt;algorithm&gt;5using namespace std;6const int MAXN &#x3D; 50005;7int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];8void Suffix(int *r, int *sa, int n, int m)9&#123;10 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;11 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;12 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;13 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];14 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;15 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)16 &#123;17 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;18 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;19 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];20 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;21 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;22 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];23 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];24 t &#x3D; x;25 x &#x3D; y;26 y &#x3D; t;27 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)28 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;29 &#125;30&#125;31int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];32void calheight(int *r,int *sa,int n)33&#123;34 int i,j,k&#x3D;0;35 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;36 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)37 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);38&#125;39int n,minnum[MAXN][16];40void RMQ()41&#123;42 int i,j;43 int m&#x3D;(int)(log(n*1.0)&#x2F;log(2.0));44 for(i&#x3D;1;i&lt;&#x3D;n;i++)45 minnum[i][0]&#x3D;height[i];46 for(j&#x3D;1;j&lt;&#x3D;m;j++)47 for(i&#x3D;1;i+(1&lt;&lt;j)-1&lt;&#x3D;n;i++)48 minnum[i][j]&#x3D;min(minnum[i][j-1],minnum[i+(1&lt;&lt;(j-1))][j-1]);49&#125;50int Ask_MIN(int a,int b)51&#123;52 int k&#x3D;int(log(b-a+1.0)&#x2F;log(2.0));53 return min(minnum[a][k],minnum[b-(1&lt;&lt;k)+1][k]);54&#125;55int calprefix(int a,int b)56&#123;57 a&#x3D;Rank[a],b&#x3D;Rank[b];58 if(a&gt;b)59 swap(a,b);60 return Ask_MIN(a+1,b);61&#125;62char s[5];63int main()64&#123;65 int t,i,j,k,ans,Max;66 scanf(&quot;%d&quot;,&amp;t);67 while(t--)68 &#123;69 Max&#x3D;1;70 scanf(&quot;%d&quot;,&amp;n);71 for(i&#x3D;0;i&lt;n;i++)72 &#123;73 scanf(&quot;%s&quot;,s);74 r[i]&#x3D;s[0]-&#39;a&#39;+1;75 &#125;76 r[i]&#x3D;0;77 Suffix(r,sa,n+1,3);78 calheight(r,sa,n);79 RMQ();80 for(i&#x3D;1;i&lt;&#x3D;n;i++)81 &#123;82 for(j&#x3D;0;j+i&lt;n;j+&#x3D;i)83 &#123;84 ans&#x3D;calprefix(j,j+i);85 k&#x3D;j-(i-ans%i);86 ans&#x3D;ans&#x2F;i+1;87 if(k&gt;&#x3D;0&amp;&amp;calprefix(k,k+i)&gt;&#x3D;i)88 ans++;89 Max&#x3D;max(Max,ans);90 &#125;91 &#125;92 printf(&quot;%d\\n&quot;,Max);93 &#125;94 return 0;95&#125; Step3.3 - 两个字符串的相关问题这类问题的一个常用做法是，先连接这两个字符串，然后求后缀数组和 height 数组，再利用 height 数组进行求解。 1. 最长公共字串题目大意：给定两个字符串 A 和 B，求最长公共子串。 解题思路：分隔符将两个字符串连接 后缀数组求height数组后 只要相邻两个分别在两串，就可以用height更新ans 代码：1#include &lt;cstring&gt;2#include &lt;cstdio&gt;3#include &lt;algorithm&gt;4#include &lt;iostream&gt;5#include &lt;cmath&gt;6#define ll long long7using namespace std;8const int MAXN &#x3D; 50005;9int wa[MAXN], wb[MAXN], wv[MAXN], ws_[MAXN];10void Suffix(int *r, int *sa, int n, int m)11&#123;12 int i, j, k, *x &#x3D; wa, *y &#x3D; wb, *t;13 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;14 for(i &#x3D; 0; i &lt; n; ++i) ws_[x[i] &#x3D; r[i]]++;15 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];16 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[x[i]]] &#x3D; i;17 for(j &#x3D; 1, k &#x3D; 1; k &lt; n; j *&#x3D; 2, m &#x3D; k)18 &#123;19 for(k &#x3D; 0, i &#x3D; n - j; i &lt; n; ++i) y[k++] &#x3D; i;20 for(i &#x3D; 0; i &lt; n; ++i) if(sa[i] &gt;&#x3D; j) y[k++] &#x3D; sa[i] - j;21 for(i &#x3D; 0; i &lt; n; ++i) wv[i] &#x3D; x[y[i]];22 for(i &#x3D; 0; i &lt; m; ++i) ws_[i] &#x3D; 0;23 for(i &#x3D; 0; i &lt; n; ++i) ws_[wv[i]]++;24 for(i &#x3D; 1; i &lt; m; ++i) ws_[i] +&#x3D; ws_[i - 1];25 for(i &#x3D; n - 1; i &gt;&#x3D; 0; --i) sa[--ws_[wv[i]]] &#x3D; y[i];26 t &#x3D; x;27 x &#x3D; y;28 y &#x3D; t;29 for(x[sa[0]] &#x3D; 0, i &#x3D; k &#x3D; 1; i &lt; n; ++i)30 x[sa[i]] &#x3D; (y[sa[i - 1]] &#x3D;&#x3D; y[sa[i]] &amp;&amp; y[sa[i - 1] + j] &#x3D;&#x3D; y[sa[i] + j]) ? k - 1 : k++;31 &#125;32&#125;33int Rank[MAXN], height[MAXN], sa[MAXN], r[MAXN];34void calheight(int *r,int *sa,int n)35&#123;36 int i,j,k&#x3D;0;37 for(i&#x3D;1; i&lt;&#x3D;n; i++)Rank[sa[i]]&#x3D;i;38 for(i&#x3D;0; i&lt;n; height[Rank[i++]]&#x3D;k)39 for(k?k--:0,j&#x3D;sa[Rank[i]-1]; r[i+k]&#x3D;&#x3D;r[j+k]; k++);40&#125;41char a[MAXN], b[MAXN];42int n;43int main()44&#123;45 int i;46 scanf(&quot;%s %s&quot;, a, b);47 int lena &#x3D; strlen(a);48 int lenb &#x3D; strlen(b);49 for(i &#x3D; 0; i &lt; lena; i++)50 &#123;51 r[i] &#x3D; a[i];52 &#125;53 r[lena] &#x3D; &#39;#&#39;;54 for(i &#x3D; 0; i &lt; lenb; i++)55 &#123;56 r[i + lena + 1] &#x3D; b[i];57 &#125;58 r[lena + lenb + 1] &#x3D; 0;59 Suffix(r, sa, lena + lenb + 2, 300);60 calheight(r, sa, lena + lenb + 1);61 n &#x3D; lena + lenb + 1;62 int ans &#x3D; 0;63 for(int i &#x3D; 2; i &lt;&#x3D; n; i++)64 &#123;65 int pos1 &#x3D; sa[i - 1];66 int pos2 &#x3D; sa[i];67 if(pos1 &lt;&#x3D; lena &amp;&amp; pos2 &lt;&#x3D; lena)continue;68 else if(pos1 &gt; lena + 1&amp;&amp; pos2 &gt; lena + 1)continue;69 else ans &#x3D; max(ans, height[i]);70 &#125;71 printf(&quot;%d\\n&quot;, ans);72&#125; 2. 子串的个数留坑Step3.4 - 多个字符串的相关问题留坑","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"二分匹配","slug":"二分匹配","date":"2020-03-07T08:53:28.082Z","updated":"2020-03-07T08:54:04.181Z","comments":true,"path":"2020/03/07/二分匹配/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/","excerpt":"二分匹配的总结","text":"二分匹配的总结 HYSBZ - 1143 祭祀river (二分图最大匹配)1#include &lt;bits/stdc++.h&gt;2using namespace std;3int a[105][105] = &#123;0&#125;;4int pre[205], s[205] = &#123;0&#125;, vis[105];5int cat(int x, int n)6&#123;7 int i;8 for(i = 1; i &lt;= n; i++)9 &#123;10 if(vis[i] == 0 &amp;&amp; a[x][i])11 &#123;12 vis[i] = 1;13 if(!s[i] || cat(s[i], n))14 &#123;15 s[i] = x;16 return 1;17 &#125;18 &#125;19 &#125;20 return 0;21&#125;22int main()23&#123;24 int n, m, i, j, k, u, v;25 scanf(\"%d %d\", &amp;n, &amp;m);26 for(i = 1; i &lt;= m; i++)27 &#123;28 scanf(\"%d %d\", &amp;u, &amp;v);29 a[u][v] = 1;30 &#125;31 for(k = 1; k &lt;= n; k++)32 &#123;33 for(i = 1; i &lt;= n; i++)34 &#123;35 for(j = 1; j &lt;= n; j++)36 &#123;37 if(a[i][k] == 1 &amp;&amp; a[k][j] == 1)a[i][j] = 1;38 &#125;39 &#125;40 &#125;41 int ans = 0;42 for(i = 1; i &lt;= n; i++)43 &#123;44 memset(vis, 0, sizeof(vis));45 if(cat(i, n))ans++;46 &#125;47 printf(\"%d\\n\", n - ans);48&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"堆与哈夫曼树","slug":"堆与哈夫曼树","date":"2020-03-07T08:52:19.131Z","updated":"2020-03-07T08:53:01.753Z","comments":true,"path":"2020/03/07/堆与哈夫曼树/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%A0%86%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/","excerpt":"堆与哈夫曼树的总结","text":"堆与哈夫曼树的总结 堆与哈夫曼树堆前置知识(5min)什么是二叉树二叉树是每个结点最多有两个子树的树结构 什么是满二叉树一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树 什么是完全二叉树对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树 用一张图可以较清楚的展示三者的区别 堆是什么(0.5min)堆是计算机科学中的一类数据结构 堆有什么特点(5min) 堆总是一颗完全二叉树 堆中任意一个节点总是不大于（或不小于）其父节点的值 [换言之，任意一个父节点的值一定大于等于（或小于等于）其所有子节点的值] 例如： 上述完全二叉树中，任意一个节点的值一定大于其子节点的值 7 &gt; 4 且 7 &gt; 6 4 &gt; 1 且 4 &gt; 3 6 &gt; 2 且 6 &gt; 5 因此，这课完全二叉树就可以叫做堆 补充： 任意父节点大于等于子节点的堆叫大顶堆 任意父节点小于等于子节点的堆叫小顶堆 堆有什么用(4.5min)基于堆的特点，我们发现堆可以： 快速获取一些元素中最大的值（或最小的值）（通过查询根节点的值实现） 通过不断取出当前元素中最大（或最小）的值来实现排序 例如： 现在有一个堆，堆中的元素有[6, 8, 4]，规定这是一个大顶堆。 首先我们取出根节点，也就是 8，把 8 放入序列 然后继续取出根节点，这时根节点是 6，把 6 放入序列 然后继续取出根节点，这时根节点是 4，把 4 放入序列 排序完成，新序列为[8, 6, 4]。 如何建立一个堆(15min)完全二叉树的一个性质(7min) 上图是一颗完全二叉树，红字部分为给每个节点的标号，不难发现这样一个特点： 对于任意一个节点，其左儿子标号=该节点标号*2，其右儿子标号=该节点标号 *2+1 上图中： 2 = 1 * 2， 3 = 1 * 2 + 1 4 = 2 * 2， 5 = 2 * 2 + 1 6 = 3 * 2， 7 = 3 * 2 + 1 用数组表示树(7.5min)基于上面得到的性质，可以用一段数组来表示一颗完全二叉树，而不再使用树形结构。 只需按照标号顺序依次向数组中放入每个节点即可用数组表示完全二叉树 例如在发现完全二叉树性质时使用的例子： 其数组表示为： [7, 4, 6, 1, 3, 2, 5] 其标号顺序为： [1, 2, 3, ,4, 5, 6, 7] 用数组建立一个空堆(0.5min)那么如果要建立一个空堆（即没有任何元素的堆），只需要声明一个数组即可，因为堆本质就是一颗特殊的完全二叉树。 之后的讨论中默认新建的这个堆为大顶堆 1int heap[N]; 向堆中插入一个元素(15min)在尾部添加新元素(3min)现在向堆中插入第一个元素，我们只需要在数组的尾部插入即可，例如我们插入 4 现在数组变为[4]，表现为树形结构为： 然后，插入第二个元素 6 现在数组变为[4, 6]，很显然 6 是 4的子节点，但4 &lt; 6，不符合大顶堆的性质，那么也就是说： 我们每次在数组尾部添加了一个新元素，需要重新维护数组中元素的顺序来保证堆的性质 调整位置以保证堆的性质(12min)首先，我们来看一个插入元素的过程动画 在这个动画中，我们可以观察到，我们在堆的尾部添加了一个元素这个元素是不符合大顶堆的性质的，于是我们会对元素的位置进行调整。 可以比较清楚的发现，调整过程中，新插入元素一直在不停的与他的父亲节点交换，直到整棵完全二叉树合法 于是，我们可以这样编码： 1heap[++len] = val; // heap为堆数组，len为当前长度， val为新插入的元素，该步骤实现在尾部插入新元素2int temp_pos = len; //定义临时变量存储新添加元素当前的位置3while(temp_pos &gt; 1 &amp;&amp; heap[temp_pos] &gt; heap[temp_pos / 2])// temp_pos &gt; 1 保证了当前位置节点有父节点，根据完全二叉树性质，我们不难推断：一个节点的父节点标号=当前节点标号/2，heap[temp_pos] &gt; heap[temp_pos / 2]保证了当前元素还没有到达合适位置4&#123;5 swap(a[temp_pos], a[temp_pos/2]); //交换当前节点与父节点6 temp_pos /= 2; // 更新元素的当前位置7&#125; 从堆中取出一个最大值(15min)将首部元素取出(0.5min)一般情况下，对我们有用的元素往往是根节点的值（也就是最值）， 因此，我们要取出最大值，首先要将首部元素提出。 将尾部元素调整至首部(0.5min)首部元素提出后，首部位置将会闲置，为了保证堆仍然是一颗完全二叉树，我们将尾部元素调整至首部 调整位置以保证堆得性质(14min)同样的，调整之后堆的性质将被打乱，我们需要重新将首部元素调整至合适位置以保证堆的性质 我们来看一下删除元素的动画 从动画中我们可以看出，将尾部调整至首部后，首部元素不符合堆的性质，因此不断与比本身大的子节点交换（两个子节点都比本身大时与较大的子节点交换），直至整个堆合法。 因此，我们可以这样编码 1int maxn = heap[1]; // 取出最大值，赋值给maxn2heap[1] = heap[len--]; // 将尾部元素调至首部，并改变堆的大小3int temp_pos = 1; // temp_pos 表示首部元素的当前位置4while(temp_pos * 2 &lt;= len) // 保证当前节点有子节点5&#123;6 if(temp_pos*2+1&lt;=len) // 如果当前节点有两个子节点7 &#123;8 if(heap[temp_pos*2]&gt;=heap[temp_pos*2+1]&amp;&amp;heap[temp_pos*2]&gt;=heap[temp_pos])9 // 如果左子节点是两个子节点中最大的10 swap(heap[temp_pos*2],heap[temp_pos]),temp_pos=temp_pos*2; // 交换当前节点与左子节点11 else if (heap[temp_pos*2+1]&gt;=heap[temp_pos*2]&amp;&amp;heap[temp_pos*2+1]&gt;=heap[temp_pos])12 // 如果右子节点是两个子节点中最大的13 swap(heap[temp_pos*2+1],heap[temp_pos]),temp_pos=temp_pos*2+1; // 交换当前节点与右子节点14 else break; // 除此之外，表明堆已合法15 &#125;16 else // 如果当前节点有一个子节点17 &#123;18 if(heap[temp_pos*2] &gt;= heap[temp_pos]) //如果子节点大于当前节点19 swap(heap[temp_pos*2], heap[temp_pos]),temp_pos=temp_pos*2; //交换当前节点与子节点20 else break; // 除此之外，表明堆已合法21 &#125;22&#125; *线性建堆至此，堆的基本内容已经给大家讲完了，已经了解时间复杂度的大家可以对堆的建立，删除，插入进行一个简单的分析，其实不难得出，一次插入与删除的复杂度均为O（log n） 现在，我们有n个元素，如果我们用上面所介绍的方法建堆，将插入n次，每次复杂度为O（log n），总复杂度为O（n*log n） 事实上，我们有线性时间建堆的方法，即复杂度O（n）的建堆方法 下面我们通过动画了解一下： 通过动画我们可以发现，线性建堆的方法，在于一开始即将无序的元素放入堆数组中， 然后从尾部元素开始，逐个向下调整（过程类似于删除首部元素后的调整），直到首部元素向下调整的过程结束， 一个符合堆性质的堆数组即建立完成 下面通过伪代码的方式给大家呈现整个过程的编码实现： 1for(int i = len; i &gt;= 1; i--)&#123;2 if(i * 2 &gt; len)continue; // 无子节点时直接跳过3 down(i); //向下调整4&#125; 其中down()函数不再给出，具体实现请大家参考从堆中取出最大值的操作。 编码完了，我们还有一个问题没有解决，即： 为什么这样操作的复杂度是O（n）的？ 关于这个问题感兴趣的同学可以移步线性建堆复杂度证明去了解一下，在这里不做赘述 使用堆来排序(4.5min)排序过程中，不断从堆顶（即根节点取出元素）即可，伪代码如下： 1int p[N], len = 0;2while(heap不为空)&#123;3 p[++len] = 取出堆顶();4&#125; 使用堆来找出一个集合中的最值(0.5min)建好堆后获取根节点的值即可 哈夫曼树(10min)*什么是哈夫曼树(5min)给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 *如何构建一颗哈夫曼树(3min)可以通过将元素压入小顶堆，每次取出两个元素，权值相加作为两个元素的根节点，同时将根节点压入堆中，直到堆中只剩下一个元素，则哈夫曼树建成 哈夫曼树有什么用(2min)一道经典的例题：SDUTOJ 树-堆结构练习——合并果子之哈夫曼树 解题思路： 因为哈夫曼树是带权路径长度最短的树，所以本题可以通过构建哈夫曼树的思路解决，即： 将所有元素压入小顶堆中，每次取出两个元素相加，压入堆，直到堆中只剩一个元素，则该元素为最终答案 参考资料百度百科：二叉树 百度百科：满二叉树 百度百科：完全二叉树 二叉树,完全二叉树,满二叉树,完美二叉树 数据结构：堆（Heap） 堆排序中建堆过程的时间复杂度O(n)的证明 百度百科：堆 百度百科：哈夫曼树 SDUTOJ 树-堆结构练习——合并果子之哈夫曼树 可视化数据结构学习VisuAlgo—二叉堆","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"单调栈","slug":"单调栈","date":"2020-03-07T08:51:22.502Z","updated":"2020-03-07T08:52:07.216Z","comments":true,"path":"2020/03/07/单调栈/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"单调栈的总结","text":"单调栈的总结 题目传送门：Gym-100971D Laying Cables题目大意：给定你一些城市（直线）的坐标和城市人口大小，要求你输出距离每个城市最近的比他人口大的城市标号，如果没有，则置为-1。 解题思路：维护一个单调递减的栈，分别从左到右，在从右到左，分别计算离他最近的点。 AC代码：1#include &lt;bits&#x2F;stdc++.h&gt;2using namespace std;3typedef long long ll;4const int maxn &#x3D; 200005;5struct Node6&#123;7 ll loc, v, num;8&#125;node[maxn];9bool cmp(Node x, Node y)10&#123;11 return x.loc &lt; y.loc;12&#125;13ll aim[maxn];14int main()15&#123;16 ll n, m, i, j, k, a, b;17 scanf(&quot;%lld&quot;, &amp;m);18 for(i &#x3D; 1; i &lt;&#x3D; m; i++)19 &#123;20 scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b);21 node[i].loc &#x3D; a;22 node[i].v &#x3D; b;23 node[i].num &#x3D; i;24 &#125;25 sort(node + 1, node + 1 + m, cmp);26 stack&lt;Node&gt;s;27 vector&lt;Node&gt;lef, rig;28 lef.resize(maxn);29 rig.resize(maxn);30 Node w;31 w.v &#x3D; w.loc &#x3D; 2e10;32 w.num &#x3D; -1;33 s.push(w);34 for(i &#x3D; 1; i &lt;&#x3D; m; i++)35 &#123;36 while(node[i].v &gt; s.top().v)s.pop();37 lef[i] &#x3D; s.top();38 s.push(node[i]);39 &#125;40 while(!s.empty())s.pop();41 node[m + 1].v &#x3D; 2e10;42 node[m + 1].loc &#x3D; 2e10;43 node[m + 1].num &#x3D; -1;44 s.push(node[m + 1]);45 for(i &#x3D; m; i &gt;&#x3D; 1; i--)46 &#123;47 while(node[i].v &gt; s.top().v)s.pop();48 rig[i] &#x3D; s.top();49 s.push(node[i]);50 &#125;51 for(i &#x3D; 1; i &lt;&#x3D; m; i++)52 &#123;53 if(abs(lef[i].loc - node[i].loc) &#x3D;&#x3D; abs(rig[i].loc - node[i].loc))54 &#123;55 if(lef[i].v &gt; rig[i].v)aim[node[i].num] &#x3D; lef[i].num;56 else aim[node[i].num] &#x3D; rig[i].num;57 &#125;58 else if(abs(lef[i].loc - node[i].loc) &gt; abs(rig[i].loc - node[i].loc))59 &#123;60 aim[node[i].num] &#x3D; rig[i].num;61 &#125;62 else aim[node[i].num] &#x3D; lef[i].num;63 &#125;64 for(i &#x3D; 1; i &lt;&#x3D; m; i++)65 &#123;66 if(i !&#x3D; 1)printf(&quot; &quot;);67 printf(&quot;%lld&quot;, aim[i]);68 &#125;69 printf(&quot;\\n&quot;);70 return 0;71&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"博弈","slug":"博弈","date":"2020-03-07T08:50:02.751Z","updated":"2020-03-07T08:51:01.705Z","comments":true,"path":"2020/03/07/博弈/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E5%8D%9A%E5%BC%88/","excerpt":"纳什博弈、威佐夫博弈、尼姆博弈的总结","text":"纳什博弈、威佐夫博弈、尼姆博弈的总结 HDU - 2516 取石子游戏 (斐波那契博弈)题目链接：https://cn.vjudge.net/contest/269106#problem/F 题目大意： 1堆石子有n个,两人轮流取.先取者第1次可以取任意多个，但不能全部取完.以后每次取的石子数不能超过上次取子数的2倍。取完者胜.先取者负输出&quot;Second win&quot;.先取者胜输出&quot;First win&quot;.解题思路： 斐波那契博弈，n为斐波那契数时先手必败，用map记录一下斐波那契数即可。1#include &lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4map&lt;ll, ll&gt;mp;5int main()6&#123;7 ll i, n, a, b, c, len = 1e18;8 a = 1;9 b = 1;10 c = a + b;11 mp[1] = 1;12 while(c &lt;= len)13 &#123;14 mp[c] = 1;15 a = b;16 b = c;17 c = a + b;18 &#125;19 while(scanf(\"%lld\", &amp;n) != EOF)20 &#123;21 if(n == 0)break;22 if(mp[n] == 1)printf(\"Second win\\n\");23 else printf(\"First win\\n\");24 &#125;25 return 0;26&#125; HDU - 1527 取石子游戏 (威佐夫博弈)题目链接：https://cn.vjudge.net/contest/269106#problem/R 题目大意： 有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。解题思路： 威佐夫博弈，设（a，b），a &lt; b，若a / b最接近（sqrt（5） - 1）/ 2，则（a，b）为必败态。1#include &lt;bits/stdc++.h&gt;2using namespace std;3int main()4&#123;5 double a, b, c;6 while(scanf(\"%lf %lf\", &amp;a, &amp;b) != EOF)7 &#123;8 if(a &gt; b)&#123;c = a; a = b; b = c;&#125;9 c = (sqrt(5) - 1.0) / 2.0;10 if(abs((a + 1) / b - c) &gt; abs(a / b - c) &amp;&amp; abs((a - 1) / b - c) &gt; abs(a / b - c))11 &#123;12 printf(\"0\\n\");13 &#125;14 else printf(\"1\\n\");15 &#125;16 return 0;17&#125; HDU - 2176 取(m堆)石子游戏 （尼姆博弈）题目链接：https://cn.vjudge.net/contest/269106#problem/Q 题目大意： m堆石子,两人轮流取.只能在1堆中取.取完者胜.先取者负输出No.先取者胜输出Yes,然后输出怎样取子.例如5堆 5,7,8,9,10先取者胜,先取者第1次取时可以从有8个的那一堆取走7个剩下1个,也可以从有9个的中那一堆取走9个剩下0个,也可以从有10个的中那一堆取走7个剩下3个.解题思路： 尼姆博弈，即所有数异或和为0是必败态，否则为必胜态，首先异或一遍，为0输出No，不为零输出Yes，然后遍历石子数，sum ^= a[i]，则sum为除第i堆石子外的异或和，易知sum ^ sum = 0，故当sum &lt; a[i]时，第i堆石子可已走a[i] - sum个石子，使对手必败。1#include &lt;bits/stdc++.h&gt;2using namespace std;3typedef long long ll;4ll a[200005];5int main()6&#123;7 ll n, sum, i, left;8 while(scanf(\"%lld\", &amp;n) != EOF)9 &#123;10 if(n == 0)break;11 sum = 0;12 for(i = 1; i &lt;= n; i++)13 &#123;14 scanf(\"%lld\", &amp;a[i]);15 sum ^= a[i];16 &#125;17 if(sum == 0)18 &#123;19 printf(\"No\\n\");20 &#125;21 else22 &#123;23 printf(\"Yes\\n\");24 for(i = 1; i &lt;= n; i++)25 &#123;26 sum ^= a[i];27 left = sum;28 if(left &lt;= a[i])29 &#123;30 printf(\"%lld %lld\\n\", a[i], left);31 &#125;32 sum ^= a[i];33 &#125;34 &#125;35 &#125;36 return 0;37&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"背包问题","slug":"背包问题","date":"2020-03-07T08:47:50.595Z","updated":"2020-03-07T08:49:45.718Z","comments":true,"path":"2020/03/07/背包问题/","link":"","permalink":"http://miracle-qsh.github.io/2020/03/07/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"01背包、完全背包、多重背包的总结","text":"01背包、完全背包、多重背包的总结 动态规划—简单背包问题 零 开始之前 什么是动态规划？ 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法叫做动态规划。 什么时候能用动态规划？ 动态规划常常适用于有重叠子问题和最优子结构性质的问题。 什么是最优子结构？ 当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。 什么是重叠子问题？ 在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。 动态规划该怎么做？ 1、确定状态 2、确定状态转移方程 3、从大到小（记忆化+递归）、从小到大（递推） 一个简单的例子 爬楼梯问题 你正在爬一个有n个台阶的楼梯，每次只能上1个或者2个台阶，那么到达顶端共有多少种不同的方法？ 确定状态 dp[i] 表示有 i 个台阶时的方法数 确定转移方程 dp[i] = dp[i - 1] + dp[i - 2]。 递归加记忆化求解： #include &lt;bits/stdc++.h&gt; #define ll long long #define N 5123 using namespace std; int dp[N]; int F(int n){ if(n == 1 || n == 2)return n; //边界 if(dp[n] != 0)return dp[n]; //记忆化 return F(n - 1) + F(n - 2); // 转移 } int main(){ int n; scanf(“%d”, &amp;n); printf(“%d\\n”, F(n)); } 递推求解： #include &lt;bits/stdc++.h&gt; #define ll long long #define N 5123 using namespace std; int dp[N]; int main(){ int n; scanf(“%d”, &amp;n); dp[1] = 1; dp[2] = 2; //边界 for(int i = 3; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; //转移 printf(“%d\\n”, dp[n]); } 什么是背包问题？ 动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。背包问题是动态规划问题的一种类型。 一 0-1背包问题 简化的 01-背包 ——装箱问题 题目链接：（https://www.acwing.com/problem/content/1026/） 题目大意：有一个箱子容量为 V，同时有 n 个物品，每个物品有一个体积（正整数）。 要求 n 个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。 确定状态 dp[i][j] 表示前 i 个物品能否组成体积 j 确定转移方程 dp[i][j] = 1 (f[i - 1][j] == 1 || f[i - 1][j - v[i]] == 1) dp[i][j] = 0 (else) 列表验证 样例输入: 24 6 ​ 8 3 12 7 9 7 样例输出：0 递推解决 #include &lt;bits/stdc++.h&gt; #define ll long long #define N 21234 using namespace std; int dp[31][N], a[31]; int main() { int v, n; scanf(“%d %d”, &amp;v, &amp;n); for(int i = 1; i &lt;= n; i++)scanf(“%d”, &amp;a[i]); dp[0][0] = 1; int ans = v; for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= v; j++){ if(dp[i - 1][j] == 1)dp[i][j] = 1; if(j - a[i] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i]] == 1)dp[i][j] = 1; if(dp[i][j] == 1)ans = min(ans, v - j); } } printf(“%d\\n”, ans); } 01滚动 我们可以看到每一行的结果实际上只与上一行有关，所以就可以01滚动——f[i][0,1] 一行记录前一行的值，另一行记录当前行的值…… 就地滚动 对于本题更加常用的方法是就地滚动，顾名思义只用一个一维数组了!之前的状态和当前的状态都记在同一个数组里了！ 比如： for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= v; j++){ if([j] == 1)dp[j] = 1; if(j - a[i] &gt;= 0 &amp;&amp; dp[j - a[i]] == 1)dp[j] = 1; } } 但是简单的变成一维以后有可能发出问题 比如： 假设第一个物品体积3 一个物品被使用了多次！ 如何解决？ 我们只需改变内层循环的顺序即可！ for(int i = 1; i &lt;= n; i++){ for(int j = v; j &gt;= 0; j–){ if([j] == 1)dp[j] = 1; if(j - a[i] &gt;= 0 &amp;&amp; dp[j - a[i]] == 1)dp[j] = 1; } } 问题得到解决！ 0-1背包问题 题目链接：（https://www.acwing.com/problem/content/2/） 题目大意：有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 确定状态 f[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值 确定状态转移方程 两种情况： 1.不放当前物品 f[i][j] = f[i-1][j] 2.放当前物品 f[i][j] = f[i-1][j-c[i]]+w[i] f[i][j]=max{f[i-1][j],f[i-1][j-c[i]]+w[i]} 列表验证 就地滚动 #include &lt;bits/stdc++.h&gt; using namespace std; #define N 2123 #define ll long long int dp[N], u[N], v[N]; int main() { ios::sync_with_stdio(0); int n, w, ans = 0; cin &gt;&gt; n &gt;&gt; w; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; u[i] &gt;&gt; v[i]; } for(int i = 1; i &lt;= n; i++){ for(int j = w; j &gt;= u[i]; j–){ dp[j] = max(dp[j], dp[j - u[i]] + v[i]); ans = max(ans, dp[j]); } } printf(“%d\\n”, ans); return 0; } 二 完全背包问题 题目链接：（https://www.acwing.com/problem/content/3/） 题目大意：有 N 种物品和一个容量为 V 的背包，每种物品都有无限件可用。放入第 i 种物品的费用是 Ci ，价值是 Wi 。求解：将哪些物品装入背包，可使这些物品的耗费的费用总和不超过背包容量，且价值总和最大。 回忆 0-1 背包的就地滚动 回想 0-1 背包就地滚动时错误的代码，之所以错误，是因为每件物品重复使用多次，这恰好符合本题的要求！ 递推求解 #include &lt;bits/stdc++.h&gt; using namespace std; #define N 2123 #define ll long long int dp[N], u[N], v[N]; int main() { ios::sync_with_stdio(0); int n, w, ans = 0; cin &gt;&gt; n &gt;&gt; w; for(int i = 1; i &lt;= n; i++){ cin &gt;&gt; u[i] &gt;&gt; v[i]; } for(int i = 1; i &lt;= n; i++){ for(int j = u[i]; j &lt;= w; j++){ dp[j] = max(dp[j], dp[j - u[i]] + v[i]); ans = max(ans, dp[j]); } } printf(“%d\\n”, ans); return 0; } 三 多重背包 题目链接：（https://www.acwing.com/problem/content/3/） 题目大意：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 问题的转化 对于本题，我们可以将其拆解为 0-1 背包问题解决 如何优化 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int N,V,v[1001],w[1001],dp[2001],s[1001] int a[25000],b[25000]; //2的12次方大于2000，也就是说一个数最多可以拆成12个，故数组容量乘12 cin&gt;&gt;N&gt;&gt;V; memset(dp,0,sizeof(dp)); for(int i=0;i&lt;N;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; int total=0; for(int i=0;i&lt;N;i++) { for(int j=1;j&lt;s[i];j&lt;&lt;=1)//二进制拆分 { a[total]=jw[i];//存价值 b[total++]=jv[i];//存容量 s[i]-=j; } if(s[i])//当s[i]&gt;0; { a[total]=s[i]w[i]; b[total++]=s[i]v[i]; } } for(int i=0;i&lt;total;i++)//01背包 for(int j=V;j&gt;=b[i];j–) dp[j]=max(dp[j],dp[j-b[i]]+a[i]); cout&lt;&lt;dp[V]; return 0; } 四 参考资料 博客：动态规划快速入门：https://www.jianshu.com/p/4dd4717301dc 题目：AcWing题库 参考课件：背包九讲（崔添翼） ​ nwpu2014暑假集训：动态规划2——简单背包问题（dsy）","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://miracle-qsh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]}]}